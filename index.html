<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pulse MATRIX</title>
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #111; font-family: monospace; overflow: hidden; }
    #matrixCanvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; pointer-events: none; display: block; }
    .overlay-bg { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: none; z-index: 1; pointer-events: none; }
    .pulsate-logo { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; animation: pulsefade 3.5s cubic-bezier(0.4,0,0.2,1) infinite; pointer-events: none; opacity: 0.13; object-fit: cover; transition: opacity 0.5s; }
    @keyframes pulsefade { 0% { opacity: 0.13; } 50% { opacity: 0.33; } 100% { opacity: 0.13; } }
    .title-wrap { position: fixed; top: 10vh; width: 100%; z-index: 3; display: flex; align-items: center; justify-content: center; pointer-events: none; }
    .claim-title { font-size: 2.8em; background: linear-gradient(90deg, #05f541, #13752c, #05fc19); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; margin: 0; letter-spacing: 0.05em; font-family: sans-serif; text-align: center; font-weight: 700; }
  .center-wrap { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 4; display: flex; align-items: center; justify-content: center; pointer-events: auto; flex-direction: column; }
  .enter-link { display: inline-block; text-decoration: none; }
  .enter-image { width: min(520px, 60vw); height: auto; filter: drop-shadow(0 0 16px rgba(0,255,0,0.25)); opacity: 0.95; cursor: pointer; transition: transform .15s ease, filter .15s ease; }
  .enter-image:hover { transform: translateY(-2px) scale(1.02); filter: drop-shadow(0 0 22px rgba(0,255,0,0.35)); }
  /* CTA buttons row under ENTER */
  .cta-row { display: flex; gap: 250px; margin-top: 18px; align-items: center; justify-content: center; }
  .cta-image { width: min(160px, 28vw); height: auto; filter: drop-shadow(0 0 12px rgba(0,255,0,0.2)); transition: transform .15s ease, filter .15s ease; }
  .cta-image:hover { transform: translateY(-2px) scale(1.02); filter: drop-shadow(0 0 18px rgba(0,255,0,0.35)); }
  </style>
</head>
<body>
  <canvas id="matrixCanvas"></canvas>
  <div class="overlay-bg"></div>
  <img src="Pics/1.png" class="pulsate-logo" alt="Pulse VP Logo" />
  <div class="center-wrap">
    <a class="enter-link" href="dapp.html" title="Enter the DApp">
      <img class="enter-image" src="Pics/ENTER.png" alt="ENTER" />
    </a>
    <div class="cta-row">
      <a href="https://ipfs.io/ipfs/bafybeiejdzkx2nwoig4nbws6lid2xifjwnl2tfd7qgplutrj5tz545lqlu/dapp.html" title="Open on IPFS gateway V1.03 bafybeiejdzkx2nwoig4nbws6lid2xifjwnl2tfd7qgplutrj5tz545lqlu">
        <img class="cta-image" src="Pics/ipfs.png" alt="IPFS" onerror="this.onerror=null;this.src='Pics/ALL.png';" />
        <div style="margin-top:6px;color:#9f9;font-size:0.72em;text-align:center;letter-spacing:0.04em;">bafy…545lqlu</div>
      </a>
      <a href="https://github.com/PulseMatrix369/ENTER/archive/refs/heads/main.zip" title="Download from GitHub">
        <img class="cta-image" src="Pics/download github.png" alt="Download from GitHub" onerror="this.onerror=null;this.src='Pics/ALL.png';" />
      </a>
    </div>
  </div>

  <script>
    // Matrix rain with occasional hidden words
    (function(){
      const canvas = document.getElementById('matrixCanvas');
      const ctx = canvas.getContext('2d');
      function resizeCanvas(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
      resizeCanvas();
      window.addEventListener('resize', () => {
        resizeCanvas();
        columns = Math.floor(canvas.width / fontSize);
        columnStates = Array(columns).fill().map(() => ({
          y: Math.floor(Math.random() * canvas.height / fontSize),
          speed: Math.random() * 0.8 + 0.2,
          mode: 'gibberish',
          word: '', wordY: 0, wordIndex: 0, holdStart: 0, gradient: null
        }));
      });

      const fontSize = 16;
      let columns = Math.floor(canvas.width / fontSize);
      const maxVisibleWords = 8;         // match dapp.html (limit simultaneous words)
      const minRowOffset = 5;            // avoid top edge
      // match dapp.html list
      const specialWords = [
        'Pulse MATRIX', 'PEGGING', 'Pulse chain', 'HEX', 'Not your keys - NOT your crypto', 'PLS', 'PLSX', 'eHEX', 'pDAI to DORRA',
        'INC', 'Fully Decentralized', 'Follow the pDAI Rabbit', 'Trustless', 'Benevolent', 'Finished product', '5555', '369',
        'The highest of stakes', 'No Admin Keys', 'Immutable', 'FART', 'Richard Heart', 'PulseChain', 'Crypto Revolution',
        'Decentralized Finance', 'Smart Contracts', 'Blockchain Technology', 'Web3 Innovation', 'HEX is the Future',
        '❤❤❤❤yourfriendSOMMI❤❤❤❤', 'SciVive'
      ];
      const glyphs = 'アァイゥエカキクケサシスセタチツテノナニヌabcdefghijklmnopqrstuvwxyz0123456789#$%&*!';
      const gradientColors = [ ['#0099ff','#a64dff'], ['#00bfff','#c724ff'], ['#3399ff','#cc66ff'], ['#66ccff','#9933ff'], ['#99ccff','#9900cc'], ['#66ffff','#9900ff'] ];
      let gradientIndex = 0;
      let columnStates = Array(columns).fill().map(() => ({ y: Math.floor(Math.random() * canvas.height / fontSize), speed: Math.random() * 0.8 + 0.2, mode: 'gibberish', word: '', wordY: 0, wordIndex: 0, holdStart: 0, gradient: null }));

      function countVisibleWords(){ return columnStates.filter(col => col.mode === 'word' || col.holdStart > 0).length; }
      function launchWord(col){
        if (countVisibleWords() >= maxVisibleWords) return;
        // Restrict to outside region: skip middle 50% of columns like dapp.html
        const columnIndex = columnStates.indexOf(col);
        const totalColumns = columnStates.length;
        const leftBoundary = Math.floor(totalColumns * 0.25);
        const rightBoundary = Math.floor(totalColumns * 0.75);
        if (columnIndex >= leftBoundary && columnIndex < rightBoundary) return;

        const word = specialWords[Math.floor(Math.random() * specialWords.length)];
        const safeHeight = canvas.height / fontSize - word.length;
        const minStart = minRowOffset;
        const maxStart = Math.max(minStart + 1, safeHeight);
        col.mode = 'word'; col.word = word; col.wordIndex = 0; col.wordY = Math.floor(Math.random() * (maxStart - minStart) + minStart);
        col.holdStart = 0; col.gradient = gradientColors[gradientIndex % gradientColors.length]; gradientIndex++;
      }
      function drawGradientChar(char, x, y, colors){ const grad = ctx.createLinearGradient(x, y, x, y + fontSize); grad.addColorStop(0, colors[0]); grad.addColorStop(1, colors[1]); ctx.fillStyle = grad; ctx.fillText(char, x, y); }

      function draw(){
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = fontSize + 'px monospace';
        for (let i = 0; i < columns; i++){
          const col = columnStates[i];
          const x = i * fontSize;
          const y = col.y * fontSize;
          let char;
          if (col.mode === 'word'){
            if (col.wordIndex < col.word.length){
              const drawY = (col.wordY + col.wordIndex) * fontSize;
              char = col.word[col.wordIndex];
              drawGradientChar(char, x, drawY, col.gradient);
              col.wordIndex++;
            } else if (col.holdStart === 0){
              col.holdStart = Date.now();
            } else {
              const age = Date.now() - col.holdStart;
              if (age < 5000 + Math.random() * 5000){
                for (let j = 0; j < col.word.length; j++){
                  const drawY = (col.wordY + j) * fontSize;
                  drawGradientChar(col.word[j], x, drawY, col.gradient);
                }
              } else {
                col.mode = 'gibberish'; col.word = ''; col.wordIndex = 0; col.holdStart = 0;
              }
            }
          }
          if (col.mode === 'gibberish'){
            char = glyphs[Math.floor(Math.random() * glyphs.length)];
            ctx.fillStyle = '#00ff00';
            ctx.fillText(char, x, y);
            col.y += col.speed;
            if (y > canvas.height){
              col.y = -Math.floor(Math.random() * 10);
              if (Math.random() < 0.05){ launchWord(col); }
            }
          }
        }
      }

      setInterval(draw, 50);
    })();
  </script>
</body>
</html>
