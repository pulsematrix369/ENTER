<!DOCTYPE html>
<html lang="en">
  
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PuMa Dapp</title>
 <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="coinConfigs.js"></script>
  <script src="AllVaultABI.js"></script>
  <script>
    // Default to PulseChain Testnet V4 when no wallet is connected
    window.DEFAULT_CHAIN_ID = 943;
  // Honor previously selected read network across reloads
  try { if (typeof window !== 'undefined') { const saved = Number(localStorage.getItem('READ_CHAIN_ID')); if (saved===369 || saved===943) window.__READ_CHAIN_ID = saved; } } catch {}
    window.PULSE_RPC = {
      369: 'https://rpc.pulsechain.com',
      943: 'https://rpc.v4.testnet.pulsechain.com'
    };
    // Fetch public matrices from Google Sheets API and merge into window.coinConfigs (with polling + cache + optional CF fallback)
    (function(){
      const toDec = x=>{try{return typeof x==='string'&&x.startsWith('0x')?parseInt(x,16):Number(x)||null;}catch{return null}};
      async function detectChainId(){
        let cid=null; if(window.ethereum?.chainId) cid=toDec(window.ethereum.chainId);
        if(!cid&&window.ethereum?.request){ try{ const hex=await window.ethereum.request({method:'eth_chainId'}); cid=toDec(hex);}catch{}}
        if(!cid) cid = Number(localStorage.getItem('FACTORY_SELECTED_CHAIN')) || (window.DEFAULT_CHAIN_ID?Number(window.DEFAULT_CHAIN_ID):369);
        return cid;
      }
      const API = (function(){ try { return window.MATRICES_API_URL || localStorage.getItem('MATRICES_API_URL') || 'https://script.google.com/macros/s/AKfycbyEyspSK4xDspCjOnbacvtqIVER9Di9m2zHw4go3y46rr0AZlTrc8Lg-HgVCApQbP0L_Q/exec'; } catch { return 'https://script.google.com/macros/s/AKfycbyEyspSK4xDspCjOnbacvtqIVER9Di9m2zHw4go3y46rr0AZlTrc8Lg-HgVCApQbP0L_Q/exec'; } })();
      const CF_API = (function(){ try { return window.MATRICES_CF_API_URL || localStorage.getItem('MATRICES_CF_API_URL') || ''; } catch { return ''; } })();
      async function tryJson(url){ try{ const r=await fetch(url,{ cache:'no-cache' }); return await r.json(); }catch{return null;} }
      function tryJsonp(url){
        return new Promise(resolve => {
          const cbName = '__coinCfgCb_' + Math.random().toString(36).slice(2);
          const s = document.createElement('script');
          window[cbName] = (data)=>{ try{ resolve(data); } finally { try{ delete window[cbName]; }catch{} try{ s.remove(); }catch{} } };
          s.src = url + (url.includes('?')?'&':'?') + 'callback=' + cbName;
          s.onerror = ()=>{ try{ delete window[cbName]; }catch{} try{ s.remove(); }catch{} resolve(null); };
          try { document.head.appendChild(s); } catch { resolve(null); }
        });
      }
      function signature(cfgs){ try{ const keys=(cfgs||[]).map(c=>String(c.vault||'').toLowerCase()).sort(); return keys.join(','); }catch{ return ''; } }
      function cacheKey(cid){ return `coinConfigsSheets:${cid}`; }
      function loadCache(cid){ try{ const raw=localStorage.getItem(cacheKey(cid)); return raw? JSON.parse(raw): null; }catch{ return null; } }
      function saveCache(cid,data){ try{ localStorage.setItem(cacheKey(cid), JSON.stringify({ t: Date.now(), data })); }catch{} }
      async function loadOnce(){
        const cid = window.__READ_CHAIN_ID || await detectChainId();
        let res = await tryJson(API + '?chainId=' + cid);
        let serverItems = Array.isArray(res) ? res : (res && Array.isArray(res.items) ? res.items : null);
        if(!Array.isArray(serverItems) || serverItems.length===0){
          const jp = await tryJsonp(API + '?chainId=' + cid);
          serverItems = Array.isArray(jp) ? jp : (jp && Array.isArray(jp.items) ? jp.items : null);
        }
        if((!Array.isArray(serverItems) || serverItems.length===0) && CF_API){
          const cf = await tryJson(CF_API + (CF_API.includes('?')?'&':'?') + 'chainId=' + cid);
          serverItems = Array.isArray(cf) ? cf : (cf && Array.isArray(cf.items) ? cf.items : null);
        }
        if(Array.isArray(serverItems)){
          let scoped = serverItems.filter(x=> Number(x.chainId||cid)===cid || x.chainId==null || String(x.chainId).trim()==='');
          if(scoped.length===0) scoped = serverItems;
          const extras = scoped.map(x=>{
            const is4 = (x.abiKey && /4x4/i.test(x.abiKey)) || /4x4/.test(String(x.name||'')) || Number(x.vpSize)===4;
            const rawKey = x.abiKey || (is4 ? 'PuMa4x4' : 'PuMa3x3');
            const abiKey = (window.AllVaultABI && window.AllVaultABI[rawKey]) ? rawKey : (is4 ? 'PuMa4x4' : 'PuMa3x3');
            return {
              name: x.name || 'newMatrix',
              vault: x.vault,
              token: x.token,
              abiKey,
              decimals: Number(x.decimals||18),
              color: x.color||'#00c3ff',
              chainId: Number(x.chainId||cid),
              receipt: x.receipt,
              vpSize: x.vpSize,
              approved: x.approved,
              active: x.active,
              createdAt: x.createdAt,
              updatedAt: x.updatedAt,
              version: x.version,
              tokenName: x.tokenName,
              tokenSymbol: x.tokenSymbol || x.symbol,
              entryFee: x.entryFee
            };
          }).filter(e=>!!e.vault);
          saveCache(cid, extras);
          const base = Array.isArray(window.coinConfigs)? window.coinConfigs : [];
          const keyOf = (x)=> ((x?.vault||'').toLowerCase() + '::' + String(Number(x?.chainId ?? cid)));
          const map = new Map();
          for(const b of base){ map.set(keyOf(b), b); }
          for(const e of extras){ map.set(keyOf(e), e); }
          const merged = Array.from(map.values());
          const prevSig = window.__sheetsLastSig || '';
          const nextSig = signature(merged);
          if(prevSig !== nextSig){
            window.coinConfigs = merged;
            window.__sheetsLastSig = nextSig;
            try { console.log('Merged coinConfigs from Sheets', {cid, added: extras.length, total: merged.length}); } catch{}
            try { window.dispatchEvent(new CustomEvent('coinConfigsReady', { detail: { chainId: cid, count: merged.length, source:'sheets' } })); } catch{}
          }
        } else {
          const cached = loadCache(cid);
          const extras = Array.isArray(cached?.data) ? cached.data : [];
          if (extras.length > 0) {
            const base = Array.isArray(window.coinConfigs)? window.coinConfigs : [];
            const keyOf = (x)=> ((x?.vault||'').toLowerCase() + '::' + String(Number(x?.chainId ?? cid)));
            const map = new Map();
            for(const b of base){ map.set(keyOf(b), b); }
            for(const e of extras){ map.set(keyOf(e), e); }
            const merged = Array.from(map.values());
            const prevSig = window.__sheetsLastSig || '';
            const nextSig = signature(merged);
            if(prevSig !== nextSig){
              window.coinConfigs = merged;
              window.__sheetsLastSig = nextSig;
              try { console.warn('Using cached coinConfigs (Sheets fallback)', {cid, cached: extras.length, total: merged.length}); } catch{}
              try { window.dispatchEvent(new CustomEvent('coinConfigsReady', { detail: { chainId: cid, count: merged.length, source:'sheets-cache' } })); } catch{}
            }
          } else {
            try { console.warn('Sheets fetch failed and no cache available', {cid}); } catch {}
          }
        }
      }
      loadOnce();
      setInterval(loadOnce, 30000);
      try {
        const raw = localStorage.getItem('localMatrices');
        const arr = raw ? JSON.parse(raw) : [];
        if (Array.isArray(arr) && arr.length) {
          const base = Array.isArray(window.coinConfigs) ? window.coinConfigs : [];
          const keyOf = (x)=> ((x?.vault||'').toLowerCase() + '::' + String(Number(x?.chainId || window.__READ_CHAIN_ID || 369)));
          const map = new Map();
          for(const b of base){ map.set(keyOf(b), b); }
          for (const e of arr) { map.set(keyOf(e), e); }
          const merged = Array.from(map.values());
          const prevSig = window.__sheetsLastSig || '';
          const nextSig = signature(merged);
          if (prevSig !== nextSig) {
            window.coinConfigs = merged;
            window.__sheetsLastSig = nextSig;
            try { window.dispatchEvent(new CustomEvent('coinConfigsReady', { detail: { chainId: (window.__READ_CHAIN_ID||943), count: merged.length, source:'local-cache' } })); } catch{}
          }
        }
      } catch {}
      window.addEventListener('newContractDeployed', () => {
        try {
          const data = Array.isArray(window.coinConfigsData) ? window.coinConfigsData : [];
          localStorage.setItem('localMatrices', JSON.stringify(data));
        } catch {}
      });
    })();
  </script>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; font-family: monospace; background: #111; }
    
    #matrixCanvas {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
                        /* Softer style just for the 4-Color State System */
                        .states-box{background:rgba(0,20,0,0.25);border:1px solid rgba(0,255,0,0.14);box-shadow:none}
                        .states-box .highlight-box{background:rgba(0,50,0,0.15);border-left:3px solid rgba(0,255,0,0.22)}
                        .states-box .math-example{background:rgba(0,35,0,0.18);border:1px solid rgba(0,255,0,0.14)}
                        .states-box h5{color:#a8f0a8}
                        .states-box ul{margin-top:.4em}
                        .states-box li{opacity:.9}
      z-index: 0;
      pointer-events: none;
      display: block;
    }
    .overlay-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: none;
      z-index: 1;
      pointer-events: none;
    }
    .pulsate-logo {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 2;
      animation: pulsefade 3.5s cubic-bezier(0.4,0,0.2,1) infinite;
      pointer-events: none;
      opacity: 0.13;
      object-fit: cover;
      transition: opacity 0.5s;
    }
    @keyframes pulsefade {
      0% { opacity: 0.13; }
      50% { opacity: 0.33; }
      100% { opacity: 0.13; }
    }
    
    .carousel-nav-bar {
      position: fixed;
      top: 0;
      width: 7vw;
      height: 100vh;
      background: rgba(0,0,0,0.4);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    .carousel-nav-bar.left { left: 0; border-top-right-radius: 2em; border-bottom-right-radius: 2em; }
    .carousel-nav-bar.right { right: 0; border-top-left-radius: 2em; border-bottom-left-radius: 2em; }
    .carousel-nav-arrow {
      font-size: 5em;
      color: #087a0e;
      opacity: 0.5;
      pointer-events: none;
      transition: opacity 0.2s, color 0.2s;
    }
    /* Quick nav button stack over the left bar */
    .quick-nav-stack {
      position: fixed;
      top: 12px;
      left: 0;
      width: 7vw; /* match left bar width */
      z-index: 101; /* above the bars */
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
      pointer-events: none; /* allow underlying nav unless on buttons */
    }
    .quick-nav-btn {
      box-sizing: border-box;
      pointer-events: auto;
      width: 100%;
      background: #000;
      color: #00ff00;
      border: 1.5px solid #00ff00;
      border-radius: 10px;
  padding: 8px 6px;
      font-size: 0.72rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
  box-shadow: 0 6px 18px rgba(0,255,0,0.18);
      line-height: 1.2;
      height: 40px; /* fixed to match search */
    }
    /* Ensure search control matches button exact height/box model */
    .quick-nav-search { box-sizing: border-box; height: 40px; }
    /* Quick-nav inline search (button-like input + icon) */
    .quick-nav-search {
      pointer-events: auto;
      width: 100%;
      display: flex;
      align-items: center;
      gap: 6px;
      background: #000;
      border: 1.5px solid #00ff00;
      border-radius: 10px;
      padding: 8px 6px; /* match .quick-nav-btn */
      box-shadow: 0 6px 18px rgba(0,255,0,0.18);
      overflow: hidden;
      position: relative; /* allow absolute icon placement */
    }
    .quick-nav-search input {
      flex: 1;
      min-width: 0; /* allow flex shrink so icon stays visible */
      background: transparent;
      border: none;
      outline: none;
      color: #00ff00;
      font-size: 0.72rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      padding: 0 22px 0 0; /* add right padding so text doesn’t overlap the icon */
      line-height: 24px; /* visually center text within 40px height with 8px vertical padding */
    }
    .quick-nav-search button {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      background: transparent;
      color: #00ff00;
      border: none;
      border-radius: 6px;
      padding: 0;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .quick-nav-search button:hover { background: rgba(0,255,0,0.08); }
    .carousel-nav-bar:hover .carousel-nav-arrow {
      opacity: 0.9;
      color: #07f013;
    }
    .carousel-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100vw;
      min-height: 100vh;
      background: none;
      z-index: 2;
      position: relative;
      top: 20px;
    }
    .carousel-title {
      font-size: 2.5em;
      background: linear-gradient(90deg, #05f541, #13752c, #05fc19);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-top: 0;
      margin-bottom: 1.2rem;
      letter-spacing: 0.05em;
      font-family: sans-serif;
      text-shadow: none;
      animation: none;
      position: static;
    }
    .carousel {
      display: flex;
      align-items: flex-start; /* lock to top */
      justify-content: center;
      position: relative;
      width: 90vw;
  /* let cards grow with content */
  max-height: none;
  height: auto;
      margin: 0 auto;
      transition: transform 0.5s cubic-bezier(.4,2,.6,1);
    }
  .MAIN-card {
      /* Remove position: absolute so card expands with content */
      /* position: absolute; */
      position: relative; /* allow absolutely positioned children like the fox button */
      left: unset;
      top: unset;
      transform: none;
      width: 90vw; 
      min-height: 300px;
      max-width: 75%; 
  /* allow the card to grow with inner content */
  max-height: none;
  height: auto;
      background: rgba(30,30,30,0.8);
      border-radius: 2em;
      box-shadow: 0 8px 32px #000a;
  border: 1.5px solid rgba(0,255,0,0.30); /* thin green line around main card */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      transition: transform 0.4s, opacity 0.4s;
  z-index: 150;
      /* Remove cursor:pointer so only buttons/images are clickable */
  color: #00ff00;
      text-align: center;
  overflow: visible;
      /* allow vertical scroll if content overflows (handled by page, not card) */
  /* extra space so fixed footer never overlaps */
  padding-bottom: 4.8em;
      margin-top: 0; /* ensure no extra margin */
    }
    .MAIN-card img {
      width: 15vw;
      max-width: 140px;
      height: auto;
      object-fit: contain;
      border-radius: 1em;
      margin-top: 20px;
      margin-bottom: 1em;
  cursor: default;
  /* green glow around coin image like indexok */
  box-shadow: 0 0 28px rgba(0,255,0,0.35), 0 0 6px rgba(0,255,0,0.25) inset;
  outline: 1px solid rgba(0,255,0,0.25);
    }
    .MAIN-card .token-title {
      font-size: 1.5em;
      background: linear-gradient(90deg, #0cfc5c, #068f1d, #05eb52);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5em;
    }
    .MAIN-card .token-desc {
      font-size: 1em;
      color: #358542;
      text-align: center;
    }
    .wallet-info {
      font-size: 0.9em;
      color: #00ff00;
      margin: 1em 0;
      word-break: break-all;
      font-family: monospace;
      text-align: center;
    }
    .MAIN-card.side {
      opacity: 0.5;
      transform: translate(-50%, -50%) scale(0.7);
      z-index: 2;
      filter: blur(1px);
    }
    .MAIN-card.hidden {
      opacity: 0;
      pointer-events: none;
      z-index: 1;
    }
    /* INFO-card: inner stats/action card; 50% of MAIN-card width */
  .INFO-card {
      margin-top: 1.2em;
      /* Green-tint overlay like indexok + dark base */
      background: linear-gradient(0deg, rgba(0,255,0,0.05), rgba(0,255,0,0.05)), rgba(30,30,30,0.8);
      border-radius: 1.2em;
      padding: 1.2em 2.2em;
      font-size: 1.15em;
  color: #00ff00;
      box-shadow: 0 2px 8px #0004;
      border: 1.5px solid rgba(0,255,0,0.30); /* thin green line like indexok */
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.7em;
      width: 50%;            /* 50% of MAIN-card */
      min-width: 270px;      /* keep usability on small screens */
      margin-left: auto;
      margin-right: auto;
    }
    /* Indent the metrics text inside INFO-card by 20% from left border */
    .INFO-metrics {
      width: 100%;
      box-sizing: border-box;
      margin-left: 20%;   /* indent 20% from left border without affecting background */
      padding-left: 0;
      text-align: left;
      margin-bottom: 0.8em; /* breathing room above the button */
    }
  /* OPEN-card and DEV-card: 75% of MAIN-card with green outline */
  .OPEN-card, .HISTORY-card, .DEV-card, .VIEW-card {
      background: rgba(0,0,0,0.7);
      border-radius: 1em;
      padding: 1.2em;
  color: #00ff00;
      /* Exactly 75% of MAIN-card (parent container) */
      width: 75%;
      box-sizing: border-box;    /* include padding/border in the 75% width */
      margin-left: auto;
      margin-right: auto;
  /* extra breathing room at bottom so footer bar never overlaps */
  margin-bottom: 3.6em;
      box-shadow: 0 2px 8px #000a;
      border: 1.5px solid rgba(0,255,0,0.30); /* thin green line like indexok */
      text-align: left;
      position: relative; /* allow absolute-positioned EOL timer overlay */
  /* grow naturally with content */
  height: auto;
  max-height: none;
  overflow: visible;
    }
    @media (max-width: 900px) {
      .INFO-card { width: 85%; }
      .INFO-metrics { margin-left: 10%; }
    }
    @media (max-width: 700px) {
      .INFO-card { width: 92%; }
      .INFO-metrics { margin-left: 6%; }
    }
    @media (max-width: 900px) {
  .carousel, .carousel.up { width: 98vw; height: auto; max-height: none; }
  .MAIN-card { width: 98vw; height: auto; max-height: none; }
      .MAIN-card img { width: 30vw; max-width: 100px; }
    }
    @media (max-width: 700px) {
  .carousel, .carousel.up { width: 98vw; height: auto; max-height: none; }
  .MAIN-card { width: 98vw; height: auto; max-height: none; }
      .MAIN-card img { width: 40vw; max-width: 70px; }
    }
  /* Reserve space for the fixed support footer across the page */
  body { padding-bottom: 84px; }
  /* Ensure ALL view and other containers also reserve space */
  #all-view-root { padding-bottom: 84px; }
  </style>
</head>
<body>
  <!-- Simple network toggle: choose read network independent of wallet for accurate code checks -->
  <div id="read-net-toggle" style="position:fixed;top:8px;right:10px;z-index:9999;display:flex;gap:6px;font-family:monospace;">
    <button id="btn-testnet" style="padding:6px 10px;border-radius:8px;border:1px solid #0f0;background:#000;color:#0f0;cursor:pointer;transition:all .2s ease;">Testnet V4</button>
    <button id="btn-mainnet" style="padding:6px 10px;border-radius:8px;border:1px solid #0f0;background:#000;color:#0f0;cursor:pointer;transition:all .2s ease;">MainNet</button>
  </div>
  <script>
    (function(){
      function hexChainId(n){ try { return '0x' + Number(n).toString(16); } catch { return '0x0'; } }
      async function ensureWalletOnChain(targetCid){
        if (!window.ethereum) return false;
        try {
          await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: hexChainId(targetCid) }] });
          return true;
        } catch (err) {
          // Unrecognized chain -> try add then switch
          if (err && (err.code === 4902 || String(err.message||'').includes('Unrecognized'))) {
            try {
              const params = (targetCid===943) ? [{
                chainId: hexChainId(943), chainName: 'PulseChain Testnet v4', nativeCurrency: { name:'tPLS', symbol:'tPLS', decimals:18 },
                rpcUrls: ['https://rpc.v4.testnet.pulsechain.com'], blockExplorerUrls: ['https://scan.v4.testnet.pulsechain.com']
              }] : [{
                chainId: hexChainId(369), chainName: 'PulseChain', nativeCurrency: { name:'PLS', symbol:'PLS', decimals:18 },
                rpcUrls: ['https://rpc.pulsechain.com'], blockExplorerUrls: ['https://scan.pulsechain.com']
              }];
              await window.ethereum.request({ method: 'wallet_addEthereumChain', params });
              await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: hexChainId(targetCid) }] });
              return true;
            } catch { return false; }
          }
          return false;
        }
      }
      function paintActive(){
        const testBtn = document.getElementById('btn-testnet');
        const mainBtn = document.getElementById('btn-mainnet');
        if (!testBtn || !mainBtn) return;
        const cid = Number(window.__READ_CHAIN_ID||943);
        const setActive = (el)=>{ el.style.boxShadow='0 0 12px rgba(0,255,0,0.5)'; el.style.opacity='1'; el.style.filter='none'; el.setAttribute('aria-pressed','true'); };
        const setInactive = (el)=>{ el.style.boxShadow='none'; el.style.opacity='0.45'; el.style.filter='grayscale(40%)'; el.setAttribute('aria-pressed','false'); };
        if (cid === 943) { setActive(testBtn); setInactive(mainBtn); }
        else if (cid === 369) { setActive(mainBtn); setInactive(testBtn); }
        else { setInactive(testBtn); setInactive(mainBtn); }
      }
      async function setReadChain(cid){
        // Try to switch wallet network as well
        try { await ensureWalletOnChain(Number(cid)); } catch {}
        try { window.__READ_CHAIN_ID = Number(cid); localStorage.setItem('READ_CHAIN_ID', String(cid)); } catch {}
        // Simple refresh to re-pull stats and sheets listing under the selected chain
        try { location.reload(); } catch {}
      }
      const testBtn = document.getElementById('btn-testnet');
      const mainBtn = document.getElementById('btn-mainnet');
      if (testBtn) testBtn.onclick = async ()=> { await setReadChain(943); };
      if (mainBtn) mainBtn.onclick = async ()=> { await setReadChain(369); };
      paintActive();
    })();
  </script>
  <script>
    // Expose simple helpers for FAQ buttons to add networks to wallet
    (function(){
      function hasEth(){ return typeof window !== 'undefined' && window.ethereum && typeof window.ethereum.request === 'function'; }
      async function addChain(params){
        if (!hasEth()) { alert('No injected wallet detected. Please install MetaMask or a compatible wallet.'); return; }
        try { await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [params] }); }
        catch (err) { console.error('addEthereumChain error:', err); alert('Wallet rejected or does not support adding networks.'); }
      }
      window.addPulseMainnet = async function(){
        await addChain({
          chainId: '0x171', // 369
          chainName: 'PulseChain',
          nativeCurrency: { name:'PLS', symbol:'PLS', decimals:18 },
          rpcUrls: ['https://rpc.pulsechain.com'],
          blockExplorerUrls: ['https://scan.pulsechain.com']
        });
      };
      window.addPulseTestnet = async function(){
        await addChain({
          chainId: '0x3AF', // 943
          chainName: 'PulseChain Testnet v4',
          nativeCurrency: { name:'tPLS', symbol:'tPLS', decimals:18 },
          rpcUrls: ['https://rpc.v4.testnet.pulsechain.com'],
          blockExplorerUrls: ['https://scan.v4.testnet.pulsechain.com']
        });
      };
    })();
  </script>
  <!-- Matrix Background Canvas -->
  <canvas id="matrixCanvas"></canvas>
  <div class="overlay-bg"></div>
  <img src="Pics/1.png" alt="Pulsate Logo" class="pulsate-logo" />

  <div id="react-root"></div>

  <script>
    // Matrix Background Animation with HIDDEN MESSAGES and ALIEN SCRIPT
  function initMatrixBackground() {
      console.log('Initializing matrix background...');
      const canvas = document.getElementById('matrixCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

  const fontSize = 16;
  let columnStates = [];
  let columns = 0;

      function initColumns() {
        columns = Math.floor(canvas.width / fontSize);
        columnStates = Array(columns).fill().map(() => ({
          y: Math.floor(Math.random() * canvas.height / fontSize),
          speed: Math.random() * 0.8 + 0.2,
          mode: 'gibberish',
          word: '',
          wordY: 0,
          wordIndex: 0,
          holdStart: 0,
          gradient: null
        }));
      }

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        initColumns();
      }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
      const maxVisibleWords = 8;
      const minRowOffset = 5;

      // HIDDEN MESSAGES that appear in the matrix!
      const specialWords = [
        'Pulse MATRIX', 'PEGGING', 'Pulse chain', 'HEX','Not your keys - NOT your crypto', 'PLS', 'PLSX', 'eHEX', 'pDAI to DORRA',
        'INC','Not your keys NOT yor crypto', 'pDAI', 'Fully Decentralized','Follow the pDAI Rabbit', 'Trustless', 'Benevolent',
        'Finished product', '5555', '369', 'The highest of stakes','No Admin Keys','FART', 'Immutable', 'Richard Heart', 'PulseChain', 
        'Crypto Revolution', 'Decentralized Finance', 'Smart Contracts', 'Blockchain Technology', 
        'Web3 Innovation', 'HEX is the Future', '❤❤❤❤yourfriendSOMMI❤❤❤❤', 'SciVive'
      ];

      // ALIEN SCRIPT mixed with normal characters
      const glyphs = 'アァイゥエカキクケサシスセタチツテノナニヌabcdefghijklmnopqrstuvwxyz0123456789#$%&*!';

      const gradientColors = [
        ['#0099ff', '#a64dff'],
        ['#00bfff', '#c724ff'],
        ['#3399ff', '#cc66ff'],
        ['#66ccff', '#9933ff'],
        ['#99ccff', '#9900cc'],
        ['#66ffff', '#9900ff']
      ];

  let gradientIndex = 0;

      function countVisibleWords() {
        return columnStates.filter(col => col.mode === 'word' || col.holdStart > 0).length;
      }

      function launchWord(col) {
        if (countVisibleWords() >= maxVisibleWords) return;
        const columnIndex = columnStates.indexOf(col);
        const totalColumns = columnStates.length;
        const leftBoundary = Math.floor(totalColumns * 0.25);
        const rightBoundary = Math.floor(totalColumns * 0.75);
        if (columnIndex >= leftBoundary && columnIndex < rightBoundary) return; // skip middle 50%

        const word = specialWords[Math.floor(Math.random() * specialWords.length)];
        const safeHeight = canvas.height / fontSize - word.length;
        const minStart = minRowOffset;
        const maxStart = Math.max(minStart + 1, safeHeight);
        col.mode = 'word';
        col.word = word;
        col.wordIndex = 0;
        col.wordY = Math.floor(Math.random() * (maxStart - minStart) + minStart);
        col.holdStart = 0;
        col.gradient = gradientColors[gradientIndex % gradientColors.length];
        gradientIndex++;
      }

      function drawGradientChar(char, x, y, colors) {
        const grad = ctx.createLinearGradient(x, y, x, y + fontSize);
        grad.addColorStop(0, colors[0]);
        grad.addColorStop(1, colors[1]);
        ctx.fillStyle = grad;
        ctx.fillText(char, x, y);
      }

      function draw() {
        // fade previous frame slightly to create trail and disappearance
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = fontSize + 'px monospace';
        for (let i = 0; i < columns; i++) {
          const col = columnStates[i];
          const x = i * fontSize;
          const y = col.y * fontSize;
          if (col.mode === 'word') {
            if (col.wordIndex < col.word.length) {
              const drawY = (col.wordY + col.wordIndex) * fontSize;
              const char = col.word[col.wordIndex];
              drawGradientChar(char, x, drawY, col.gradient);
              col.wordIndex++;
            } else if (col.holdStart === 0) {
              col.holdStart = Date.now();
            } else {
              const age = Date.now() - col.holdStart;
              if (age < 5000 + Math.random() * 5000) {
                for (let j = 0; j < col.word.length; j++) {
                  const drawY = (col.wordY + j) * fontSize;
                  drawGradientChar(col.word[j], x, drawY, col.gradient);
                }
              } else {
                col.mode = 'gibberish';
                col.word = '';
                col.wordIndex = 0;
                col.holdStart = 0;
              }
            }
          } else {
            const ch = glyphs[Math.floor(Math.random() * glyphs.length)];
            ctx.fillStyle = '#00ff00';
            ctx.fillText(ch, x, y);
            col.y += col.speed;
            if (y > canvas.height) {
              col.y = -Math.floor(Math.random() * 10);
              if (Math.random() < 0.05) launchWord(col);
            }
          }
        }
      }
      // cooldown timer
      setInterval(draw, 50);
    }
    window.addEventListener('load', function() { initMatrixBackground(); });
  </script>

  <script type="text/babel">
    console.log('Starting React app...');

    // --- Utility ---
    function mod(n, m) { return ((n % m) + m) % m; }
    function formatAmount(val, decimals = 18) {
      if (val === undefined || val === null || val === '—' || val === '…' || isNaN(Number(val))) return '0';
      let n = Number(val);
      // If value is a big integer (e.g. 555500000000000000000), format as token amount
      if (n > 1e9 && decimals > 0) {
        n = n / Math.pow(10, decimals);
      }
      // Show up to 4 decimals, trim trailing zeros
      return n.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 4 });
    }

    // --- Carousel Pages ---
    const extraPages = [
  { name: 'ALL', img: 'Pics/ALL.png', desc: 'All matrices overview' },
      { name: 'Factory', img: 'Pics/factory.png', desc: 'make your own Matrix with your own coin!' }
    ];

    // Static coin data - now with contract integration
    // Helper: pick config by name preferring current read chainId
    const __READ_CID = Number(window.__READ_CHAIN_ID || 943);
    function pickConfigByName(name, cid){
      try {
        const list = Array.isArray(window.coinConfigs) ? window.coinConfigs : [];
  // Strict: only return configs for the selected chain; do NOT fallback across chains
  const m = list.find(c => c && c.name === name && Number(c.chainId) === Number(cid));
  return m || null;
      } catch { return null; }
    }

    const staticCoins = [
      {
        name: "PuMa 3x3",
        img: "Pics/PuMa.png",
        matrixSize: "3",
        desc: "PuMa 3x3 matrix system - Fast 3x3 matrix with 5.555x payout multiplier",
        config: pickConfigByName("PuMa 3x3", __READ_CID)
      },
      {
        name: "PuMa 4x4", 
        img: "Pics/PuMa.png",
        matrixSize: "4",
        desc: "PuMa 4x4 matrix system - High stakes 4x4 matrix with 55.55x payout multiplier",
        config: pickConfigByName("PuMa 4x4", __READ_CID)
      },
      {
        name: "PLS 3x3",
        img: "Pics/PLS.png", 
        matrixSize: "3",
        desc: "PLS 3x3 matrix system - Fast 3x3 matrix with 5.555x payout multiplier",
        config: pickConfigByName("PLS 3x3", __READ_CID)
      },
      {
        name: "PLS 4x4",
        img: "Pics/PLS.png",
        matrixSize: "4", 
        desc: "PLS 4x4 matrix system - High stakes 4x4 matrix with 55.55x payout multiplier",
        config: pickConfigByName("PLS 4x4", __READ_CID)
      }
    ];

    // Build tokens array: ordered coins + extra pages
    const tokens = [
          ...staticCoins,
          ...extraPages,
          {
            name: 'Comprehensive Documentation & FAQ',
            img: 'Pics/FAQ.png',
            desc: 'Comprehensive FAQ & Documentation'
          }
    ];

    console.log('Tokens array:', tokens);
    // Default = FAQ page index (bookmark override via hash)
    const FAQ_NAME = 'Comprehensive Documentation & FAQ';
    const DEFAULT_INDEX = tokens.findIndex(t => t.name === FAQ_NAME) >= 0 ? tokens.findIndex(t => t.name === FAQ_NAME) : 0;

    // --- Bookmark (hash) utilities ---
    function slugifyToken(name){
      return name.toLowerCase()
        .replace(/&/g,'and')
        .replace(/[^a-z0-9]+/g,'-')
        .replace(/^-|-$/g,'');
    }
    function getIndexFromHash(){
      const m = window.location.hash.match(/page=([^&]+)/i);
      if(!m) return DEFAULT_INDEX;
      const wanted = m[1].toLowerCase();
      const idx = tokens.findIndex(t => slugifyToken(t.name) === wanted);
      return idx >= 0 ? idx : DEFAULT_INDEX;
    }

    // ===== ADD TO METAMASK FUNCTION  =====
    async function addTokenToMetaMask(tokenConfig) {
      if (!window.ethereum) {
        alert('MetaMask not found. Please install MetaMask to add tokens.');
        return;
      }

      try {
        const tokenAddress = tokenConfig.token;
        const tokenDecimals = tokenConfig.decimals || 18;
        // Try to get symbol from chain, with timeout fallback
        let tokenSymbol = 'UNKNOWN';
        try {
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const code = await provider.getCode(tokenAddress);
          if (code === '0x') throw new Error('Contract not deployed');
          const tokenAbi = ["function symbol() view returns (string)"];
          const token = new ethers.Contract(tokenAddress, tokenAbi, provider);
          const symbolPromise = token.symbol();
          const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 3000));
          tokenSymbol = await Promise.race([symbolPromise, timeout]);
        } catch (e) {
          tokenSymbol = tokenConfig.name && tokenConfig.name.includes('PuMa') ? 'PUMA' : 'PLS';
        }

        const tokenImage = tokenConfig.name && tokenConfig.name.includes('PuMa')
          ? 'https://pulsematrix.app/Pics/PuMa.png'
          : 'https://pulsematrix.app/Pics/PLS.png';

        const wasAdded = await window.ethereum.request({
          method: 'wallet_watchAsset',
          params: {
            type: 'ERC20',
            options: { address: tokenAddress, symbol: tokenSymbol, decimals: tokenDecimals, image: tokenImage }
          }
        });

        if (wasAdded) alert(`✅ ${tokenSymbol} successfully added to MetaMask!`);
        else alert('Token addition was cancelled.');
      } catch (error) {
        if (error.code === 4001) alert('Token addition was cancelled by user.');
        else alert('Failed to add token to MetaMask: ' + (error.message || error));
      }
    }

    // ===== Provider selection (read-only) =====
  function getReadProvider() {
      try {
    const wanted = Number(window.__READ_CHAIN_ID || (typeof localStorage!=='undefined' && localStorage.getItem('READ_CHAIN_ID')) || 943);
        // Prefer wallet provider if it’s already on the desired chain (no await; use ethereum.chainId)
        if (typeof window !== 'undefined' && window.ethereum && window.ethereum.chainId) {
          try {
            const walletCid = parseInt(String(window.ethereum.chainId), 16);
            if (walletCid === wanted) {
              return new ethers.providers.Web3Provider(window.ethereum);
            }
          } catch {}
        }
        // Fallback to known RPC endpoints
        const RPCS = {
          943: (window.PULSE_RPC && window.PULSE_RPC[943]) || 'https://rpc.v4.testnet.pulsechain.com',
          369: (window.PULSE_RPC && window.PULSE_RPC[369]) || 'https://rpc.pulsechain.com'
        };
        const url = RPCS[wanted] || RPCS[943];
        return new ethers.providers.JsonRpcProvider(url);
      } catch {
        // Ultimate fallback
        return new ethers.providers.JsonRpcProvider('https://rpc.v4.testnet.pulsechain.com');
      }
    }

    // ===== Open VP utilities (fixed vpId vs tokenId logic) =====
    function getVPStructureSize(matrixSize) { return matrixSize === 3 ? 13 : 85; }
    function getPaySpacing(matrixSize) { return matrixSize === 3 ? 9 : 64; }

    // Absolute base (tokenId) for current cycle (pre-EOL: 0; post-EOL: lastEOLTriggerEntry)
    function getCycleBase(lastEOLTriggerEntry = 0) { return lastEOLTriggerEntry ? Number(lastEOLTriggerEntry) : 0; }

    // Payment point for a VP by its index within the current cycle (1-based)
    function getVPPaymentPointByIndex(vpIndex, matrixSize, lastEOLTriggerEntry = 0) {
      const base = getCycleBase(lastEOLTriggerEntry);
      const s = getVPStructureSize(matrixSize);
      const spacing = getPaySpacing(matrixSize);
      return base + s + ((vpIndex - 1) * spacing);
    }

    // Range for a VP by its index within the current cycle (absolute tokenIds)
    function getVPRangeByIndex(vpIndex, matrixSize, lastEOLTriggerEntry = 0) {
      const base = getCycleBase(lastEOLTriggerEntry);
      const s = getVPStructureSize(matrixSize);
      const start = base + 1 + (vpIndex - 1) * s;
      const end = start + s - 1;
      return { start, end };
    }

    function computeVPFilledByIndex(vpIndex, totalEntriesAbs, matrixSize, lastEOLTriggerEntry = 0) {
      const r = getVPRangeByIndex(vpIndex, matrixSize, lastEOLTriggerEntry);
      return mintedInRange(totalEntriesAbs, r.start, r.end);
    }

    // Helper: count minted tokens in [startId, endId] inclusive (absolute tokenIds)
    function mintedInRange(totalMintedAbs, startIdAbs, endIdAbs) {
      if (endIdAbs < startIdAbs) return 0;
      const end = Math.min(totalMintedAbs, endIdAbs);
      if (end < startIdAbs) return 0;
      return (end - startIdAbs + 1);
    }

    // Prefilled count for the IMMEDIATE next VP leaders right after VP#1 completes
    // - 3x3: leaders 2..4 each get leader(1) + 3 children chunks: [5..7], [8..10], [11..13]
    // - 4x4: leaders 2..5 each get leader(1) + 4 children [6..21 chunked by 4] + 16 grandchildren [22..85 chunked by 16]
    function computePrefilledForLeaderIndex(vpIndex, totalEntriesAbs, lastEOLTriggerEntry = 0, matrixSize = 3) {
      // vpIndex is 1-based within cycle; leader absolute tokenId is base + vpIndex
      const base = getCycleBase(lastEOLTriggerEntry);
      const leaderId = base + vpIndex;
      let filled = mintedInRange(totalEntriesAbs, leaderId, leaderId); // leader itself

      if (matrixSize === 3) {
        // Initial prefill inside VP#1 (ids 1..13): distribute children among vpIndex 2..4
        if (vpIndex >= 2 && vpIndex <= 4) {
          const chunkStart = base + 5 + (vpIndex - 2) * 3; // 5..7, 8..10, 11..13
          const chunkEnd = chunkStart + 2;
          filled += mintedInRange(totalEntriesAbs, chunkStart, chunkEnd);
        }
        // After VP#1 completes (base+s), new entries fill the next leaders sequentially in +9 blocks
        const s = getVPStructureSize(3);
        const mintedAfter = Math.max(0, totalEntriesAbs - (base + s));
        if (mintedAfter > 0 && vpIndex >= 2 && vpIndex <= 4) {
          const offsetBlocks = vpIndex - 2; // 0 for VP#2, 1 for VP#3, 2 for VP#4
          const taken = Math.max(0, Math.min(9, mintedAfter - (offsetBlocks * 9)));
          filled += taken;
        }
      } else {
        // 4x4: leaders 2..5; add L3 (4 each) and L4 (16 each)
        if (vpIndex >= 2 && vpIndex <= 5) {
          // Level 3: 6..21 partitioned into 4 chunks of 4
          const l3Start = base + 6 + (vpIndex - 2) * 4;
          const l3End = l3Start + 3;
          filled += mintedInRange(totalEntriesAbs, l3Start, l3End);
          // Level 4: 22..85 partitioned into 4 chunks of 16
          const l4Start = base + 22 + (vpIndex - 2) * 16;
          const l4End = l4Start + 15;
          filled += mintedInRange(totalEntriesAbs, l4Start, l4End);
          // After VP#1 completes (base+s), new entries fill the next leaders sequentially in +64 blocks
          const s = getVPStructureSize(4);
          const mintedAfter = Math.max(0, totalEntriesAbs - (base + s));
          const offsetBlocks = vpIndex - 2; // 0..3
          if (mintedAfter > 0) {
            const taken = Math.max(0, Math.min(64, mintedAfter - (offsetBlocks * 64)));
            filled += taken;
          }
          // Display expectation: show children-only count; exclude leader itself
          if (filled > 0) filled -= 1;
        }
      }
      return filled;
    }

    // Determine if a VP (by index within cycle) is complete based on payment point
    function isVPCompleteByIndex(vpIndex, totalEntriesAbs, matrixSize, lastEOLTriggerEntry = 0) {
      return totalEntriesAbs >= getVPPaymentPointByIndex(vpIndex, matrixSize, lastEOLTriggerEntry);
    }

    // Per-entry payment point (absolute entryId), preserved for HistorySection
    function getEntryPaymentPoint(entryId, matrixSize, lastEOLTriggerEntry = 0) {
      const s = getVPStructureSize(matrixSize);
      const spacing = getPaySpacing(matrixSize);
      const base = getCycleBase(lastEOLTriggerEntry);
      const cycleStart = base + 1;
      const posInCycle = Math.max(1, entryId - cycleStart + 1);
      return base + s + ((posInCycle - 1) * spacing);
    }
    // Back-compat wrapper used by ViewMatrixSection: computes payment point in a base-0 (pre-EOL) space
    function getVPPaymentPoint(entryId, matrixSize) {
      return getEntryPaymentPoint(entryId, matrixSize, 0);
    }

    // Simple wallet connection (no actual contract interaction)
    async function connectWallet() {
      if (!window.ethereum) {
        alert('Please install MetaMask, Rabby Wallet, or Internet Money Wallet for PulseChain');
        return false;
      }

      try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        if (accounts && accounts.length > 0) {
          alert('✅ Wallet connected: ' + accounts[0].slice(0,6) + '...' + accounts[0].slice(-4));
          // Update React state if setAccount is available in window
          if (typeof window.setAccount === 'function') {
            window.setAccount(accounts[0]);
          }
          return true;
        }
        return false;
      } catch (error) {
        if (error.code === 4001) {
          alert('Wallet connection was cancelled by user.');
        } else {
          alert('Failed to connect wallet: ' + error.message);
        }
        return false;
      }
    }

  function PuMaDappCarousel() {
    // Build dynamic tokens: core + user matrices (from coinConfigs) + extra pages + FAQ
    const [refreshStats, setRefreshStats] = React.useState(0);
    const tokens = React.useMemo(() => {
      const core = [...staticCoins];
      const coreNames = new Set(['PuMa 3x3','PuMa 4x4','PLS 3x3','PLS 4x4']);
      // Merge both runtime sources: coinConfigs (primary) and coinConfigsData (if present)
      const fromA = Array.isArray(window.coinConfigs) ? window.coinConfigs : [];
      const fromB = Array.isArray(window.coinConfigsData) ? window.coinConfigsData : [];
      const mergedBaseMap = new Map();
      const keyOf = (e)=> ((String(e?.vault||'').toLowerCase()) + '::' + String(Number(e?.chainId || window.__READ_CHAIN_ID || 369)));
      for (const e of [...fromA, ...fromB]) {
        if (!e || !e.vault) continue;
        const key = keyOf(e);
        const cur = mergedBaseMap.get(key);
        // Prefer entries with abiKey/decimals/chainId if duplicates arrive
        const score = (x) => (x? (('abiKey' in x?1:0)+('decimals' in x?1:0)+('chainId' in x?1:0)) : 0);
        if (!cur || score(e) >= score(cur)) mergedBaseMap.set(key, e);
      }
  const base = Array.from(mergedBaseMap.values());
  // Only include extras for the currently selected chain to avoid cross-chain mismatches
  const extrasCfgs = base.filter(c => c && !coreNames.has(c.name) && Number(c.chainId) === __READ_CID);
      const seen = new Set();
      const extrasTokens = [];
      for (const c of extrasCfgs) {
        const is4 = (c.abiKey && /4x4/i.test(c.abiKey)) || /4x4/.test(c.name || '');
        let abiKey = c.abiKey;
        if (!abiKey || !window.AllVaultABI || !window.AllVaultABI[abiKey]) {
          abiKey = is4 ? 'PuMa4x4' : 'PuMa3x3';
        }
        const cfg = { ...c, abiKey };
        const key = (cfg.vault || '').toLowerCase();
        if (!key || seen.has(key)) continue;
        seen.add(key);
        // Prefer cached ERC-20 symbol for friendly naming when name is generic
        const isGeneric = !c.name || /^(?:newmatrix|token)/i.test(String(c.name).trim());
        const cache = (window.__symbolCache = window.__symbolCache || {});
        const symAddr = (cfg.token || '').toLowerCase();
        const cachedSymbol = symAddr && cache[symAddr] ? cache[symAddr] : null;
        const name = isGeneric
          ? `${cachedSymbol || 'TOKEN'} ${is4 ? '4x4' : '3x3'}`
          : c.name;
        // Derive image by coin name/symbol (case-insensitive), fallback to factory if no match
        const sizeSuffixRe = /\s*(?:3x3|4x4|3×3|4×4)\b/gi;
        const baseName = (isGeneric ? (cachedSymbol || '') : (c.name || ''))
          .replace(sizeSuffixRe, '')
          .trim();
        const symbolUpper = (baseName || '').toUpperCase();
        // Known token image mapping (uses local Pics/ folder). Keep specific symbols first to avoid substring collisions.
        const symbolToFile = {
          // Core
          'PUMA': 'PuMa.png',
          'PLS': 'PLS.png',
          'PLSX': 'PLSX.png',
          'INC': 'INC.png',
          'PDAI': 'pDAI.png',
          'PHEX': 'pHEX.png',
          'EHEX': 'eHEX.png',
          'PWBTC': 'pWBTC.png',
          // Test tokens (t*)
          'TPLS': 'tPLS.png',
          'TPLSX': 'tPLSX.png',
          'TPDAI': 'tpDAI.png',
          'TPHEX': 'tpHEX.png',
          'TEHEX': 'teHEX.png',
          // Common majors
          'USDC': 'usdc.png',
          'ETH': 'ETH.png',
          'DAI_MAIN': 'DAI.png', // alias to avoid matching PDAI; not searched directly
          // Ecosystem extras you have in Pics/
          'PLSD': 'plsd.png',
          'HDRN': 'hdrn.png',
          'MAXI': 'maxi.png',
          'TRIO': 'trio.png',
          'PTGC': 'ptgc.png',
          'PTS': 'pts.png',
          'PHAME': 'phame.png',
          'PHIAT': 'phiat.png',
          'TEXAN': 'texan.png',
          'HELGO': 'helgo.png',
          'IM': 'IM.png',
          'PP': 'PP.png',
          'COM': 'com.png',
          'BEAR': 'bear.png',
          'LIBERTY': 'liberty.png',
          'PUMP': 'pump.png',
          'MOST': 'most.png'
        };
        // Resolve an image path from symbol/name to an absolute URL usable by MetaMask and the UI.
        function resolveTokenImage(symbol, name){
          try{
            const candidates = [];
            if (symbol) candidates.push(String(symbol).toUpperCase());
            if (name) candidates.push(String(name).toUpperCase());
            let mappedKey = null;
            for (const key of Object.keys(symbolToFile)) {
              if (candidates.some(s => s.includes(key))) { mappedKey = key; break; }
            }
            const rel = mappedKey ? `Pics/${symbolToFile[mappedKey]}` : 'Pics/factory.png';
            return new URL(rel, window.location.href).href;
          } catch { return new URL('Pics/factory.png', window.location.href).href; }
        }
        // Match by inclusion against known symbols (case-insensitive)
        const candidates = [symbolUpper, (c.name || '').toUpperCase()];
        // Prefer the same resolver as used elsewhere so both UI and MetaMask agree on the icon
        const img = resolveTokenImage(cachedSymbol || baseName, c.name || baseName);
  extrasTokens.push({ name, img, matrixSize: is4 ? '4' : '3', desc: 'User matrix', config: cfg });
      }
      // Sort core in logical order: PUMA, PLS, (PLSX, INC, pHEX, eHEX, pDAI), 3x3 before 4x4
      function baseSym(name){ return String(name||'').replace(/\s*(?:3x3|4x4|3×3|4×4)\b/gi,'').trim().toUpperCase(); }
      const order = ['PUMA','PLS','PLSX','INC','PHEX','EHEX','PDAI'];
      const coreSorted = core.slice().sort((a,b)=>{
        const ab = baseSym(a.name), bb = baseSym(b.name);
        const ai = Math.max(0, order.indexOf(ab)), bi = Math.max(0, order.indexOf(bb));
        if ((ai>=0 && bi>=0) && ai !== bi) return ai - bi;
        if (ab === bb) {
          const as = /3x3/i.test(a.name) ? 3 : 4;
          const bs = /3x3/i.test(b.name) ? 3 : 4;
          return as - bs;
        }
        // Unknowns last within core (shouldn't happen), fallback by name
        return ab.localeCompare(bb);
      });
      // Sort extras alphabetically by base symbol, 3x3 first
      const extrasSorted = extrasTokens.slice().sort((a,b)=>{
        const ab = baseSym(a.name), bb = baseSym(b.name);
        const by = ab.localeCompare(bb);
        if (by !== 0) return by;
        const as = a.matrixSize === '3' ? 3 : 4;
        const bs = b.matrixSize === '3' ? 3 : 4;
        return as - bs;
      });

      return [
        ...coreSorted,
        ...extrasSorted,
        ...extraPages,
        { name: 'Comprehensive Documentation & FAQ', img: 'Pics/FAQ.png', desc: 'Comprehensive FAQ & Documentation' }
      ];
    }, [refreshStats]);

    // Resolve ERC-20 symbols for generic extras and cache them to improve display names
    React.useEffect(() => {
      try {
        const coreNames = new Set(['PuMa 3x3','PuMa 4x4','PLS 3x3','PLS 4x4']);
  const base = Array.isArray(window.coinConfigs) ? window.coinConfigs : [];
  const cid = Number(window.__READ_CHAIN_ID || localStorage.getItem('READ_CHAIN_ID') || window.DEFAULT_CHAIN_ID || 943);
  const extrasCfgs = base.filter(c => c && !coreNames.has(c.name) && Number(c.chainId) === cid);
        const cache = (window.__symbolCache = window.__symbolCache || {});
        let cancelled = false;
        (async () => {
          for (const c of extrasCfgs) {
            const isGeneric = !c.name || /^(?:newmatrix|token)/i.test(String(c.name).trim());
            const addr = (c.token || '').toLowerCase();
            if (!isGeneric || !addr || cache[addr]) continue;
            // Use only the selected read network
            const abi = ['function symbol() view returns (string)'];
            async function tryProvider(p) {
              try {
                const code = await p.getCode(addr);
                if (!code || code === '0x') return null;
                const erc20 = new ethers.Contract(addr, abi, p);
                const s = await erc20.symbol();
                return s ? String(s).toUpperCase() : null;
              } catch { return null; }
            }
            let symbol = null;
            try {
              const url = (window.PULSE_RPC && window.PULSE_RPC[cid]) || (cid===369 ? 'https://rpc.pulsechain.com' : 'https://rpc.v4.testnet.pulsechain.com');
              symbol = await tryProvider(new ethers.providers.JsonRpcProvider(url));
            } catch {}
            if (!cancelled && symbol) {
              cache[addr] = symbol;
              // Trigger tokens recompute to pick up nicer names
              setRefreshStats(x => x + 1);
            }
          }
        })();
        return () => { cancelled = true; };
      } catch {}
    }, [refreshStats]);

  const [carouselIdx, setCarouselIdx] = React.useState(getIndexFromHash());
  // Lock to FAQ on initial load until the user explicitly navigates or a hash is set
  const defaultPageLockRef = React.useRef(true);
    // Freeze selection during critical tx to avoid index jumps on refresh
    const [freezeSel, setFreezeSel] = React.useState(false);
    // Initial load guard: avoid auto-reselect during first settle window
    const [initLock, setInitLock] = React.useState(true);
    React.useEffect(() => {
      const t = setTimeout(() => setInitLock(false), 1500);
      return () => clearTimeout(t);
    }, []);
    // Track the selected page by slug so index stays stable when tokens array changes
    const [stickySlug, setStickySlug] = React.useState(() => {
      const i0 = getIndexFromHash();
      try { return slugifyToken((tokens[i0] && tokens[i0].name) || ''); } catch { return ''; }
    });
    // Track a stable identity: vault address (lowercase) for the selected page
    const [stickyVault, setStickyVault] = React.useState(() => {
      const i0 = getIndexFromHash();
      try { return String(tokens[i0]?.config?.vault || '').toLowerCase(); } catch { return ''; }
    });
    // When user navigates (index changes), update sticky slug to the current token
  React.useEffect(() => {
      try {
        const nm = (tokens[carouselIdx] && tokens[carouselIdx].name) || '';
        const slug = slugifyToken(nm);
        if (slug && slug !== stickySlug) setStickySlug(slug);
    const v = String(tokens[carouselIdx]?.config?.vault || '').toLowerCase();
    if (v && v !== stickyVault) setStickyVault(v);
        // If user leaves FAQ, disable the default page lock
        try {
          if (slug && slug !== slugifyToken('Comprehensive Documentation & FAQ')) {
            defaultPageLockRef.current = false;
          }
        } catch {}
      } catch {}
  }, [carouselIdx, tokens]);
    // When tokens refresh (e.g., after coinConfigs arrive) or on hash navigation,
    // re-point the index to the hash page if present. If no hash, prefer the CURRENT page slug
    // (more stable during refresh) and only then fall back to stickySlug.
    React.useEffect(() => {
      try {
        if (freezeSel) return; // don't alter selection mid-transaction
        const m = window.location.hash.match(/page=([^&]+)/i);
        const hasExplicitHash = !!(m && m[1]);
        // While no explicit hash and user hasn't navigated yet, pin to FAQ to avoid jitter on async refresh
        if (!hasExplicitHash && defaultPageLockRef.current) {
          const faqIdx = tokens.findIndex(t => t && t.name === 'Comprehensive Documentation & FAQ');
          if (faqIdx >= 0 && faqIdx !== carouselIdx) {
            setCarouselIdx(faqIdx);
            return;
          }
        }
        const currentSlug = (tokens[carouselIdx] && tokens[carouselIdx].name)
          ? slugifyToken(tokens[carouselIdx].name)
          : '';
        // Resolve desired target (prefer sticky slug to survive token reorders)
        const wantedSlug = m && m[1]
          ? m[1].toLowerCase()
          : (initLock ? '' : (stickySlug || currentSlug));
        let idx = -1;
        if (wantedSlug) {
          idx = tokens.findIndex(t => slugifyToken(t.name) === wantedSlug);
        }
        // If no slug match (or during init with no hash), try stable vault identity
        if (idx < 0) {
          const currentVault = String(tokens[carouselIdx]?.config?.vault || '').toLowerCase();
          const vaultKey = currentVault || stickyVault;
          if (vaultKey) idx = tokens.findIndex(t => String(t?.config?.vault || '').toLowerCase() === vaultKey);
        }
        // If we are on FAQ and no explicit hash, do not auto-switch on background token updates
        const isFAQ = (tokens[carouselIdx] && tokens[carouselIdx].name === 'Comprehensive Documentation & FAQ');
        if (idx >= 0 && idx !== carouselIdx) {
          if (isFAQ && !hasExplicitHash && stickySlug === slugifyToken('Comprehensive Documentation & FAQ')) {
            // stay on FAQ
          } else {
            setCarouselIdx(idx);
          }
        }
      } catch {}
    }, [refreshStats, tokens.length, freezeSel, initLock]);
  // Cache for ALL page: per-token live data
  const [allVaultData, setAllVaultData] = React.useState({}); // { [tokenIndex]: { decimals, ENTRY_FEE, PAYOUT_AMOUNT, vaultBalance, approvedLimit, userBalance, myStatus } }
    const [account, setAccount] = React.useState(null); // Track wallet connection
  // REMOVE for MAIN NET !!!
  const [chainId, setChainId] = React.useState(null); // Track wallet network
  // END REMOVE for MAIN NET
      const [vaultStats, setVaultStats] = React.useState({ 
        entryFee: 'Loading...', 
        payout: 'Loading...', 
        vaultBalance: 'Loading...', 
        totalEntries: 'Loading...', 
        approvedLimit: 'Loading...' 
      });
  const [vaultData, setVaultData] = React.useState(null); // For live contract data
  // Tiny in-memory caches to smooth carousel scrolling
  const statsCacheRef = React.useRef(new Map()); // key: vaultAddr -> { t, stats, data }
  const openCacheRef  = React.useRef(new Map()); // key: vaultAddr -> { t, open }

  // Cache housekeeping: sweep stale entries and cap size for long sessions
  React.useEffect(() => {
    const CACHE_TTL = 10_000; // matches serve freshness
    const SWEEP_MS = 45_000;  // sweep every 45s
    const MAX_SIZE = 60;      // max entries per cache
    const KEEP_NEW = 24;      // keep newest when trimming

    function sweep(map){
      try {
        const now = Date.now();
        // drop very old entries (> 6x TTL)
        for (const [k,v] of map) {
          const t = v && v.t ? v.t : 0;
          if (now - t > CACHE_TTL * 6) map.delete(k);
        }
        // enforce size cap (remove oldest first)
        if (map.size > MAX_SIZE) {
          const arr = [...map.entries()].sort((a,b)=> (a[1]?.t||0) - (b[1]?.t||0));
          for (let i=0; i<Math.max(0, arr.length - KEEP_NEW); i++) map.delete(arr[i][0]);
        }
      } catch {}
    }

    const id = setInterval(() => { sweep(statsCacheRef.current); sweep(openCacheRef.current); }, SWEEP_MS);
    return () => clearInterval(id);
  }, []);

  // Flush caches on account or chain changes to avoid stale per-user state
  React.useEffect(() => {
    try { statsCacheRef.current.clear(); openCacheRef.current.clear(); } catch {}
  }, [account, chainId]);
  // When coinConfigs are updated (from Sheets loader), force a re-render so ALL card recomputes extras
  React.useEffect(() => {
    function onCoinConfigsReady(e){
      try { console.log('coinConfigsReady', e?.detail); } catch {}
      setRefreshStats(x => x + 1);
    }
    window.addEventListener('coinConfigsReady', onCoinConfigsReady);
    // Also refresh when a new contract is deployed locally
    const onNew = () => setRefreshStats(x => x + 1);
    window.addEventListener('newContractDeployed', onNew);
    return () => { 
      window.removeEventListener('coinConfigsReady', onCoinConfigsReady);
      window.removeEventListener('newContractDeployed', onNew);
    };
  }, []);
  // Open VPs state
  const [openVPs, setOpenVPs] = React.useState([]);
  // All token IDs (positions) the connected user owns in the CURRENT matrix cycle (after last EOL)
  const [userCyclePositions, setUserCyclePositions] = React.useState([]);
      const [txMsgs, setTxMsgs] = React.useState({});
      const setTxMsg = msg => setTxMsgs(m => ({ ...m, [carouselIdx]: msg }));
      const txMsg = txMsgs[carouselIdx] || '';
  // Search UI state
  const [searchOpen, setSearchOpen] = React.useState(false);
  const [searchQuery, setSearchQuery] = React.useState('');
      
      const n = tokens.length;
  const leftIdx = mod(carouselIdx - 1, n);
      const rightIdx = mod(carouselIdx + 1, n);

      // Keyboard navigation
      React.useEffect(() => {
        function handleKeyDown(e) {
          if (e.key === 'ArrowLeft') setCarouselIdx(idx => mod(idx - 1, n));
          else if (e.key === 'ArrowRight') setCarouselIdx(idx => mod(idx + 1, n));
        }
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [n]);

      // Connect wallet handler
      async function connectWallet() {
        if (!window.ethereum) {
          alert('Please install MetaMask or another Web3 wallet.');
          return;
        }
        
        try {
          // Add loading state to prevent multiple clicks
          setTxMsg('Connecting wallet...');
          
          // Simple connection request
          const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
          });
          
          if (accounts && accounts.length > 0) {
            setAccount(accounts[0]);
            setTxMsg('Wallet connected!');
            setTimeout(() => setTxMsg(''), 2000); // Clear message after 2 seconds
          } else {
            setTxMsg('No accounts found.');
          }
        } catch (error) {
          if (error.code === 4001) {
            setTxMsg('Connection cancelled by user.');
          } else {
            setTxMsg('Connection failed. Please try again.');
          }
        }
      }

      // --- Free-claim PuMa state & helpers  ---
      const [lastPuMaClaim, setLastPuMaClaim] = React.useState(() => {
        if (account) {
          const t = localStorage.getItem(`lastPuMaClaim_${account.toLowerCase()}`);
          return t ? parseInt(t, 10) : 0;
        }
        return 0;
      });
      // Update lastPuMaClaim when account changes
      React.useEffect(() => {
        if (account) {
          const t = localStorage.getItem(`lastPuMaClaim_${account.toLowerCase()}`);
          setLastPuMaClaim(t ? parseInt(t, 10) : 0);
        } else {
          setLastPuMaClaim(0);
        }
      }, [account]);
      // Helper: is claim available?
      const canClaimPuMa = () => {
        const tk = tokens[carouselIdx];
        if (!tk || !tk.name || !tk.name.includes('PuMa')) return false;
        const now = Date.now();
        return (now - lastPuMaClaim) > 3600_000; // 1 hour in ms
      };
      // Free-claim handler
      async function freeClaimPuMa() {
        try {
          const tk = tokens[carouselIdx];
          const PuMaToken = tk?.config?.token;
          if (!window.ethereum) { alert('Please install MetaMask or another Web3 wallet.'); return; }
          if (!PuMaToken) { alert('PuMa token address not found in config'); return; }
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const signer = provider.getSigner();
          const network = await provider.getNetwork();
          const wanted = Number(window.__READ_CHAIN_ID || localStorage.getItem('READ_CHAIN_ID') || window.DEFAULT_CHAIN_ID || 943);
          const name = wanted===369 ? 'PulseChain Mainnet' : 'PulseChain Testnet V4';
          if (Number(network.chainId) !== wanted) {
            alert(`Wrong network! Please switch to ${name} (Chain ID: ${wanted}). Currently on: ${network.chainId}`);
            return;
          }
          const code = await provider.getCode(PuMaToken);
          if (code === '0x') { alert(`No contract found at address ${PuMaToken}. Please deploy contracts.`); return; }
          const abi = [
            'function claim() public',
            'function canClaim(address account) view returns (bool)'
          ];
          const contract = new ethers.Contract(PuMaToken, abi, signer);
          try {
            const userAddress = await signer.getAddress();
            const ok = await contract.canClaim(userAddress);
            if (!ok) { alert('You cannot claim at this time. Please wait for cooldown period.'); return; }
          } catch (_) {
            // canClaim not available: proceed
          }
          const tx = await contract.claim();
          await tx.wait();
          alert('Free claim successful!');
          const now = Date.now();
          setLastPuMaClaim(now);
          if (account) localStorage.setItem(`lastPuMaClaim_${account.toLowerCase()}`, now.toString());
        } catch (e) {
          if (e && (e.code === -32603 || e.code === -32000)) {
            if (e.data && e.data.message && e.data.message.includes('revert')) {
              alert('Transaction failed: Contract rejected the claim. You may have already claimed recently.');
            } else {
              alert('RPC Error: Check network/contracts and try again.');
            }
          } else if (e && e.code === 4001) {
            alert('Transaction cancelled by user.');
          } else {
            alert('Free claim failed: ' + (e?.message || e));
          }
        }
      }

  // REMOVE for MAIN NET !!!
  // Detect current chain and update on changes
  React.useEffect(() => {
        if (!window.ethereum) return;
        window.ethereum.request({ method: 'eth_chainId' })
          .then(id => setChainId(id))
          .catch(() => {});
        const onChainChanged = (id) => setChainId(id);
        window.ethereum.on && window.ethereum.on('chainChanged', onChainChanged);
        return () => {
          window.ethereum.removeListener && window.ethereum.removeListener('chainChanged', onChainChanged);
        };
  }, []);
  // END REMOVE for MAIN NET

  // (Removed Ganache network switch helper)

  // Fetch vault stats from contract using a dynamic RPC (prefers wallet on 943/369; falls back to Testnet V4)
  React.useEffect(() => {
        let cancelled = false;
        let timer = null;
        async function fetchStats() {
          const currentToken = tokens[carouselIdx];
          if (!currentToken.config) {
            setVaultStats({ 
              entryFee: 'No Contract', 
              payout: 'No Contract', 
              vaultBalance: 'No Contract', 
              totalEntries: 'No Contract', 
              approvedLimit: 'No Contract' 
            });
            setVaultData(null);
            return;
          }
          try {
            // Read from the selected network (independent of wallet)
            const provider = getReadProvider();
            const config = currentToken.config;
            const abi = window.AllVaultABI[config.abiKey];
            if (!abi) {
              setVaultStats({ 
                entryFee: 'No ABI', 
                payout: 'No ABI', 
                vaultBalance: 'No ABI', 
                totalEntries: 'No ABI', 
                approvedLimit: 'No ABI' 
              });
              setVaultData(null);
              return;
            }
            const cacheKey = String(config.vault||'').toLowerCase();
            // Serve cached values if fresh (<=10s)
            const cached = statsCacheRef.current.get(cacheKey);
            if (cached && (Date.now() - cached.t) <= 10000) {
              if (cancelled) return;
              if (cached.stats) setVaultStats(cached.stats);
              if (cached.data)  setVaultData(cached.data);
              // Kick off neighbor prefetch in background while showing cache
              try { prefetchNeighborsStats(); } catch {}
              return;
            }
            // Ensure contracts exist at addresses (prevents "0x" revert errors)
            const [vaultCode, tokenCode] = await Promise.all([
              provider.getCode(config.vault),
              provider.getCode(config.token)
            ]);
            if (vaultCode === '0x' || tokenCode === '0x') {
              console.warn('No contract code at address:', { vault: config.vault, token: config.token });
              const stats = {
                entryFee: 'Not deployed',
                payout: 'Not deployed',
                vaultBalance: 'Not deployed',
                totalEntries: 'Not deployed',
                approvedLimit: account ? '0' : 'Connect'
              };
              setVaultStats(stats);
              setVaultData(null);
              statsCacheRef.current.set(cacheKey, { t: Date.now(), stats, data: null });
              // Surface a gentle per-card message for the selected read network
              setTxMsg('This contract is not deployed on the selected read network.');
              try { prefetchNeighborsStats(); } catch {}
              return;
            }
            const vaultContract = new ethers.Contract(config.vault, abi, provider);
            // Prefer on-chain vault.TOKEN() over configured token to avoid mismatches,
            // but if that address has no code on the current network, fall back to config.token
            let vaultTokenAddr = await (async () => {
              try { return await vaultContract.TOKEN(); } catch { return config.token; }
            })();
            try {
              const vCode = await provider.getCode(vaultTokenAddr);
              if (vCode === '0x') {
                // Fallback to configured token to avoid JSON-RPC reverts on missing code
                vaultTokenAddr = config.token;
              }
            } catch {}
            const tokenContract = new ethers.Contract(vaultTokenAddr, [
              "function balanceOf(address) view returns (uint256)",
              "function allowance(address,address) view returns (uint256)",
              "function decimals() view returns (uint8)"
            ], provider);
            // Get contract data with robust fallbacks
            const entryFeeWei = await vaultContract.ENTRY_FEE()
              .catch(() => vaultContract.entryFee ? vaultContract.entryFee() : Promise.reject())
              .catch(() => ethers.BigNumber.from('0'));

            const payoutWei = await vaultContract.PAYOUT_AMOUNT()
              .catch(() => vaultContract.payout ? vaultContract.payout() : Promise.reject())
              .catch(() => ethers.BigNumber.from('0'));

            // Always read via ERC20/PRC20 to avoid vault-side reverts
            const vaultBalanceWei = await tokenContract.balanceOf(config.vault)
              .catch(() => ethers.BigNumber.from('0'));

            let totalEntriesMade = ethers.BigNumber.from('0');
            try {
              if (vaultContract.getTotalEntriesMade) {
                totalEntriesMade = await vaultContract.getTotalEntriesMade();
              } else if (vaultContract.nextTokenId) {
                const nextId = await vaultContract.nextTokenId();
                totalEntriesMade = ethers.BigNumber.from(nextId).sub(1);
              }
            } catch {}

            const allowanceWei = account
              ? await tokenContract.allowance(account, config.vault).catch(() => ethers.BigNumber.from('0'))
              : ethers.BigNumber.from('0');

            // User token balance (required for JOIN transferFrom)
            const userBalWei = account
              ? await tokenContract.balanceOf(account).catch(() => ethers.BigNumber.from('0'))
              : ethers.BigNumber.from('0');

            // Optional: fetch MY_STATUS for this account (uses eth_call with from override)
            let myStatus = null;
            if (account && typeof vaultContract.MY_STATUS === 'function') {
              try {
                // Ethers v5 allows call overrides for view functions
                const s = await vaultContract.MY_STATUS({ from: account });
                myStatus = {
                  canEnter: Boolean(s.canEnter ?? s[0]),
                  hasRewards: Boolean(s.hasRewards ?? s[1]),
                  totalAutoPayable: s.totalAutoPayable ?? s[2] ?? ethers.BigNumber.from('0'),
                  activeEntries: s.activeEntries ?? s[3] ?? ethers.BigNumber.from('0'),
                  nextActionTime: s.nextActionTime ?? s[4] ?? ethers.BigNumber.from('0'),
                  statusMessage: s.statusMessage ?? s[5] ?? '',
                  systemColor: s.systemColor ?? s[6] ?? ethers.BigNumber.from('0')
                };
              } catch (e) {
                // ignore; not all variants may implement MY_STATUS consistently
                myStatus = null;
              }
            }

            const decimals = await tokenContract.decimals().catch(() => (config.decimals || 18));

            // Format the data
            const entryFee = ethers.utils.formatUnits(entryFeeWei, decimals);
            const payout = ethers.utils.formatUnits(payoutWei, decimals);
            const vaultBalance = ethers.utils.formatUnits(vaultBalanceWei, decimals);
            const approvedLimit = ethers.utils.formatUnits(allowanceWei, decimals);
            const stats = {
              entryFee: parseFloat(entryFee).toFixed(1),
              payout: parseFloat(payout).toFixed(1),
              vaultBalance: parseFloat(vaultBalance).toFixed(1),
              totalEntries: totalEntriesMade.toString(),
              approvedLimit: parseFloat(approvedLimit).toFixed(1)
            };
            if (cancelled) return;
            setVaultStats(stats);
            // Also set vaultData for token card and developer section
            const data = {
              ENTRY_FEE: entryFeeWei,
              PAYOUT_AMOUNT: payoutWei,
              vaultBalance: vaultBalanceWei,
              totalEntriesMade: totalEntriesMade,
              approvedLimit: allowanceWei,
              userBalance: userBalWei,
              decimals: decimals,
              myStatus: myStatus,
              configToken: config.token,
              vaultToken: vaultTokenAddr
            };
            setVaultData(data);
            statsCacheRef.current.set(cacheKey, { t: Date.now(), stats, data });
            try { prefetchNeighborsStats(); } catch {}
          } catch (error) {
            if (cancelled) return;
            setVaultStats({ 
              entryFee: 'Error', 
              payout: 'Error', 
              vaultBalance: 'Error', 
              totalEntries: 'Error', 
              approvedLimit: 'Error' 
            });
            setVaultData(null);
            // Aid debugging in console, avoid noisy alerts
            console.error('fetchStats error for', currentToken.name, error);
          }
        }
        function hexChainId(n){ try { return '0x' + Number(n).toString(16); } catch { return '0x0'; } }
        // Background prefetcher for neighbor indices
        async function prefetchStatsForIndex(idx) {
          const tk = tokens[idx];
          if (!tk?.config) return;
          const cfg = tk.config;
          const cacheKey = String(cfg.vault||'').toLowerCase();
          const cached = statsCacheRef.current.get(cacheKey);
          if (cached && (Date.now() - cached.t) <= 10000) return;
          try {
            const provider = getReadProvider();
            const [vaultCode, tokenCode] = await Promise.all([
              provider.getCode(cfg.vault), provider.getCode(cfg.token)
            ]);
            if (vaultCode === '0x' || tokenCode === '0x') {
              const stats = { entryFee:'Not deployed', payout:'Not deployed', vaultBalance:'Not deployed', totalEntries:'Not deployed', approvedLimit: '0' };
              statsCacheRef.current.set(cacheKey, { t: Date.now(), stats, data: null });
              return;
            }
            const abi = window.AllVaultABI[cfg.abiKey];
            if (!abi) return;
            const vaultContract = new ethers.Contract(cfg.vault, abi, provider);
            let vaultTokenAddr = cfg.token;
            try { const a = await vaultContract.TOKEN(); const c = await provider.getCode(a); if (c && c !== '0x') vaultTokenAddr = a; } catch {}
            const tokenContract = new ethers.Contract(vaultTokenAddr, [
              'function balanceOf(address) view returns (uint256)',
              'function allowance(address,address) view returns (uint256)',
              'function decimals() view returns (uint8)'
            ], provider);
            const [entryFeeWei, payoutWei] = await Promise.all([
              vaultContract.ENTRY_FEE().catch(async()=> vaultContract.entryFee ? vaultContract.entryFee() : ethers.BigNumber.from('0')),
              vaultContract.PAYOUT_AMOUNT ? vaultContract.PAYOUT_AMOUNT() : Promise.resolve(ethers.BigNumber.from('0'))
            ]);
            const [vaultBalanceWei, allowanceWei, userBalWei, decimals] = await Promise.all([
              tokenContract.balanceOf(cfg.vault).catch(()=>ethers.BigNumber.from('0')),
              account ? tokenContract.allowance(account, cfg.vault).catch(()=>ethers.BigNumber.from('0')) : Promise.resolve(ethers.BigNumber.from('0')),
              account ? tokenContract.balanceOf(account).catch(()=>ethers.BigNumber.from('0')) : Promise.resolve(ethers.BigNumber.from('0')),
              tokenContract.decimals().catch(()=> (cfg.decimals || 18))
            ]);
            let totalEntriesMade = ethers.BigNumber.from('0');
            try { if (vaultContract.getTotalEntriesMade) totalEntriesMade = await vaultContract.getTotalEntriesMade(); else if (vaultContract.nextTokenId) totalEntriesMade = ethers.BigNumber.from(await vaultContract.nextTokenId()).sub(1);} catch {}
            const stats = {
              entryFee: parseFloat(ethers.utils.formatUnits(entryFeeWei, decimals)).toFixed(1),
              payout: parseFloat(ethers.utils.formatUnits(payoutWei, decimals)).toFixed(1),
              vaultBalance: parseFloat(ethers.utils.formatUnits(vaultBalanceWei, decimals)).toFixed(1),
              totalEntries: totalEntriesMade.toString(),
              approvedLimit: parseFloat(ethers.utils.formatUnits(allowanceWei, decimals)).toFixed(1)
            };
            const data = { ENTRY_FEE: entryFeeWei, PAYOUT_AMOUNT: payoutWei, vaultBalance: vaultBalanceWei, totalEntriesMade, approvedLimit: allowanceWei, userBalance: userBalWei, decimals, myStatus: null, configToken: cfg.token, vaultToken: vaultTokenAddr };
            statsCacheRef.current.set(cacheKey, { t: Date.now(), stats, data });
          } catch {}
        }
        function prefetchNeighborsStats(){
          try { prefetchStatsForIndex(leftIdx); } catch {}
          try { prefetchStatsForIndex(rightIdx); } catch {}
        }
        // Debounce to avoid firing while user is fast-scrolling
        timer = setTimeout(fetchStats, 200);
        return () => { cancelled = true; if (timer) clearTimeout(timer); };
      }, [account, carouselIdx, refreshStats]);

      // Fetch Open VPs (reads via wallet on 943/369 or Testnet V4 RPC)
      React.useEffect(() => {
        let cancelled = false;
        let timer = null;
        async function fetchOpenVPs() {
          setOpenVPs([]);
          const token = tokens[carouselIdx];
          if (!token?.config) return;
          try {
        // Use selected read network provider
        const provider = getReadProvider();
        const cfg = token.config;
            const cacheKey = String(cfg.vault||'').toLowerCase();
            const cached = openCacheRef.current.get(cacheKey);
            if (cached && (Date.now() - cached.t) <= 10000) {
              if (!cancelled) setOpenVPs(cached.open || []);
              // Kick off neighbor prefetch and skip heavy work
              try { prefetchNeighborsOpen(); } catch {}
              return;
            }
        // Verify contract exists
        const code = await provider.getCode(cfg.vault);
            if (code === '0x') { openCacheRef.current.set(cacheKey, { t: Date.now(), open: [] }); return; }
        const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);

        // Gather base data
        let eolCycleCount = 0;
        let totalCurrentEntries = 0; // absolute tokenId minted count
        let lastEOLTriggerEntry = 0;
        const calls = await Promise.allSettled([
          vault.EOLCycleCount ? vault.EOLCycleCount() : Promise.reject('NA'),
          vault.nextTokenId()
        ]);
        if (calls[0].status === 'fulfilled') eolCycleCount = Number(calls[0].value);
        if (calls[1].status === 'fulfilled') totalCurrentEntries = Math.max(0, Number(calls[1].value) - 1);

        if (eolCycleCount > 0 && vault.EOLTriggerAtEntryId) {
          try {
            const trig = await vault.EOLTriggerAtEntryId(eolCycleCount);
            const n = Number(trig);
            if (n > 0) lastEOLTriggerEntry = n;
          } catch {}
        }

        // Build open VP list (leaders after VP#1 in the current cycle)
        const matrixSize = token.name.includes('3x3') ? 3 : 4;
        const structureSize = getVPStructureSize(matrixSize);
        const base = getCycleBase(lastEOLTriggerEntry);
        const entriesInCycle = Math.max(0, totalCurrentEntries - base);

        const open = [];
        const nextOpenVPs = [];
        if (entriesInCycle > 0) {
          // Determine starting vpIndex: if VP#1 complete, start from 2; else only show VP#1
          const vp1Complete = isVPCompleteByIndex(1, totalCurrentEntries, matrixSize, lastEOLTriggerEntry);
          const startIndex = vp1Complete ? 2 : 1;
          const maxToShow = vp1Complete ? matrixSize : 1; // show only VP#1 until it completes

          // Always show a fixed window of OPEN VPs:
          // - Before VP#1 completes: show only VP#1 (true current fill)
          // - After VP#1 completes/EOL: show next 3 (3x3) or 4 (4x4) open VPs,
          //   with STRICT sequential filling:
          //   • First open VP shows progress beyond baseline
          //   • Remaining pills show EXACT baseline (4 for 3x3, 20 for 4x4)
          const windowLen = vp1Complete ? (matrixSize === 4 ? 4 : 3) : 1;

          if (!vp1Complete) {
            // VP#1 still open: show only VP#1 with actual filled count
            let vpIndex = 1;
            const leaderId = base + vpIndex;
            const payPoint = getVPPaymentPointByIndex(vpIndex, matrixSize, lastEOLTriggerEntry);
            const isClosed = totalCurrentEntries >= payPoint;
            if (!isClosed) {
              const fill = computeVPFilledByIndex(vpIndex, totalCurrentEntries, matrixSize, lastEOLTriggerEntry);
              nextOpenVPs.push({ tokenId: leaderId, payPoint, leader: leaderId, filledCount: Math.min(structureSize, fill), structureSize });
            }
          } else {
            // VP#1 complete/EOL: find first open VP and build window with sequential rules
            const baseline = (matrixSize === 4 ? 20 : 4);
            let firstOpenIdx = null;
            let scan = startIndex;
            let guard = 0;
            while (firstOpenIdx === null && guard++ < 1000) {
              const payPoint = getVPPaymentPointByIndex(scan, matrixSize, lastEOLTriggerEntry);
              const isClosed = totalCurrentEntries >= payPoint;
              if (!isClosed) firstOpenIdx = scan; else scan++;
            }

            if (firstOpenIdx !== null) {
              let vpIndex = firstOpenIdx;
              let guard2 = 0;
              while (nextOpenVPs.length < windowLen && guard2++ < 1000) {
                const leaderId = base + vpIndex;
                const payPoint = getVPPaymentPointByIndex(vpIndex, matrixSize, lastEOLTriggerEntry);
                const isClosed = totalCurrentEntries >= payPoint;
                if (!isClosed) {
                  let fill;
                  if (vpIndex === firstOpenIdx) {
                    // Active VP: baseline + real progress
                    fill = computePrefilledForLeaderIndex(vpIndex, totalCurrentEntries, lastEOLTriggerEntry, matrixSize);
                    fill = Math.max(fill, baseline);
                  } else {
                    // Future VPs: exact baseline only
                    fill = baseline;
                  }
                  nextOpenVPs.push({ tokenId: leaderId, payPoint, leader: leaderId, filledCount: Math.min(structureSize, fill), structureSize });
                }
                vpIndex++;
              }
            }
          }
        }
        if (nextOpenVPs.length > 0) {
          open.push({ id: 'next_open_vps', nextOpenVPs, stateColor: '💚', statusText: 'Available to Fill' });
        }
        if (!cancelled) setOpenVPs(open);
        openCacheRef.current.set(cacheKey, { t: Date.now(), open });

            // ALSO: collect user-owned positions in the current matrix (cycle) for display under OPEN-card
            try {
              if (account) {
                // Determine current cycle range (after last EOL trigger if any)
                const nextTokenId = await vault.nextTokenId();
                const maxTokenId = Number(nextTokenId) - 1;
                let lastEOL = 0;
                if (vault.EOLCycleCount && vault.EOLTriggerAtEntryId) {
                  try {
                    const cycles = Number(await vault.EOLCycleCount());
                    if (cycles > 0) {
                      const trig = Number(await vault.EOLTriggerAtEntryId(cycles));
                      if (!isNaN(trig) && trig > 0) lastEOL = trig;
                    }
                  } catch {}
                }
                if (maxTokenId > 0 && maxTokenId > lastEOL) {
                  const cycleStart = lastEOL > 0 ? lastEOL + 1 : 1;
                  const receiptAddr = await vault.getReceiptContract();
                  const rc = new ethers.Contract(receiptAddr, [
                    'function balanceOf(address, uint256) view returns (uint256)',
                    'function balanceOfBatch(address[], uint256[]) view returns (uint256[])'
                  ], provider);
                  let ids = [];
                  for (let id = cycleStart; id <= maxTokenId; id++) ids.push(id);
                  if (ids.length > 1200) ids = ids.slice(-1200);
                  const owned = [];
                  try {
                    const CHUNK = 100;
                    for (let i = 0; i < ids.length; i += CHUNK) {
                      const slice = ids.slice(i, i + CHUNK);
                      const accounts = Array(slice.length).fill(account);
                      const res = await rc.balanceOfBatch(accounts, slice);
                      if (cancelled) return;
                      slice.forEach((id, idx) => { if (res[idx] && res[idx].toString() !== '0') owned.push(id); });
                    }
                  } catch {
                    // Fallback to single calls (should be rare)
                    for (const id of ids) {
                      try { const bal = await rc.balanceOf(account, id); if (bal && bal.toString() !== '0') owned.push(id); } catch {}
                      if (owned.length > 200) break;
                      if (cancelled) return;
                    }
                  }
                  if (!cancelled) setUserCyclePositions(owned);
                } else {
                  if (!cancelled) setUserCyclePositions([]);
                }
              } else {
                if (!cancelled) setUserCyclePositions([]);
              }
            } catch { if (!cancelled) setUserCyclePositions([]); }
          } catch {
            if (!cancelled) setOpenVPs([]);
          }
        }
    function prefetchNeighborsOpen(){
      try { prefetchOpenForIndex(leftIdx); } catch {}
      try { prefetchOpenForIndex(rightIdx); } catch {}
    }
    async function prefetchOpenForIndex(idx){
      const token = tokens[idx];
      if (!token?.config) return;
      const cfg = token.config;
      const cacheKey = String(cfg.vault||'').toLowerCase();
      const cached = openCacheRef.current.get(cacheKey);
      if (cached && (Date.now() - cached.t) <= 10000) return;
      try {
        const provider = getReadProvider();
        const code = await provider.getCode(cfg.vault);
        if (code === '0x') { openCacheRef.current.set(cacheKey, { t: Date.now(), open: [] }); return; }
        const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);
        let eolCycleCount = 0, totalCurrentEntries = 0, lastEOLTriggerEntry = 0;
        const calls = await Promise.allSettled([
          vault.EOLCycleCount ? vault.EOLCycleCount() : Promise.reject('NA'),
          vault.nextTokenId()
        ]);
        if (calls[0].status === 'fulfilled') eolCycleCount = Number(calls[0].value);
        if (calls[1].status === 'fulfilled') totalCurrentEntries = Math.max(0, Number(calls[1].value) - 1);
        if (eolCycleCount > 0 && vault.EOLTriggerAtEntryId) {
          try { const trig = await vault.EOLTriggerAtEntryId(eolCycleCount); const n = Number(trig); if (n>0) lastEOLTriggerEntry = n; } catch {}
        }
        const matrixSize = token.name.includes('3x3') ? 3 : 4;
        const structureSize = getVPStructureSize(matrixSize);
        const base = getCycleBase(lastEOLTriggerEntry);
        const entriesInCycle = Math.max(0, totalCurrentEntries - base);
        const open = [];
        const nextOpenVPs = [];
        if (entriesInCycle > 0) {
          const vp1Complete = isVPCompleteByIndex(1, totalCurrentEntries, matrixSize, lastEOLTriggerEntry);
          const windowLen = vp1Complete ? (matrixSize === 4 ? 4 : 3) : 1;
          if (!vp1Complete) {
            const leaderId = base + 1;
            const payPoint = getVPPaymentPointByIndex(1, matrixSize, lastEOLTriggerEntry);
            if (totalCurrentEntries < payPoint) {
              const fill = computeVPFilledByIndex(1, totalCurrentEntries, matrixSize, lastEOLTriggerEntry);
              nextOpenVPs.push({ tokenId: leaderId, payPoint, leader: leaderId, filledCount: Math.min(structureSize, fill), structureSize });
            }
          } else {
            const baseline = (matrixSize === 4 ? 20 : 4);
            let firstOpenIdx = null, scan = 2, guard=0;
            while (firstOpenIdx === null && guard++ < 500) {
              const payPoint = getVPPaymentPointByIndex(scan, matrixSize, lastEOLTriggerEntry);
              if (totalCurrentEntries < payPoint) firstOpenIdx = scan; else scan++;
            }
            if (firstOpenIdx !== null) {
              let vpIndex = firstOpenIdx, guard2 = 0;
              while (nextOpenVPs.length < windowLen && guard2++ < 500) {
                const leaderId = base + vpIndex;
                const payPoint = getVPPaymentPointByIndex(vpIndex, matrixSize, lastEOLTriggerEntry);
                if (totalCurrentEntries < payPoint) {
                  let fill = (vpIndex === firstOpenIdx)
                    ? Math.max(baseline, computePrefilledForLeaderIndex(vpIndex, totalCurrentEntries, lastEOLTriggerEntry, matrixSize))
                    : baseline;
                  nextOpenVPs.push({ tokenId: leaderId, payPoint, leader: leaderId, filledCount: Math.min(structureSize, fill), structureSize });
                }
                vpIndex++;
              }
            }
          }
        }
        if (nextOpenVPs.length > 0) open.push({ id:'next_open_vps', nextOpenVPs, stateColor:'💚', statusText:'Available to Fill' });
        openCacheRef.current.set(cacheKey, { t: Date.now(), open });
      } catch {}
    }
    // Debounce to avoid hammering RPC while sliding
    timer = setTimeout(fetchOpenVPs, 250);
    return () => { cancelled = true; if (timer) clearTimeout(timer); };
  }, [carouselIdx, refreshStats, account]);

      // Robust guard: if tokens[carouselIdx] is undefined, show fallback info card
      if (!tokens[carouselIdx]) {
        return (
          <div className="carousel-container">
            {/* Quick navigation button stack over left bar */}
            <div className="quick-nav-stack">
              {(() => {
                const goFAQ = () => {
                  const idx = tokens.findIndex(t => t && t.name === 'Comprehensive Documentation & FAQ');
                  if (idx >= 0) setCarouselIdx(idx);
                };
                const goCarouselHome = () => {
                  const idx = tokens.findIndex(t => t && t.matrixSize);
                  if (idx >= 0) setCarouselIdx(idx);
                };
                const goALL = () => {
                  const idx = tokens.findIndex(t => t && t.name === 'ALL');
                  if (idx >= 0) setCarouselIdx(idx);
                };
                const goFactory = () => {
                  const idx = tokens.findIndex(t => t && t.name === 'Factory');
                  if (idx >= 0) setCarouselIdx(idx);
                };
                return (
                  <>
                    <button className="quick-nav-btn" onClick={goFAQ}>FAQ</button>
                    <button className="quick-nav-btn" onClick={goCarouselHome}>Carousel</button>
                    <button className="quick-nav-btn" onClick={goALL}>ALL Tokens</button>
                    <button className="quick-nav-btn" onClick={goFactory}>Factory</button>
            <div className="quick-nav-search" title="Type and click 🔍">
              <input
                value={searchQuery}
                onChange={e=>setSearchQuery(e.target.value)}
                placeholder="Search…"
                onKeyDown={(e)=>{ if(e.key==='Enter'){ const q=String(searchQuery||'').trim().toLowerCase(); if(!q) return; const allIdx=tokens.findIndex(t=>t&&t.name==='ALL'); const matches=tokens.map((t,i)=> t&&t.matrixSize?{t,i}:null).filter(Boolean).filter(({t})=>{ const n=String(t.name||'').toLowerCase(); const v=String(t.config?.vault||'').toLowerCase(); const tok=String(t.config?.token||'').toLowerCase(); return n.includes(q)||v.includes(q)||tok.includes(q);}).map(x=>x.i); if(matches.length===1){ setCarouselIdx(matches[0]); return;} if(matches.length>1){ try{ window.__ALLFilterQuery=q; }catch{} if(allIdx>=0) setCarouselIdx(allIdx); return;} alert('No matches found.'); }} }
              />
              <button onClick={()=>{ const q=String(searchQuery||'').trim().toLowerCase(); if(!q) return; const allIdx=tokens.findIndex(t=>t&&t.name==='ALL'); const matches=tokens.map((t,i)=> t&&t.matrixSize?{t,i}:null).filter(Boolean).filter(({t})=>{ const n=String(t.name||'').toLowerCase(); const v=String(t.config?.vault||'').toLowerCase(); const tok=String(t.config?.token||'').toLowerCase(); return n.includes(q)||v.includes(q)||tok.includes(q);}).map(x=>x.i); if(matches.length===1){ setCarouselIdx(matches[0]); return;} if(matches.length>1){ try{ window.__ALLFilterQuery=q; }catch{} if(allIdx>=0) setCarouselIdx(allIdx); return;} alert('No matches found.'); }}>🔍</button>
            </div>
                  </>
                );
              })()}
            </div>
            <div className="carousel-title">Pulse MATRIX RESEARCH game</div>
            <div className="carousel">
              <div className="MAIN-card">
                {/* Add to MetaMask Fox Button - Top Right Corner  */}
                {!isSpecialPage && (
                  <div
                    onClick={() => addTokenToMetaMask(tokens[carouselIdx].config)}
                    style={{
                      position: 'absolute',
                      top: '20px',
                      right: '20px',
                      cursor: 'pointer',
                      fontSize: '1.5em',
                      zIndex: 9999,
                      pointerEvents: 'auto',
                      color: 'inherit',
                      fontFamily: '"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji", emoji, system-ui, sans-serif',
                      lineHeight: 1,
                      background: 'transparent'
                    }}
                    title={'Add token to MetaMask' + (tokens[carouselIdx]?.config?.token ? ' (' + tokens[carouselIdx].config.token.slice(0,6) + '...' + tokens[carouselIdx].config.token.slice(-4) + ')' : '')}
                  >
                    🦊
                  </div>
                )}
                <div style={{
                  marginTop: '2em',
                  background: 'rgba(30,30,30,0.7)',
                  borderRadius: '1.2em',
                  padding: '2em 2.2em',
                  fontSize: '1.2em',
                  color: '#ffd93d',
                  boxShadow: '0 2px 8px #0004',
                  minWidth: '270px',
                  maxWidth: '350px',
                  marginLeft: 'auto',
                  marginRight: 'auto',
                  textAlign: 'center',
                  fontWeight: 500
                }}>
                  Page not found or tokens not loaded. Please reload or check your config.
                </div>
                {/* Free claim button (matrix style) for PuMa-only with 1h cooldown */}
        {tokens[carouselIdx].name && tokens[carouselIdx].name.includes('PuMa') && canClaimPuMa() && (
                  <div style={{
                    position: 'fixed',
                    right: '8vw',
                    bottom: 40,
                    transform: 'none',
          zIndex: 200,
                    width: 'auto',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'flex-end',
                    pointerEvents: 'auto'
                  }}>
                    <button
                      style={{
                        background: '#000',
                        color: '#00ff00',
                        border: '1.5px solid #00ff00',
                        borderRadius: '0.8em',
                        padding: '0.35em 1.1em',
                        fontSize: '0.95em',
                        fontWeight: 'bold',
                        cursor: 'pointer',
                        marginBottom: '2px',
                        zIndex: 101,
                        boxShadow: '0 6px 18px rgba(0,255,0,0.2)'
                      }}
                      onClick={freeClaimPuMa}
                      onMouseEnter={(e) => { e.target.style.background = 'rgba(0,255,0,0.10)'; }}
                      onMouseLeave={(e) => { e.target.style.background = '#000'; }}
                    >
                      free claim
                    </button>
                    <span style={{ fontSize: '0.7em', color: '#00ff00', opacity: 0.8, marginTop: '1px', fontWeight: 500 }}>1x/Hour</span>
                  </div>
                )}
        {tokens[carouselIdx].name && tokens[carouselIdx].name.includes('PuMa') && !canClaimPuMa() && (
                  <div style={{
                    position: 'fixed',
                    right: '8vw',
                    bottom: 40,
                    transform: 'none',
          zIndex: 200,
                    width: 'auto',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'flex-end',
                    pointerEvents: 'none',
                    opacity: 0.85
                  }}>
                    <button
                      style={{
                        background: '#111',
                        color: '#0f0',
                        border: '1.5px solid #0a0',
                        borderRadius: '0.8em',
                        padding: '0.35em 1.1em',
                        fontSize: '0.95em',
                        fontWeight: 'bold',
                        cursor: 'not-allowed',
                        opacity: 0.7,
                        marginBottom: '2px',
                        zIndex: 101,
                        boxShadow: '0 2px 8px #0008'
                      }}
                      disabled
                    >
                      free claim
                    </button>
                    <Countdown lastClaim={lastPuMaClaim} />
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      }

      const currentToken = tokens[carouselIdx];
      const isMatrixToken = currentToken.matrixSize; // Has matrix size
  const isSpecialPage = ['Comprehensive Documentation & FAQ', 'FAQ', 'Mail Notification', 'Coming soon'].includes(currentToken.name);

      // Collapsible sections: all collapsed by default except Research Disclaimer
      const [faqOpen, setFaqOpen] = React.useState(() => ({ disclaimer: true }));
      const toggleFaq = (id) => setFaqOpen(o => ({ ...o, [id]: !o[id] }));

  const faqSections = React.useMemo(() => ([
        // Disclaimer (open by default via state) - red outlined box
        { id: 'disclaimer', title: '⚠️ RESEARCH DISCLAIMER', body: `<div class="disclaimer-box"><p>This project is offered purely for RESEARCH purposes only! This is an immutable, trustless, Fully Decentralized, Finished product, autonomous smart contract system with NO ADMIN KEYS and NO OFF switch. By participating, you acknowledge you enter the Matrix at your own risk. This is not financial advice and carries inherent smart-contract and blockchain risks.</p></div>` },
        // What is PuMa
        { id: 'what', title: '🎯 What is Pulse Matrix - PuMa?', body: `
          <p>PuMa (Pulse Matrix) is an autonomous VP RESEARCH system with a FIXED 3x3 OR 4x4 matrix option. Participants can enter with FREE PuMa tokens and earn Puma through mathematical progression logic. The system auto-configures based on matrix size choice.</p>
          <div class="highlight-box">
            <h5>Key Innovation:</h5>
            <p>PuMa now supports both <strong>3x3 (Fast/safer)</strong> and <strong>4x4 (Slow/More RISK/HIGHER-reward)</strong> configurations with automatic parameter adjustment. Each matrix type uses sequential entry logic with mathematical progression rather than physical user based filling.</p>
          </div>
          <h5>🎮 Core Mechanics</h5>
          <ul>
            <li><strong>Dual Matrix Support:</strong> Choose between 3x3 (13 positions) or 4x4 (85 positions) for any coins that entered the matrix</li>
            <li><strong>Sequential Entry:</strong> TokenIDs are assigned sequentially for each coin/size (1, 2, 3...) and never reset</li>
            <li><strong>Non-Transferable erc1155 Receipts:</strong> Erc1155 Entry tokens cannot be traded or transferred, permanently linked to original owners address</li>
            <li><strong>Auto-Pay System:</strong> ALL users get paid automatically when their auto-pay point is reached - no manual claiming needed</li>
            <li><strong>Smart Auto-Pay Logic:</strong> 3x3 uses "+9 spacing", 4x4 uses "+64 spacing" after first payout</li>
            <li><strong>Payout Multipliers:</strong> 3x3 pays 5.555x, 4x4 pays 55.55x entry fee</li>
            <li><strong>EOL Unclog Mechanism:</strong> Any token holder can click 🪠 and automatically redistribute vault reserves to the stuck owners of the NFT's if growth stalls for 36.9 days, and spawns a fresh new fast matrix</li>
            <li><strong>Enhanced EOL Pools:</strong> 6.445x (3x3) or 27.45x (4x4) entry fees stay in vault for EOL auto-pay sharing</li>
            <li><strong>Autonomous Operation:</strong> Immutable, Trustless, Fully Decentralized, Finished product with NO admin keys, NO Off button and fully self-managing system</li>
          </ul>
            <div class="faq-box states-box">
            <h5>🚥 4-Color State System</h5>
            <div class="highlight-box">
              <h5>State Meanings</h5>
              <ul>
                <li>💚 <strong>Active</strong> — New/active entry progressing toward its auto-pay point</li>
                <li>💛 <strong>Ready</strong> — Approaching threshold; in the pre pay-window for upcoming auto-pay</li>
                <li>🧡 <strong>Auto-payable</strong> — Eligible for automatic payout now (either via regular auto-pay or in an EOL batch)</li>
                <li>❤️ <strong>Paid</strong> — Auto-pay completed for this entry in the current cycle</li>
              </ul>
            </div>
            <div class="math-example">
              <h5>Transitions</h5>
              <ul>
                <li>💚 → 💛 as your sequential position approaches the auto-pay point</li>
                <li>💛 → 🧡 once the auto-pay point is hit (or when included in an EOL payout batch)</li>
                <li>🧡 → ❤️ immediately after the system sends the automatic payout</li>
              </ul>
            </div>
            <p style="opacity:.9">Note: Colors reflect payout progress for a single entry, not profit/loss. They’re derived from on-chain state and thresholds; no manual actions required.</p>
          </div>
        ` },
        
  // Quick Start
        { id: 'quickstart', title: '🚀 Quick Start: How Do I Get Started?', body: `
          <p>This fast-track guide gets you from zero to your first VP entry safely. Read fully before sending any tokens.</p>
          <div class="highlight-box">
            <h5>⚡ 8-Step Launch Sequence</h5>
            <ol>
              <li><strong>Create / Use Fresh NEW Wallet:</strong> For our research systems always use a NEW dedicated MetaMask DO NOT GOOGLE IT use direct link <a href="https://metamask.io/" target="_blank" rel="noopener noreferrer">https://metamask.io/</a> (or compatible like <a href="https://internetmoney.io/" target="_blank" rel="noopener noreferrer">https://internetmoney.io/</a>) wallet.</li>
              <li><strong>Add PulseChain Network:</strong> (Chain ID 369) if not already added (see Network Config below).</li>
              <li><strong>Get some Gas money (Pulse Chain testnet V4):</strong> Go to <a href="https://faucet.v4.testnet.pulsechain.com/" target="_blank" rel="noopener noreferrer">https://faucet.v4.testnet.pulsechain.com/</a> to get a small amount of <strong>tPLS</strong> (native for testnet V4) for transaction fees.</li>
              <li><strong>Fund Gas (Pulse Chain Mainnet):</strong> Acquire a small amount of <strong>PLS</strong> (native) for transaction fees.</li>
              <li><strong>Claim Free PuMa:</strong> Use the FREE hourly PuMa token claim in the DApp. Run a few free claim → join cycles to observe auto-pay & receipt burn before risking other tokens.</li>
              <li><strong>Get other Tokens (Optional):</strong> If you plan to join a token vault (pHEX, PLSX, eHEX, pDAI, etc.) obtain those tokens or bridge them to PulseChain.</li>
              <li><strong>Open DApp & Connect:</strong> Visit the main interface (Matrix page) and click CONNECT. Confirm in wallet.</li>
              <li><strong>Select Matrix & Token:</strong> Choose 3x3 (faster / lower payout) or 4x4 (slower / higher payout) for the token you want.</li>
              <li><strong>Approve (PRC20) then Join:</strong> First Approve (default 10x entry fee per token), then click Join VP. Wait for confirmation. Receive your <strong>ERC1155</strong> receipt token. Done. (this token will be automatically burned when you get paid)</li>
            </ol>
          </div>
          <div class="math-example">
            <h5>🛰️ Network Config (PulseChain)</h5>
            <p><strong>Network Name:</strong> PulseChain<br>
            <strong>RPC URL:</strong> https://rpc.pulsechain.com<br>
            <strong>Chain ID:</strong> 369<br>
            <strong>Currency Symbol:</strong> PLS<br>
            <strong>Explorer:</strong> https://scan.pulsechain.com</p>
            <div class="highlight-box" style="margin-top:0.6em">
              <button onclick="window.addPulseMainnet && window.addPulseMainnet()" style="padding:6px 10px;border-radius:8px;border:1px solid #0f0;background:#000;color:#0f0;cursor:pointer;margin-right:8px;">Add PulseChain (369)🦊</button>
              <button onclick="window.addPulseTestnet && window.addPulseTestnet()" style="padding:6px 10px;border-radius:8px;border:1px solid #0f0;background:#000;color:#0f0;cursor:pointer;">Add Testnet v4 (943)🦊</button>
            </div>
          </div>
          <div class="highlight-box">
            <h5>💡 Pro Tips</h5>
            <ul>
              <li><strong>Test with FREE PuMa tokens First:</strong> Start with the smallest entry token you hold to observe an auto-pay cycle.</li>
              <li><strong>Track Your Positions:</strong> Use the "Your Positions" list in the DApp to see all token IDs you own.</li>
              <li><strong>No Manual Claims:</strong> All payouts are automatic (regular or EOL).</li>
              <li><strong>Gas Efficiency:</strong> Approval is for 10 x entry fee (unless you change it).</li>
            </ul>
          </div>
          <div class="danger-box">
            <h5>⚠️ Safety Reminders</h5>
            <ul>
              <li>Never expose seed phrase. Use hardware wallet for larger values.</li>
              <li>Double-check contract addresses you interact with.</li>
              <li>Keep some extra PLS for future EOL batch gas continuation if you plan to help the system.</li>
            </ul>
          </div>
        ` },
        // Glossary (Cheat Sheet)
        { id: 'glossary', title: '📚 Glossary (Cheat Sheet)', body: `
          <div class="faq-box">
            <ul>
              <li><strong>VP (Virtual Position):</strong> The top position in a cycle that receives the next auto-pay.</li>
              <li><strong>TokenID:</strong> Your sequential receipt ID (ERC-1155) that marks your place in the flow.</li>
              <li><strong>Auto‑pay:</strong> Automatic payout when your TokenID reaches its payment point; burns the receipt.</li>
              <li><strong>EOL (End‑of‑Life):</strong> Safety valve that redistributes the vault to unpaid entries after 36.9 days of inactivity and starts a fresh matrix.</li>
              <li><strong>Cycle:</strong> The range of TokenIDs since the last EOL trigger (or from #1 if none yet).</li>
              <li><strong>Trigger:</strong> The special join that hits a payment point; gets a 3.69% entry discount.</li>
              <li><strong>Entry Fee:</strong> The amount required to join a matrix for a given token.</li>
              <li><strong>Payout Multiplier:</strong> Fixed by matrix: 5.555x (3x3) or 55.55x (4x4).</li>
              <li><strong>Vault:</strong> Contract balance that funds auto-pays and EOL distributions.</li>
            </ul>
          </div>
        ` },
        // Success Factors (standalone section placed right after Quick Start)
        { id: 'success', title: '🎯 Matrix System Success Factors => YOUR JOB !!', body: `
          <div class="highlight-box">
            <h5>⚡ Critical Success Requirements for ANY Matrix:</h5>
            <ul>
              <li><strong>Active Promotion:</strong> Continuously market your matrix to potential participants</li>
              <li><strong>Fair Pricing:</strong> Set entry fees that balance accessibility with meaningful rewards</li>
              <li><strong>Community Support:</strong> Maintain active communication and support channels</li>
              <li><strong>Consistent Activity:</strong> Ensure regular new entries to prevent EOL triggers</li>
              <li><strong>Long-term Vision:</strong> Build sustainable growth rather than quick pumps</li>
            </ul>
          </div>
        ` },
        // Safety Guidelines
        { id: 'safety', title: '🛡️ What Safety Guidelines Should I Follow?', body: `
          <div class="warning-box"><h5>🚨 Critical Safety Rules</h5></div>
          <ul>
            <li><strong>Fresh Wallet:</strong> Use a NEW dedicated wallet, not your primary holdings wallet.</li>
            <li><strong>Limit Risk:</strong> Only allocate amounts you are 100% prepared to lose (research context).</li>
            <li><strong>Know Immutability:</strong> Contracts can’t be paused, upgraded, or hot-fixed.</li>
            <li><strong>Read First:</strong> Understand auto-pay + EOL flow before joining.</li>
            <li><strong>Test Small and with the FREE PuMa tokens:</strong> Do a minimal entry to watch one full payout.</li>
            <li><strong>Maintain Gas:</strong> Keep a buffer of PLS for approvals, joins, and optional EOL batch processing.</li>
            <li><strong>Secure Keys:</strong> Back up seed phrase offline; prefer hardware wallet for scale.</li>
            <li><strong>No Guarantees:</strong> Outcome depends on continued participation of ALL USERS including YOU!; no promises.</li>
          </ul>
          <div class="highlight-box"><p><strong>Autonomy Reminder:</strong> There are <em>no admin keys</em>. All logic self-executes; funds flow only through deterministic auto-pay or EOL batches.</p></div>
        ` },
  // Entry Fees & Multipliers
  { id: 'fees', title: '💵 Entry Fees & Multipliers (Defaults by Matrix)', body: `
      <p>Defaults shown for the PuMa token. Other tokens deployed via Factory pick their own entry fees; multipliers are fixed per matrix size.</p>
      <div class="math-example">
        <h5>📌 Defaults (PuMa token)</h5>
        <p><strong>PuMa3x3 Entry Fee:</strong> 369 PuMa • <strong>Auto-payout:</strong> 5.555x = 2,049.795 PuMa</p>
        <p><strong>PuMa4x4 Entry Fee:</strong> 555.5 PuMa • <strong>Auto-payout:</strong> 55.55x = 30,858.03 PuMa</p>
        <p><strong>EOL Vault Components:</strong><br>
           3x3: 6.445x retained for EOL auto-pays<br>
           4x4: 27.45x retained for EOL auto-pays</p>
      </div>
      <div class="highlight-box">
        <h5>🛠️ Deploying Other Tokens</h5>
        <ul>
          <li>Factory lets you set ANY entry fee appropriate for your token economics.</li>
          <li>Multipliers (5.555x / 55.55x) are FIXED by matrix size.</li>
          <li>Retention portions (6.445x / 27.45x) always flow to EOL pool logic.</li>
          <li>Keep pricing accessible—healthy flow reduces reliance on EOL.</li>
          <li>If a token becomes too valuable and the matrix stalls, you can make a NEW Matrix with a smaller amount, and re-start the process.</li>
        </ul>
      </div>
            <div class="warning-box">
                <h5>⚠️ Important</h5>
                <p>Listing multiple tokens with static numbers caused confusion. Focus on understanding the multipliers; token-specific entry fees are a launch choice, not a protocol constant.</p>
            </div>
        ` },
        // Matrix Logic
        { id: 'logic', title: '🧮 Matrix Logic Explained', body: `
          <p>PuMa supports two matrix configurations with different auto-pay logic:</p>
          <h5>💚 3x3 Matrix (Fast & Safe)</h5>
          <div class="formula">Auto-Pay Point = 13 + ((TokenID - 1) × 9)</div>
          <div class="math-example">
            <h5>📊 3x3 Example Auto-Pay Calculations:</h5>
            <p><strong>TokenID #1:</strong> Auto-pay point = 13 + (0 × 9) = 13 → Paid at 13th join</p>
            <p><strong>TokenID #2:</strong> 13 + (1 × 9) = 22</p>
            <p><strong>TokenID #5:</strong> 13 + (4 × 9) = 49</p>
            <p><strong>Universal Auto-Pay:</strong> 5.555x paid instantly, receipt burned</p>
            <p><strong>Vault Enhancement:</strong> 6.445x retained for EOL</p>
          </div>
          <h5>❤️ 4x4 Matrix (High Stakes)</h5>
          <div class="formula">Auto-Pay Point = 85 + ((TokenID - 1) × 64)</div>
          <div class="math-example">
            <h5>📊 4x4 Example Auto-Pay Calculations:</h5>
            <p><strong>TokenID #1:</strong> 85</p>
            <p><strong>TokenID #2:</strong> 149</p>
            <p><strong>TokenID #3:</strong> 213</p>
            <p><strong>Universal Auto-Pay:</strong> 55.55x paid instantly, receipt burned</p>
            <p><strong>Vault Enhancement:</strong> 27.45x retained for EOL</p>
          </div>
          <div class="highlight-box">
            <h5>💡 Why Different Spacing Works:</h5>
            <p><strong>3x3 "+9 Logic":</strong> Faster cycles, lower rewards<br><strong>4x4 "+64 Logic":</strong> Slower cycles, higher rewards, higher EOL risk</p>
          </div>
        ` },
        // Auto-Pay Trigger Discount System
        { id: 'discount', title: '🎫 Auto-Pay Trigger Discount System', body: `
          <p>Discount rewards positions that trigger auto-pays.</p>
          <h5>🔄 How It Works</h5>
          <div class="highlight-box">
            <h5>✨ Key Innovation</h5>
            <ul>
              <li><strong>Trigger Positions Only:</strong> Positions that trigger auto-pay get a 3.69% discount on the entry fee</li>
              <li><strong>Math Pattern:</strong> 3x3: 13,22,31,... (+9) | 4x4: 85,149,213,... (+64)</li>
              <li><strong>Gas Compensation:</strong> Discount offsets extra gas for triggering auto-pay</li>
            </ul>
          </div>
          <h5>💰 Discount Calculation Examples</h5>
          <div class="math-example">
            <p><strong>3x3 (Entry 369):</strong> Trigger pays ≈355.41 (3.69% less)</p>
            <p><strong>4x4 (Entry 555.5):</strong> Trigger pays ≈534.99 (3.69% less)</p>
          </div>
          <h5>🎯 Strategic Benefits</h5>
          <div class="highlight-box">
            <ul>
              <li>Offsets gas</li>
              <li>Predictable pattern</li>
              <li>Incentivizes smooth flow</li>
            </ul>
          </div>
          <h5>🔄 Lifecycle Pattern</h5>
          <div class="math-example">
            <p>1–12 fill → 13 triggers auto-pay #1 → 22 triggers #2 → 31 triggers #3 ...</p>
          </div>
        ` },
        
  // EOL System
  { id: 'eol', title: '🔄 EOL (End of Life) System', body: `
    <p><strong>Trigger reward factor:</strong> 0.3690x (3x3) or 0.5555x (4x4). The on-chain <em>trigger reward</em> = factor × entry fee and is paid to the caller as batches progress.</p>
    <p>User-called <strong>'unclog'</strong> feature (use the 🪠 in the History section. Caller must have entries) to redistribute the vault if growth stalls. (36.9 days)</p>
          <h5>Trigger Conditions</h5>
          <ol>
            <li><strong>Minimum Entries:</strong> ≥4 (3x3) / ≥10 (4x4)</li>
            <li><strong>Time Delay:</strong> 36.9 days since last entry</li>
            <li><strong>Holder Requirement:</strong> Caller must have entries</li>
            <li><strong>Funds Available:</strong> Vault balance available minus trigger reward</li>
          </ol>
          <h5>Sequence</h5>
          <ol>
            <li>Snapshot balances</li>
            <li>Reserve trigger reward (factor × entry fee)</li>
            <li>Pool allocation</li>
            <li>Spawn fresh matrix</li>
            <li>Batch auto-pays</li>
          </ol>
          <div class="math-example">
            <h5>📈 Example Puma4x4 (10 entries @555.5)</h5>
            <p>Vault = 5,555.0 | Reward ≈308.58 | Pool ≈5,246.42 → ≈524.642 each.</p>
          </div>
          <div class="warning-box">
            <h5>Batched Processing (for large amount of holders)</h5>
            <ul>
              <li>Default max 369 entries per batch (configurable)</li>
              <li>Trigger processes first batch</li>
              <li>continueEOLProcessing for next batches</li>
            </ul>
          </div>
        ` },
        // FAQ list
        { id: 'faqs', title: '❓ Frequently Asked Questions', body: `
          <h5>Q: Are receipt tokens transferable?</h5>
          <p><strong>No.</strong> Permanently bound to original wallet address.</p>
          <h5>Q: Who pays the gas for auto-pay?</h5>
          <p>Trigger joiner (13th / 85th) pays extra gas; but gets a 3.69% discount on the entry fee.</p>
          <h5>Q: What if auto-pay fails?</h5>
          <p>Fails are recorded & retried via later triggers or EOL batches.</p>
          <h5>Q: Difference 3x3 vs 4x4?</h5>
          <p>3x3: 13 spots, 5.555x, +9 spacing. 4x4: 85 spots, 55.55x, +64 spacing.</p>
          <h5>Q: Vault funds on VP completion?</h5>
          <p>Multiplier paid; retention stays for EOL (6.445x / 27.45x portions).</p>
          <h5>Q: Positions at EOL?</h5>
          <p>Open unpaid positions share EOL pool proportionally.</p>
          <h5>Q: Matrix choice?</h5>
          <p>3x3 = faster / safer. 4x4 = higher risk-reward / slower.</p>
          <h5>Q: After EOL?</h5>
          <p>Fresh matrix spawns immediately.</p>
          <h5>Q: EOL bonuses?</h5>
          <p>0.3690x (3x3) vs 0.5555x (4x4) for caller incentive to pay the auto-pay fee.</p>
          <h5>Q: Can i see the Dev section?</h5>
          <p>Absolutely, password is 5555</p>
        ` },
        // Factory System
        { id: 'factory', title: '🏭 Matrix Factory System', body: `
          <p>In the FACTORY users can deploy new matrices for any PRC20. Success depends on community execution.</p>
          <div class="highlight-box">
            <h5>🚀 Deployment</h5>
            <ul>
              <li>Only 3 Parameters: token address, entry fee, matrix size</li>
              <li>Immediate live contract</li>
            </ul>
          </div>
          <div class="warning-box">
            <h5>YOUR RESPONSIBILITY</h5>
            <ul>
              <li>Promote & build community</li>
              <li>Create demand & retention</li>
              <li>Strategize sustainable growth</li>
            </ul>
          </div>
        ` },
        // MetaMask Problems
        { id: 'metamask', title: '🦊 MetaMask Connection Problems', body: `
          <p>Common issues & fixes.</p>
          <div class="highlight-box">
            <h5>🔗 Checklist</h5>
            <ol>
              <li>Make sure you use the Correct Network PulseChain (Chain ID 369)</li>
              <li>Account unlocked</li>
              <li>Reset site permissions</li>
              <li>Hard refresh / 'alt F5' in your browser</li>
            </ol>
          </div>
          <div class="math-example">
            <h5>🛠️ Network Settings</h5>
            <p><strong>Name:</strong> PulseChain<br><strong>RPC:</strong> https://rpc.pulsechain.com<br><strong>Chain ID:</strong> 369<br><strong>Symbol:</strong> PLS</p>
          </div>
          <div class="warning-box">
            <h5>⚡ Quick Fixes</h5>
            <ul><li>Lock/unlock wallet</li>
              <li>Clear site data</li>
              <li>Disable extensions</li>
              <li>Use arrows < or > to navigate </li>
              <li>Reset account nonce</li></ul>
          </div>
        ` },
        // Security, Risk & AI Audit (combined)
        { id: 'security', title: '🛡️ Security, Risk Management & AI Audit', body: `
          <div class="warning-box"><h5>🔬 Research Reminder</h5><p>Experimental autonomous system. Treat as research.</p></div>
          <div class="highlight-box"><h5>✅ Features</h5><ul><li>No Admin Keys</li><li>Immutable Logic</li><li>Open Source</li><li>Predictable thresholds</li></ul></div>
          <div class="danger-box"><h5>⚠️ Risks</h5><ul><li>Smart contract bugs</li><li>Network issues</li><li>Market price volatility</li><li>Participation slowdown</li></ul></div>
          <h5>✅ Security Audit Passed by AI</h5>
          <div class="highlight-box"><h5>🏭 Deployment Ready</h5><ul><li>Abstract & Robust Vault design</li><li>Universal token compatibility</li><li>Dynamic config (User token implementation)</li><li>Standard ABI for all</li></ul></div>
          <div class="warning-box"><h5>🔒 Attack Vectors Mitigated</h5><ul><li>Reentrancy guarded</li><li>Try-catch isolation</li><li>Overflow protected</li><li>Front-running resistant</li><li>Immutable params</li></ul></div>
          <div class="danger-box"><h5>💰 Economic Security</h5><ul><li>Vault reserves retention</li><li>Discount logic for 'pay' entries</li><li>Robust EOL unclog mechanism</li><li>Non-transferable receipts</li></ul></div>
        ` },
      ]), []);

      return (
        <>
          {/* Sidebar Navigation */}
          <div className="carousel-nav-bar left" onClick={() => setCarouselIdx(leftIdx)}>
            <span className="carousel-nav-arrow">&#9664;</span>
          </div>
          <div className="carousel-nav-bar right" onClick={() => setCarouselIdx(rightIdx)}>
            <span className="carousel-nav-arrow">&#9654;</span>
          </div>
          
          {/* Fixed quick navigation button stack over left nav bar */}
          <div className="quick-nav-stack">
            {(() => {
              const goFAQ = () => {
                const idx = tokens.findIndex(t => t && t.name === 'Comprehensive Documentation & FAQ');
                if (idx >= 0) setCarouselIdx(idx);
              };
              const goCarouselHome = () => {
                const idx = tokens.findIndex(t => t && t.matrixSize);
                if (idx >= 0) setCarouselIdx(idx);
              };
              const goALL = () => {
                const idx = tokens.findIndex(t => t && t.name === 'ALL');
                if (idx >= 0) setCarouselIdx(idx);
              };
              const goFactory = () => {
                const idx = tokens.findIndex(t => t && t.name === 'Factory');
                if (idx >= 0) setCarouselIdx(idx);
              };
              return (
                <>
                  <button className="quick-nav-btn" onClick={goFAQ}>FAQ</button>
                  <button className="quick-nav-btn" onClick={goCarouselHome}>Carousel</button>
                  <button className="quick-nav-btn" onClick={goALL}>ALL Tokens</button>
                  <button className="quick-nav-btn" onClick={goFactory}>Factory</button>
                  <div className="quick-nav-search" title="Type and click 🔍">
                    <input
                      value={searchQuery}
                      onChange={e=>setSearchQuery(e.target.value)}
                      placeholder="Search…"
                      onKeyDown={(e)=>{ if(e.key==='Enter'){ const q=String(searchQuery||'').trim().toLowerCase(); if(!q) return; const allIdx=tokens.findIndex(t=>t&&t.name==='ALL'); const matches=tokens.map((t,i)=> t&&t.matrixSize?{t,i}:null).filter(Boolean).filter(({t})=>{ const n=String(t.name||'').toLowerCase(); const v=String(t.config?.vault||'').toLowerCase(); const tok=String(t.config?.token||'').toLowerCase(); return n.includes(q)||v.includes(q)||tok.includes(q);}).map(x=>x.i); if(matches.length===1){ setCarouselIdx(matches[0]); return;} if(matches.length>1){ try{ window.__ALLFilterQuery=q; }catch{} if(allIdx>=0) setCarouselIdx(allIdx); return;} alert('No matches found.'); }} }
                    />
                    <button onClick={()=>{ const q=String(searchQuery||'').trim().toLowerCase(); if(!q) return; const allIdx=tokens.findIndex(t=>t&&t.name==='ALL'); const matches=tokens.map((t,i)=> t&&t.matrixSize?{t,i}:null).filter(Boolean).filter(({t})=>{ const n=String(t.name||'').toLowerCase(); const v=String(t.config?.vault||'').toLowerCase(); const tok=String(t.config?.token||'').toLowerCase(); return n.includes(q)||v.includes(q)||tok.includes(q);}).map(x=>x.i); if(matches.length===1){ setCarouselIdx(matches[0]); return;} if(matches.length>1){ try{ window.__ALLFilterQuery=q; }catch{} if(allIdx>=0) setCarouselIdx(allIdx); return;} alert('No matches found.'); }}>🔍</button>
                  </div>
                </>
              );
            })()}
          </div>

          <div className="carousel-container">
            <div className="carousel-title">Pulse MATRIX RESEARCH game</div>
            <div className="carousel">
              <div className="MAIN-card">
                {(() => {
                  // Matrix-style Share button (top-right). Copies a link to this page/token.
                  const shareBtnStyle = {
                    position: 'absolute', top: '20px', right: '20px', zIndex: 10000,
                    background: '#000', color: '#00ff00', border: '1.5px solid #00ff00',
                    borderRadius: '10px', padding: '6px 10px', fontSize: '.72rem', fontWeight: 700,
                    letterSpacing: '0.03em', textTransform: 'uppercase', cursor: 'pointer',
                    boxShadow: '0 6px 18px rgba(0,255,0,0.18)'
                  };
                  return (
                    <button
                      onClick={() => {
                        try {
                          const slug = slugifyToken(currentToken.name || '');
                          const base = window.location.origin + window.location.pathname;
                          const url = `${base}#page=${slug}`;
                          if (navigator.clipboard && navigator.clipboard.writeText) {
                            navigator.clipboard.writeText(url);
                          } else {
                            const ta = document.createElement('textarea'); ta.value = url; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
                          }
                          try { setTxMsgs(m => ({...m, share: 'Link copied'})); setTimeout(()=>setTxMsgs(m=>{ const n={...m}; delete n.share; return n; }), 1500); } catch {}
                        } catch {}
                      }}
                      title="Copy share link"
                      style={shareBtnStyle}
                    >Share</button>
                  );
                })()}
                
                {/* Image with matrix size overlays */}
                <div style={{position: 'relative', display: 'inline-block'}}>
                  <img
                    src={tokens[carouselIdx].img || 'Pics/factory.png'}
                    alt={tokens[carouselIdx].name}
                    style={{cursor:'default'}}
                    onError={(e)=>{ if(e.target.dataset.fallback!=='factory'){ e.target.dataset.fallback='factory'; e.target.src='Pics/factory.png'; } else { e.target.src='Pics/ALL.png'; } }}
                  />
                  {tokens[carouselIdx].matrixSize && (
                    <>
                      {/* Top-left corner number */}
                      <div style={{
                        position: 'absolute',
                        top: '25px',
                        left: '15px',
                        fontSize: '20px',
                        fontWeight: 'bold',
                        color: '#00ff00',
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                        zIndex: 10
                      }}>
                        {tokens[carouselIdx].matrixSize}
                      </div>
                      {/* Top-right corner number */}
                      <div style={{
                        position: 'absolute',
                        top: '25px',
                        right: '15px',
                        fontSize: '20px',
                        fontWeight: 'bold',
                        color: '#00ff00',
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                        zIndex: 10
                      }}>
                        {tokens[carouselIdx].matrixSize}
                      </div>
                      {/* Bottom-left corner number */}
                      <div style={{
                        position: 'absolute',
                        bottom: '25px',
                        left: '15px',
                        fontSize: '20px',
                        fontWeight: 'bold',
                        color: '#00ff00',
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                        zIndex: 10
                      }}>
                        {tokens[carouselIdx].matrixSize}
                      </div>
                      {/* Bottom-right corner number */}
                      <div style={{
                        position: 'absolute',
                        bottom: '25px',
                        right: '15px',
                        fontSize: '20px',
                        fontWeight: 'bold',
                        color: '#00ff00',
                        textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                        zIndex: 10
                      }}>
                        {tokens[carouselIdx].matrixSize}
                      </div>
                    </>
                  )}
                </div>
    <div className="title-row" style={{display:'inline-flex', alignItems:'baseline', gap:'6px'}}>
                  <div className="token-title" style={{display:'inline-flex', alignItems:'center', gap:'8px'}}>
                    <span>{currentToken.name}</span>
                  </div>
                  {!isSpecialPage && currentToken.name !== 'ALL' && currentToken.name !== 'Factory' && (
                    <span
                      onClick={() => addTokenToMetaMask(currentToken.config)}
                      title={'Add token to MetaMask' + (currentToken?.config?.token ? ' (' + currentToken.config.token.slice(0,6) + '...' + currentToken.config.token.slice(-4) + ')' : '')}
                      style={{
      cursor:'pointer', display:'inline', background:'transparent', border:'none', boxShadow:'none',
      padding:0, margin:0, marginLeft:'6px', color:'inherit', fontSize:'1.5em', lineHeight:1, verticalAlign:'baseline'
                      }}
                    >
                      🦊
                    </span>
                  )}
                </div>
                
                {/* Show wallet info if connected */}
        {account && (
                  <div className="wallet-info" style={{display:'flex',alignItems:'center',gap:'0.6em'}}>
                    <span>Connected: {account.slice(0, 6)}...{account.slice(-4)}</span>
                    <span title="Active read chain ID" style={{opacity:0.9}}>🔗 {Number(window.__READ_CHAIN_ID || window.DEFAULT_CHAIN_ID || 943)}</span>
                    {currentToken && currentToken.config && currentToken.config.token ? (
                      <span title={`Token address: ${currentToken.config.token}`} style={{opacity:0.9}}>🪙 {currentToken.config.token.slice(0,6)}...{currentToken.config.token.slice(-4)}</span>
                    ) : null}
                    {/* Ganache switch removed */}
                  </div>
                )}
                
                {/* Matrix token conditional: account connected = data card, otherwise = button */}
                {currentToken.name === 'Comprehensive Documentation & FAQ' ? (
                  <div style={{
                    width:'100%',
                    display:'flex',
                    flexDirection:'column',
                    alignItems:'center'
                  }}>
                    <div style={{
                      width:'85%',
                      textAlign:'left',
                      padding:'0 1.2em 1.4em 1.2em',
                      boxSizing:'border-box',
                      marginTop:'1.2em',
                      color:'#00ff00',
                      fontSize:'1.05em', // increased base font size
                      lineHeight:1.6,
                      fontFamily:'monospace'
                    }}>
                      <style>{`
                        .faq-section-title{cursor:pointer;padding:0.55em 0;font-weight:600;color:#00ff88;border-bottom:1px solid rgba(0,255,0,0.25);font-size:1.18em;}
                        .faq-section-title:hover{color:#00ffaa;}
                        .faq-box{margin:0.65em 0 1.1em 0;padding:0.9em 1em;border-radius:0.8em;background:rgba(0,40,0,0.45);border:1px solid rgba(0,255,0,0.25);}
                        .highlight-box{background:rgba(0,100,0,0.15);border-left:4px solid rgba(0,255,0,0.5);} 
                        /* Remove 4-Color State System from FAQ */
                        .states-box{display:none !important;}
                        .warning-box{background:rgba(100,100,0,0.3);border-left:4px solid #ffff00;}
                        .danger-box{background:rgba(100,0,0,0.3);border-left:4px solid #ff0000;}
                        .disclaimer-box{border:1px solid #ff3030;background:rgba(80,0,0,0.30);padding:0.9em 1em;border-radius:0.8em;box-shadow:0 0 6px rgba(255,0,0,0.25);}
                        .math-example,.formula{background:rgba(0,50,0,0.4);border:1px solid #00aa00;padding:0.9em 1em;border-radius:0.6em;margin:0.9em 0;}
                        .faq-collapsed{display:none;}
                        .faq-toggle-icon{float:right;font-size:0.85em;opacity:0.85;}
                        .faq-section-wrapper{padding-left:1em;}
                        /* Indent answer paragraphs directly following each question heading inside FAQ list */
                        .faq-section-wrapper h5 + p{margin-left:1.2em;padding-left:0.55em;border-left:2px solid rgba(0,255,0,0.25);}
                        .faq-section-wrapper p,.faq-section-wrapper li{font-size:1.05em;}
                        .faq-section-wrapper h2{font-size:1.6em;}
                        .faq-section-wrapper h3{font-size:1.4em;}
                        .faq-section-wrapper h4{font-size:1.25em;}
                        .faq-section-wrapper h5{font-size:1.12em;}
                        .faq-section-wrapper h6{font-size:1.0em;}
                        /* Matrix-style links inside FAQ content */
                        .faq-section-wrapper a{color:#00ff88;font-weight:700;text-decoration:none;}
                        .faq-section-wrapper a:hover,.faq-section-wrapper a:focus{color:#00ffaa;text-decoration:underline;}
                      `}</style>
                      {/* Anchor for Back-to-top links */}
                      <div id="faq-top" />
                      {(() => {
                        const order = [
                          'disclaimer',
                          'what',
                          'quickstart',
                          'glossary',
                          'success',
                          'fees',
                          'discount',
                          'logic',
                          'eol',
                          'faqs',
                          'factory',
                          'metamask',
                          'safety',
                          'security'
                        ];
                        const byOrder = (a,b) => order.indexOf(a.id) - order.indexOf(b.id);
                        const list = [...faqSections].sort(byOrder);
                        return list.map(sec => {
                        // Disclaimer: always visible, no collapse/expand UI
                        if (sec.id === 'disclaimer') {
                          return (
                            <div key={sec.id} style={{marginBottom:'0.9em'}} className="faq-section-wrapper">
                              <div className="faq-section-title" style={{cursor:'default'}}>
                                {sec.title}
                              </div>
                              <div style={{padding:'0.4em 0 0.6em 0.3em'}} dangerouslySetInnerHTML={{__html: sec.body}} />
                              <div style={{margin:'0.4em 0 0.6em 0.3em'}}>
                                <a href="#faq-top" style={{color:'#00ff88', fontSize:'0.85em', textDecoration:'none'}} onMouseEnter={(e)=>e.currentTarget.style.textDecoration='underline'} onMouseLeave={(e)=>e.currentTarget.style.textDecoration='none'}>Back to top ↑</a>
                              </div>
                            </div>
                          );
                        }
                        const open = !!faqOpen[sec.id];
                        return (
                          <div key={sec.id} style={{marginBottom:'0.6em'}} className="faq-section-wrapper">
                            <div className="faq-section-title" onClick={()=>toggleFaq(sec.id)}>
                              {sec.title}
                              <span className="faq-toggle-icon">[{open?'-':'+'}]</span>
                            </div>
                            <div className={open?'' : 'faq-collapsed'} style={{padding:'0.2em 0 0.4em 0.3em'}} dangerouslySetInnerHTML={{__html: sec.body}} />
                            {open && (
                              <div style={{margin:'0.4em 0 0.6em 0.3em'}}>
                                <a href="#faq-top" style={{color:'#00ff88', fontSize:'0.85em', textDecoration:'none'}} onMouseEnter={(e)=>e.currentTarget.style.textDecoration='underline'} onMouseLeave={(e)=>e.currentTarget.style.textDecoration='none'}>Back to top ↑</a>
                              </div>
                            )}
                          </div>
                        );
                        });
                      })()}
                      <div style={{marginTop:'1.5em',fontSize:'0.65em',opacity:0.55}}>End of FAQ</div>
                    </div>
                  </div>
        ) : currentToken.name === 'ALL' ? (
                  <div style={{width:'100%',display:'flex',flexDirection:'column',alignItems:'center',marginTop:'1.2em'}}>
                    <div style={{width:'95%',maxWidth:'1600px'}}>
          <div style={{marginBottom:'0.9em',display:'flex',justifyContent:'center'}}>
            {!account && (
              <button
                onClick={connectWallet}
                style={{
                  background:'#000',
                  border:'2px solid #00ff00',
                  borderRadius:'1em',
                  padding:'0.9em 2em',
                  fontSize:'1.0em',
                  fontWeight:'bold',
                  color:'#00ff00',
                  cursor:'pointer',
                  transition:'all 0.3s ease',
                  fontFamily:'monospace',
                  textTransform:'uppercase',
                  letterSpacing:'0.1em',
                  boxShadow:'none'
                }}
                onMouseEnter={(e)=>{e.currentTarget.style.transform='translateY(-2px)';e.currentTarget.style.boxShadow='0 8px 25px rgba(0,255,0,0.4)';e.currentTarget.style.background='rgba(0,255,0,0.1)';}}
                onMouseLeave={(e)=>{e.currentTarget.style.transform='translateY(0)';e.currentTarget.style.boxShadow='none';e.currentTarget.style.background='#000';}}
              >
                CONNECT Wallet
              </button>
            )}
          </div>
          <style>{`
            .token-grid{display:grid;grid-template-columns:1fr;gap:24px;padding:20px 0 96px 0;margin:0 auto;width:100%;}
            .token-card{background:rgba(255,255,255,0.05);backdrop-filter:blur(15px);border:1px solid rgba(255,255,255,0.1);border-radius:20px;padding:24px;position:relative;overflow:visible;width:95%;margin:0 auto;transition:all .3s cubic-bezier(.4,0,.2,1);}            
            .token-card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;background:var(--token-color,#666);opacity:.8;}
            .token-card:hover{transform:translateY(-5px);box-shadow:0 20px 40px rgba(0,0,0,0.3);border-color:rgba(255,255,255,0.3);}            
            .token-header{display:flex;align-items:flex-start;justify-content:space-between;gap:16px;margin-bottom:16px;width:100%;position:relative;}
            .vault-badge{position:absolute;left:50%;transform:translateX(-50%);top:-2px;background:rgba(0,255,0,0.08);border:1px solid rgba(0,255,0,0.35);color:#00ff88;padding:2px 6px;border-radius:8px;font-size:.80rem;font-weight:600;white-space:nowrap;box-shadow:0 2px 6px rgba(0,0,0,0.2);}            
            .token-name{font-size:1.5rem;font-weight:700;color:#00ff88;text-shadow:0 0 10px #00ff88;font-family:monospace;letter-spacing:0.05em;display:flex;align-items:center;gap:10px;}
            .claim-wrapper{display:flex;flex-direction:column;align-items:flex-end;gap:3px;}
            .claim-btn{background:#000;color:#00ff00;border:1.5px solid #00ff00;border-radius:.8em;padding:.35em 1.1em;font-size:.75rem;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,255,0,0.2);transition:background .2s,box-shadow .2s,transform .15s;}
            .claim-btn:hover:not(:disabled){background:rgba(0,255,0,0.10);} .claim-btn:active:not(:disabled){transform:translateY(1px);} .claim-btn:disabled{background:#111;color:#0f0;border:1.5px solid #0a0;opacity:.7;cursor:not-allowed;box-shadow:0 2px 8px #0008;}
            .claim-info{font-size:.55rem;color:#00ff00;opacity:.85;font-weight:500;letter-spacing:.5px;text-transform:uppercase;}
            .stats-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:12px;margin-bottom:20px;align-items:stretch;width:100%;}
            .stat-item{background:rgba(255,255,255,0.05);border-radius:12px;padding:12px;text-align:center;display:flex;flex-direction:column;justify-content:center;}
            .stat-label{font-size:.8rem;color:#b8b8b8;margin-bottom:4px;}
            .stat-value{font-size:1.2rem;font-weight:700;color:#fff;}
            .btn{padding:12px 16px;border:none;border-radius:12px;font-size:.9rem;font-weight:600;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center;gap:6px;text-transform:uppercase;letter-spacing:.5px;}
            .btn:disabled{opacity:.5;cursor:not-allowed;}
            .btn-primary{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;}
            .btn-primary:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 8px 25px rgba(102,126,234,0.4);}
            .btn-success{background:linear-gradient(135deg,#22c55e 0%,#16a34a 100%);color:#fff;}
            .btn-success:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 8px 25px rgba(34,197,94,0.4);}
            .btn-warning{background:linear-gradient(135deg,#f59e0b 0%,#d97706 100%);color:#fff;}
            .btn-warning:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 8px 25px rgba(245,158,11,0.4);}
            .progress-section{margin:16px 0;}
            .progress-label{font-size:.85rem;color:#b8b8b8;margin-bottom:8px;display:flex;justify-content:space-between;}
            .health-blocks{display:flex;gap:2px;height:6px;margin-top:4px;}
            .health-block{flex:1;background:#22c55e;opacity:1;border-radius:1px;transition:background .4s,opacity .4s;}
            .user-dashboard{background:rgba(0,0,0,0.2);border-radius:12px;padding:16px;margin-top:16px;}
            .dashboard-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;font-size:1rem;font-weight:600;}
            .claim-btn-mini{display:none;} /* replaced by full claim-wrapper */
          `}</style>
          {(() => {
            function AllTokenCard({token, originalIdx}){
              const cfg = token.config;
              const [displayName, setDisplayName] = React.useState(token.name);
              const isExtraMatrix = Boolean(cfg && token.matrixSize);
              // Create a regular page for this user matrix and navigate to it
              function openAsRegularPage(){
                try{
                  const existingIdx = tokens.findIndex(t => t.config && (t.config.vault||'').toLowerCase() === (cfg.vault||'').toLowerCase());
                  if (existingIdx >= 0) { setCarouselIdx(existingIdx); return; }
                }catch(e){ console.warn('openAsRegularPage failed', e); }
                setCarouselIdx(originalIdx);
              }
              const handleTitleClick = React.useCallback(() => { isExtraMatrix ? openAsRegularPage() : setCarouselIdx(originalIdx); }, [isExtraMatrix, originalIdx, displayName, cfg?.vault]);
              React.useEffect(()=>{
                let cancelled=false;
                async function run(){
                  const generic = !token.name || /^(?:newmatrix|token)/i.test(token.name.trim());
                  if(!generic) return; // keep provided name
                  const is4 = token.matrixSize === '4' || /4x4/i.test(token.name||'');
                  let symbol = null;
                  try {
                    const provider = window.ethereum ? new ethers.providers.Web3Provider(window.ethereum) : null;
                    if(provider && cfg?.token){
                      const code = await provider.getCode(cfg.token);
                      if(code && code !== '0x'){
                        const erc20 = new ethers.Contract(cfg.token, ["function symbol() view returns (string)"] , provider);
                        symbol = await erc20.symbol();
                      }
                    }
                  } catch {}
                  const name = (symbol ? symbol.toUpperCase() : 'TOKEN') + ' ' + (is4?'4x4':'3x3');
                  if(!cancelled) setDisplayName(name);
                }
                run();
                return ()=>{cancelled=true};
              },[token.name, token.matrixSize, cfg?.token]);
              // If ABI missing for this abiKey, render a minimal placeholder card so list still shows
              const hasAbi = cfg && cfg.abiKey && window.AllVaultABI && window.AllVaultABI[cfg.abiKey];
  if(!hasAbi){
                return <div className="token-card" style={{'--token-color': token.color || '#4ecdc4'}}>
                  <div className="token-header">
                    <div className="token-name">
    <span style={{cursor:'pointer'}} onClick={handleTitleClick}>{displayName}</span>
    {cfg?.token && (
      <span
        title={cfg.token}
        style={{
          fontSize: '.9rem',
          color: '#9f9',
          opacity: .9,
          fontFamily: 'monospace',
          padding: '2px 4px',
          borderRadius: '6px',
          background: 'rgba(0,255,0,0.06)'
        }}
      >{cfg.token.slice(0,6)}…{cfg.token.slice(-4)}</span>
    )}
                    </div>
                    <div className="vault-badge" title="Vault address">{cfg?.vault?.slice(0,6)}…{cfg?.vault?.slice(-4)}</div>
                  </div>
                  <div style={{fontSize:'.9rem',opacity:.8}}>Loading ABI…</div>
      {/* Click title to open as regular page */}
                </div>;
              }
              const [stats,setStats] = React.useState({entryFee:'…', payout:'…', vaultBalance:'…', totalOpenUnpaid:'…', openVP:'…', allowance:null, rawEntryFee:null, lastEntryTs:null, canJoin:true, eolActive:false, canTriggerEOL:false, userTokens:[]});
              const [loading,setLoading]=React.useState(false);
              const [approving,setApproving]=React.useState(false);
              const isPuMaToken = /puma/i.test(token.name);
              const [lastPuMaClaim,setLastPuMaClaim]=React.useState(()=>{ if(!account||!isPuMaToken) return 0; const t=localStorage.getItem(`lastPuMaClaim_${account.toLowerCase()}`); return t?parseInt(t,10):0; });
              const [nowTs,setNowTs]=React.useState(Date.now());
              React.useEffect(()=>{ if(!isPuMaToken) return; const id=setInterval(()=>setNowTs(Date.now()),1000); return ()=>clearInterval(id); },[isPuMaToken]);
              const COOLDOWN=3600_000; const msLeft=Math.max(0,(lastPuMaClaim+COOLDOWN)-nowTs); const canClaimPuMa = isPuMaToken && msLeft===0; const formatRemain=(ms)=>{const s=Math.floor(ms/1000);const m=Math.floor(s/60);const r=s%60;return `${m}m ${r}s`;};
              React.useEffect(()=>{ if(!account) return; let ignore=false; async function load(){ try{ const provider=new ethers.providers.Web3Provider(window.ethereum); const vault=new ethers.Contract(cfg.vault,window.AllVaultABI[cfg.abiKey],provider); const tokenC=new ethers.Contract(cfg.token,['function allowance(address,address)view returns(uint256)','function balanceOf(address) view returns (uint256)'],provider); const [entryFee,nextTokenId,eolActive, userTokens, allowance,lastEntryTs,payoutAmount, vaultBal] = await Promise.all([
                vault.ENTRY_FEE(),vault.nextTokenId(),vault.isEOLActive(),vault.getMyEntries(account),tokenC.allowance(account,cfg.vault),vault.lastEntryTimestamp(), vault.PAYOUT_AMOUNT ? vault.PAYOUT_AMOUNT(): Promise.resolve(ethers.BigNumber.from(0)), tokenC.balanceOf(cfg.vault)
              ]);
                const payout = payoutAmount && payoutAmount.gt(0)? payoutAmount: entryFee;
                const maxId = nextTokenId.toNumber()-1;
                // Determine cycle context for ACTIVE entries (matches History-card logic)
                let eolCycleCount=0; let postEOLVPId=1; let lastEOLTriggerEntry=0;
                try{ if(vault.EOLCycleCount) eolCycleCount=Number(await vault.EOLCycleCount()); }catch{}
                try{ if(vault.postEOLVPId){ const v=Number(await vault.postEOLVPId()); if(v>0) postEOLVPId=v; } }catch{}
                if(eolCycleCount>0 && vault.EOLTriggerAtEntryId){ try{ const trig=Number(await vault.EOLTriggerAtEntryId(eolCycleCount)); if(trig>0){ lastEOLTriggerEntry=trig; if(postEOLVPId===1) postEOLVPId=trig+1; } }catch{} }
                const totalEntriesMade = Math.max(0, maxId);
                const cycleStart = lastEOLTriggerEntry>0 ? lastEOLTriggerEntry+1 : 1;
                // OPEN VP progress (index-based within current cycle)
                const matrixSize = token.matrixSize ? parseInt(token.matrixSize,10) : (/3x3/i.test(token.name)?3:4);
                const structureSize = getVPStructureSize(matrixSize);
                const base = lastEOLTriggerEntry>0 ? lastEOLTriggerEntry : 0;
                const vp1Complete = isVPCompleteByIndex(1, totalEntriesMade, matrixSize, lastEOLTriggerEntry);
                // Find first open VP index (skip closed/paid)
                const startIndex = vp1Complete ? 2 : 1;
                let firstOpenIdx = null;
                {
                  let scan = startIndex; let guard = 0;
                  while (guard++ < 1000) {
                    const payPoint = getVPPaymentPointByIndex(scan, matrixSize, lastEOLTriggerEntry);
                    if (totalEntriesMade < payPoint) { firstOpenIdx = scan; break; }
                    scan++;
                  }
                }
                const baseline = (matrixSize === 4 ? 20 : 4);
                let openVPFill = 0;
                let activeWork = 0; // entries beyond baseline currently filling the active VP
                if (firstOpenIdx !== null) {
                  // Compute fill: before VP#1 pays use raw fill (baseline = 0), after uses prefilled+progress
                  if (!vp1Complete) {
                    openVPFill = computeVPFilledByIndex(firstOpenIdx, totalEntriesMade, matrixSize, lastEOLTriggerEntry);
                    activeWork = Math.max(0, openVPFill); // baseline is 0 before VP#1 completes
                  } else {
                    openVPFill = computePrefilledForLeaderIndex(firstOpenIdx, totalEntriesMade, lastEOLTriggerEntry, matrixSize);
                    openVPFill = Math.max(openVPFill, baseline); // enforce baseline visuals
                    activeWork = Math.max(0, openVPFill - baseline);
                  }
                } else {
                  openVPFill = 0; activeWork = 0;
                }
                const openVPDisplay = `${Math.min(openVPFill, structureSize)}/${structureSize}${openVPFill>=structureSize?' Filled':''}`;
                // Active Entries = (entries in current cycle) − (number of paid paypoints in cycle)
                // Example (3x3): s=13, spacing=9, total=25 => paid at 13 and 22 (2 paid) => 25 − 2 = 23
                const spacing = getPaySpacing(matrixSize);
                const s = structureSize;
                const cycleTotal = Math.max(0, totalEntriesMade - base); // entries since cycle start
                let paidCount = 0;
                if (cycleTotal >= s) {
                  paidCount = 1 + Math.floor((cycleTotal - s) / spacing);
                }
                const activeEntriesCount = Math.max(0, cycleTotal - paidCount);
                let canTriggerEOL=false; if(!eolActive){ try{ canTriggerEOL = await vault.canTriggerEOL(); }catch{} }
                if(!ignore) setStats({entryFee:ethers.utils.formatUnits(entryFee,cfg.decimals||18), payout:ethers.utils.formatUnits(payout,cfg.decimals||18), vaultBalance: ethers.utils.formatUnits(vaultBal,cfg.decimals||18), totalOpenUnpaid: String(activeEntriesCount), openVP:openVPDisplay, allowance, rawEntryFee:entryFee, lastEntryTs:lastEntryTs?Number(lastEntryTs.toString()):null, canJoin: !eolActive, eolActive, canTriggerEOL, userTokens: userTokens.map(x=>Number(x.toString()))});
              }catch(e){ console.error('ALL card load',token.name,e); }
              }
              load(); const id=setInterval(load,12000); return ()=>{ignore=true; clearInterval(id);} ;
            },[account,cfg,token.name,token.matrixSize]);
              async function handleTriggerEOL(){ if(!account) return; setLoading(true); try{ const provider=new ethers.providers.Web3Provider(window.ethereum); const signer=provider.getSigner(); const vault=new ethers.Contract(cfg.vault,window.AllVaultABI[cfg.abiKey],signer); const tx=await vault.triggerEOL(); await tx.wait(); setTxMsg('EOL triggered'); }catch(e){ console.error('triggerEOL',e); setTxMsg('EOL error'); } setLoading(false); }
              async function handleApprove(){
                if(!account||!stats.rawEntryFee) return; setApproving(true);
                try{
                  setFreezeSel(true);
                  // Pin URL hash to current page to keep selection stable through refreshes
                  try{ const slug = slugifyToken(tokens[carouselIdx].name); const desired = '#page='+slug; if(window.location.hash!==desired) history.replaceState(null,'',desired);}catch{}
                  const provider=new ethers.providers.Web3Provider(window.ethereum);
                  const signer=provider.getSigner();
                  // Prefer the token address declared by the vault on-chain; fallback to cfg.token if unavailable on this network
                  let actualToken = cfg.token;
                  try {
                    const readVault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);
                    const addr = await readVault.TOKEN();
                    const code = await provider.getCode(addr);
                    if (code && code !== '0x') actualToken = addr;
                  } catch {}
                  const tContract=new ethers.Contract(actualToken,["function approve(address,uint256) external returns (bool)"],signer);
                  const amt=stats.rawEntryFee.mul(ethers.BigNumber.from('10'));
                  const tx=await tContract.approve(cfg.vault,amt);
                  await tx.wait();
                  // Optimistically reflect allowance so JOIN unlocks immediately
                  try{ setStats(s=>({...s,allowance: amt})); }catch{}
                  // Backfill with an on-chain read (in case of non-standard decimals/rounding)
                  try{
                    const read=new ethers.providers.Web3Provider(window.ethereum); const tRead=new ethers.Contract(cfg.token,['function allowance(address,address) view returns(uint256)'],read); const allowance=await tRead.allowance(account,cfg.vault); setStats(s=>({...s,allowance}));
                  }catch{}
                }catch(e){ console.error('approve',e); }
                setApproving(false); setFreezeSel(false);
              }
              async function handleJoin(){
                if(!account) return; setLoading(true);
                try{
                  setFreezeSel(true);
                  // Pin URL hash to current page to keep selection stable through refreshes
                  try{ const slug = slugifyToken(tokens[carouselIdx].name); const desired = '#page='+slug; if(window.location.hash!==desired) history.replaceState(null,'',desired);}catch{}
                  const provider=new ethers.providers.Web3Provider(window.ethereum);
                  const signer=provider.getSigner();
                  const vault=new ethers.Contract(cfg.vault,window.AllVaultABI[cfg.abiKey],signer);
                  await vault.JOIN();
                }catch(e){ console.error('join',e);} setLoading(false); setFreezeSel(false);
              }
              async function handlePuMaClaim(){
                if(!canClaimPuMa) return;
                try{
                  const provider=new ethers.providers.Web3Provider(window.ethereum);
                  const signer=provider.getSigner();
                  const net=await provider.getNetwork();
                  const wanted = Number(window.__READ_CHAIN_ID || localStorage.getItem('READ_CHAIN_ID') || window.DEFAULT_CHAIN_ID || 943);
                  const name = wanted===369 ? 'PulseChain Mainnet' : 'PulseChain Testnet V4';
                  if (Number(net.chainId) !== wanted) {
                    alert(`Wrong network! Please switch to ${name} (Chain ID: ${wanted}). Currently on: ${net.chainId}`);
                    return;
                  }
                  const claimAbi=['function claim() public','function canClaim(address) view returns (bool)'];
                  const c=new ethers.Contract(cfg.token,claimAbi,signer);
                  try{ const ok=await c.canClaim(account); if(!ok) return; }catch{}
                  const tx=await c.claim(); await tx.wait();
                  const now=Date.now(); setLastPuMaClaim(now); localStorage.setItem(`lastPuMaClaim_${account.toLowerCase()}`,String(now));
                }catch(e){ console.error('puma claim',e);} }
              const hasAllowance = stats.allowance && stats.rawEntryFee ? stats.allowance.gte(stats.rawEntryFee): false; const nowSec=Math.floor(Date.now()/1000); const elapsedSec= stats.lastEntryTs? Math.max(nowSec-stats.lastEntryTs,0):0; const daysSince=Math.min(Math.floor(elapsedSec/86400),36);
              async function addTokenToMetaMask(){
                try {
                  if(!window.ethereum) return;
                  const tokenAddress = cfg.token;
                  let symbol = token.name.replace(/[^a-z0-9]/ig,'').slice(0,11) || 'TOKEN';
                  const decimals = cfg.decimals || 18;
                  const image = (typeof resolveTokenImage === 'function')
                    ? resolveTokenImage(symbol, token.name)
                    : (new URL(/puma/i.test(token.name) ? 'Pics/PuMa.png' : 'Pics/PLS.png', window.location.href).href);
                  await window.ethereum.request({ method:'wallet_watchAsset', params:{ type:'ERC20', options:{ address: tokenAddress, symbol, decimals, image }}});
                  setTxMsg(`Added ${symbol}`);
                } catch(e){ setTxMsg('Add token failed'); }
              }
              return <div className="token-card" style={{'--token-color': token.color || '#4ecdc4'}}>
        <div className="token-header">
                  <div className="token-name">
          <span style={{cursor:'pointer'}} onClick={handleTitleClick}>{displayName}</span>
                    <span
                      onClick={addTokenToMetaMask}
                      title={`Add token to MetaMask${cfg?.token ? ` (${cfg.token.slice(0,6)}…${cfg.token.slice(-4)})` : ''}`}
                      style={{cursor:'pointer',fontSize:'0.95rem',display:'inline-flex',alignItems:'center',padding:'2px 4px'}}>🦊</span>
          {cfg?.token && (
            <span
              title={cfg.token}
              style={{
                fontSize: '.9rem',
                color: '#9f9',
                opacity: .9,
                fontFamily: 'monospace',
                padding: '2px 4px',
                borderRadius: '6px',
                background: 'rgba(0,255,0,0.06)'
              }}
            >{cfg.token.slice(0,6)}…{cfg.token.slice(-4)}</span>
          )}
                  </div>
                  <div className="vault-badge" title="Vault balance">Vault: {stats.vaultBalance} {token.name.replace(/\s*(?:3x3|4x4|3×3|4×4)\b/gi,'').trim()}</div>
                  {isPuMaToken && (
                    <div className="claim-wrapper">
                      <button className="claim-btn" onClick={handlePuMaClaim} disabled={!canClaimPuMa}>free claim</button>
                      <span className="claim-info">{canClaimPuMa? '1x / hour': formatRemain(msLeft)}</span>
                    </div>
                  )}
                </div>
                <div className="stats-grid">
                  <div className="stat-item"><div className="stat-label">Entry Fee</div><div className="stat-value">{stats.entryFee}</div></div>
                  <div className="stat-item"><div className="stat-label">Payout</div><div className="stat-value">{stats.payout}</div></div>
                  <div className="stat-item"><div className="stat-label">Active Entries</div><div className="stat-value">{stats.totalOpenUnpaid}</div></div>
                  <div className="stat-item"><div className="stat-label">Open VP</div><div className="stat-value">{stats.openVP}</div></div>
                  <div className="stat-item" style={{display:'flex',flexDirection:'column',justifyContent:'space-between',padding:'10px'}}>
                    <button className="btn btn-primary" disabled={approving||hasAllowance||!stats.rawEntryFee} onClick={handleApprove} style={{marginBottom:'8px',width:'100%',fontSize:'.7rem',padding:'8px 10px',lineHeight:1, ...(hasAllowance?{opacity:.55}:{})}}>{approving? <span>Approving…</span> : (hasAllowance? '✅ Approved':'🔐 Approve')}</button>
                    <button className="btn btn-success" disabled={!hasAllowance||loading||!stats.canJoin} onClick={handleJoin} style={{width:'100%',fontSize:'.7rem',padding:'8px 10px',lineHeight:1}}>{loading? <span>Joining…</span>:'⚡ Join'}</button>
                  </div>
                </div>
                {stats.canTriggerEOL && <button onClick={handleTriggerEOL} disabled={loading||approving} style={{marginTop:'10px',width:'100%',background:'#332800',border:'1px solid #ffcc55',color:'#ffcc55',padding:'6px 8px',borderRadius:'8px',fontSize:'.65rem',cursor: (loading||approving)?'not-allowed':'pointer'}}>{loading? 'Triggering...':'🪠 Trigger EOL'}</button>}
                <div className="progress-section">
                  <div className="progress-label"><span>VP Health</span><span>{daysSince}d</span></div>
                  <div className="health-blocks">{Array.from({length:37}).map((_,i)=>{
                    // 3-color segmentation for clearer aging: green | orange(3-day band) | red tail
                    const d = Math.max(0, Math.min(36, Number(daysSince||0)));
                    const total = 37;
                    const redLen = Math.max(0, d - 3);
                    const orangeLen = Math.min(3, d);
                    const redStart = total - redLen;        // index where red zone starts
                    const orangeStart = redStart - orangeLen; // index where orange zone starts
                    let bg = 'hsl(120,80%,45%)'; // green
                    if (i >= redStart) bg = '#ff3b30';
                    else if (i >= orangeStart) bg = '#ffa500';
                    return <div key={i} className="health-block" style={{background:bg}} />;
                  })}</div>
                  <div style={{display:'flex',justifyContent:'space-between',fontSize:'.55rem',marginTop:'4px',opacity:.6}}><span>0d</span><span>18d</span><span>36d</span></div>
                </div>
                {stats.userTokens.length>0 && (
                  <div className="user-dashboard" style={{background:'rgba(0,0,0,0.2)',padding:'12px 14px',borderRadius:'12px'}}>
                    <div className="dashboard-header" style={{cursor:'default',marginBottom:0}}>
                      <span style={{fontSize:'.9rem',fontWeight:600}}>My Positions: {stats.userTokens.map(t=>`#${t}`).join(', ')}</span>
                    </div>
                  </div>
                )}
        {/* Click title to open as regular page with full cards */}
              </div>;
            }
      // Expanded panel removed; now opening as full regular page
            // Build directly from carousel tokens (already de-duplicated by vault)
            const allIdx = tokens.findIndex(t => t.name === 'ALL');
            // Global one-time hashchange guard (installed once) to avoid glitching back to a bookmarked page while ALL view is open
            try {
              if (!window.__HASH_GUARD_INSTALLED) {
                window.__HASH_GUARD_INSTALLED = true;
                window.addEventListener('hashchange', function(){
                  try {
                    const allRoot = document.getElementById('all-view-root');
                    if (!allRoot) return; // Only guard while ALL is actually mounted
                    if (window.__ALLOW_HASH_NAV) { window.__ALLOW_HASH_NAV = false; return; }
                    const slug = (typeof slugifyToken === 'function') ? slugifyToken('ALL') : 'all';
                    const desired = '#page=' + slug;
                    if (window.location.hash !== desired) {
                      history.replaceState(null, '', desired);
                    }
                  } catch {}
                }, true);
              }
            } catch {}
            // Nudge hash to #page=all without hooks to reduce bookmark-snap glitches
            try {
              const slug = (typeof slugifyToken === 'function') ? slugifyToken('ALL') : 'all';
              const desired = '#page=' + slug;
              if (window.location && window.location.hash !== desired) {
                setTimeout(() => { try { if (window.location.hash !== desired) history.replaceState(null, '', desired); } catch {} }, 0);
              }
            } catch {}
            function baseSym(name){ return String(name||'').replace(/\s*(?:3x3|4x4|3×3|4×4)\b/gi,'').trim().toUpperCase(); }
            const order = ['PUMA','PLS','PLSX','INC','PHEX','EHEX','PDAI'];
            let list = tokens
              .map((t,i)=> t.matrixSize ? ({token:t, originalIdx:i}) : null)
              .filter(Boolean);
            try {
              const fq = String(window.__ALLFilterQuery || '').trim().toLowerCase();
              if (fq) {
                list = list.filter(({token}) => {
                  const n = String(token.name||'').toLowerCase();
                  const v = String(token.config?.vault||'').toLowerCase();
                  const tok = String(token.config?.token||'').toLowerCase();
                  return n.includes(fq) || v.includes(fq) || tok.includes(fq);
                });
              }
            } catch {}
            // Kick off background fetch of lastEntryTimestamp for Health sorting
            try {
              const cache = (window.__LastEntryCache = window.__LastEntryCache || {});
              const providers = [];
              if (window.ethereum) { try { providers.push({ prov: new ethers.providers.Web3Provider(window.ethereum), name: 'Wallet' }); } catch {} }
              // Single provider for selected read network
              try {
                const wanted = Number(window.__READ_CHAIN_ID || localStorage.getItem('READ_CHAIN_ID') || 943);
                const url = (window.PULSE_RPC && window.PULSE_RPC[wanted]) || (wanted===369 ? 'https://rpc.pulsechain.com' : 'https://rpc.v4.testnet.pulsechain.com');
                const name = wanted===369 ? 'PulseChain Mainnet' : 'PulseChain Testnet v4';
                providers.push({ prov: new ethers.providers.JsonRpcProvider(url), name });
              } catch {}
              async function fetchLastEntryTs(cfg){
                if (!cfg || !cfg.vault || !cfg.abiKey || !window.AllVaultABI || !window.AllVaultABI[cfg.abiKey]) return null;
                const abi = window.AllVaultABI[cfg.abiKey];
                for (const p of providers) {
                  try {
                    const code = await p.prov.getCode(cfg.vault);
                    if (code && code !== '0x') {
                      const v = new ethers.Contract(cfg.vault, abi, p.prov);
                      const ts = await v.lastEntryTimestamp();
                      return Number(ts);
                    }
                  } catch {}
                }
                return null;
              }
              (async () => {
                // Limit concurrent loads to avoid flooding
                let started = 0;
                for (const {token} of list) {
                  const cfg = token.config;
                  const key = cfg && cfg.vault;
                  if (!key) continue;
                  if (cache[key] == null && started < 6) {
                    started++;
                    fetchLastEntryTs(cfg).then(ts => {
                      if (ts != null) { try { cache[key] = ts; } catch {} }
                      try { setRefreshStats(x=>x+1); } catch {}
                    });
                  }
                }
              })();
            } catch {}

            // Sorting logic with optional user-selected mode
            const sortPref = (window.__ALLSort || {});
            const matrixTokens = list.sort((a,b)=>{
              const aSym = baseSym(a.token.name), bSym = baseSym(b.token.name);
              const aCore = order.includes(aSym), bCore = order.includes(bSym);
              // Default/core priority remains unless explicit sort overrides it
              function byDefault(){
                if (aCore && !bCore) return -1; if (!aCore && bCore) return 1;
                if (aCore && bCore) {
                  const ai = order.indexOf(aSym), bi = order.indexOf(bSym);
                  if (ai !== bi) return ai - bi;
                  const as = /3x3/i.test(a.token.name) ? 3 : 4;
                  const bs = /3x3/i.test(b.token.name) ? 3 : 4;
                  if (as !== bs) return as - bs;
                }
                const by = aSym.localeCompare(bSym);
                if (by !== 0) return by;
                const as = a.token.matrixSize === '3' ? 3 : 4;
                const bs = b.token.matrixSize === '3' ? 3 : 4;
                return as - bs;
              }
              function byAbc(dir){
                const cmp = aSym.localeCompare(bSym);
                if (cmp !== 0) return dir==='desc' ? -cmp : cmp;
                const as = a.token.matrixSize === '3' ? 3 : 4;
                const bs = b.token.matrixSize === '3' ? 3 : 4;
                return as - bs;
              }
              function byHealth(dir){
                const cache = window.__LastEntryCache || {};
                const aTs = cache[(a.token.config||{}).vault] || 0;
                const bTs = cache[(b.token.config||{}).vault] || 0;
                if (aTs !== bTs) return dir==='asc' ? (aTs - bTs) : (bTs - aTs); // asc=oldest first, desc=newest first
                // tie-break by symbol
                return aSym.localeCompare(bSym);
              }
              if (sortPref.mode === 'abc') return byAbc(sortPref.dir||'asc');
              if (sortPref.mode === 'health') return byHealth(sortPref.dir||'desc');
              return byDefault();
            });
            return <>
              {/* Sorting toolbar moved into header; hide standalone instance */}
              {(() => { return null; })()}
              {(() => {
                const fq = String(window.__ALLFilterQuery || '').trim();
                if (!fq) return null;
                return (
                  <div style={{display:'flex',justifyContent:'center',alignItems:'center',gap:'8px',margin:'6px 0 2px 0'}}>
                    <div style={{color:'#9f9',fontFamily:'monospace',fontSize:'0.85rem'}}>Filter: “{fq}”</div>
                    <button onClick={(e)=>{ try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{}; try{ window.__ALLFilterQuery=''; }catch{}; try { setRefreshStats(x=>x+1); } catch {} }} className="btn btn-warning" style={{padding:'6px 10px',fontSize:'.7rem'}}>Clear</button>
                  </div>
                );
              })()}

              {(() => {
                // Persisted ALL view mode: 'cards' or 'table' (avoid hooks here; use localStorage + refresh bump)
                const getAllViewMode = () => { try { return localStorage.getItem('allViewMode') || 'cards'; } catch { return 'cards'; } };
                const allViewMode = getAllViewMode();
                const setAllViewMode = (m) => { try { localStorage.setItem('allViewMode', m); } catch {} try { setRefreshStats(x=>x+1); } catch {} };

                // Lightweight row component for the table view
                const AllTokenRow = ({ token, originalIdx }) => {
                  const cfg = token.config || {};
                  const [row, setRow] = React.useState({
                    entryFee: null,
                    payout: null,
                    decimals: cfg.decimals || 18,
                    allowance: null,
                    approved: false,
                    vaultBalance: null,
                    activeEntries: null,
                    openVPs: null,
                    healthPct: 0
                  });

                  React.useEffect(() => {
                    let ignore = false;
                    (async () => {
                      try {
                        if (!cfg?.vault || !cfg?.token || !cfg?.abiKey) return;
                        const wanted = Number(window.__READ_CHAIN_ID || 943);
                        const RPC = wanted===369? 'https://rpc.pulsechain.com' : (wanted===943? 'https://rpc.v4.testnet.pulsechain.com' : '');
                        const provider = RPC ? new ethers.providers.JsonRpcProvider(RPC) : (window.ethereum ? new ethers.providers.Web3Provider(window.ethereum) : null);
                        if (!provider) return;
                        const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);
                        const erc20 = new ethers.Contract(cfg.token, [
                          'function decimals() view returns(uint8)',
                          'function balanceOf(address) view returns(uint256)',
                          'function allowance(address,address) view returns(uint256)'
                        ], provider);

                        const [decimals, entryFeeBN, payoutBN, vBalBN] = await Promise.all([
                          erc20.decimals().catch(()=> cfg.decimals || 18),
                          vault.ENTRY_FEE().catch(()=> null),
                          vault.PAYOUT_AMOUNT().catch(()=> null),
                          erc20.balanceOf(cfg.vault).catch(()=> null)
                        ]);

                        // Basic cycle/openVP snapshot
                        let nextId = null, cycleCount = 0, lastTrig = 0;
                        try { nextId = await vault.nextTokenId(); } catch {}
                        try { cycleCount = Number(await vault.EOLCycleCount()); } catch {}
                        if (cycleCount > 0) {
                          try { lastTrig = Number(await vault.EOLTriggerAtEntryId(cycleCount)); } catch {}
                        }
                        const matrixSize = token.matrixSize ? parseInt(token.matrixSize, 10) : (/3x3/i.test(token.name) ? 3 : 4);
                        const structureSize = (matrixSize === 4 ? 20 : 4) + (matrixSize === 4 ? 0 : 9); // fallback if helpers missing
                        // Prefer existing helpers when present
                        const getStruct = (typeof getVPStructureSize === 'function') ? getVPStructureSize : (() => (matrixSize===4?21:13));
                        const getPayPoint = (typeof getVPPaymentPointByIndex === 'function') ? getVPPaymentPointByIndex : null;
                        const prefFilled = (typeof computePrefilledForLeaderIndex === 'function') ? computePrefilledForLeaderIndex : null;
                        const filledByIdx = (typeof computeVPFilledByIndex === 'function') ? computeVPFilledByIndex : null;
                        const isVPComplete = (typeof isVPCompleteByIndex === 'function') ? isVPCompleteByIndex : null;

                        const totalEntriesMade = Math.max(0, (nextId ? Number(nextId) - 1 : 0));
                        const base = lastTrig > 0 ? lastTrig : 0;
                        const entriesInCycle = Math.max(0, totalEntriesMade - base);
                        const sSize = getStruct ? getStruct(matrixSize) : structureSize;
                        const vp1Done = isVPComplete ? isVPComplete(1, totalEntriesMade, matrixSize, lastTrig) : (totalEntriesMade >= (getPayPoint ? getPayPoint(1, matrixSize, lastTrig) : sSize));
                        const windowLen = vp1Done ? (matrixSize === 4 ? 4 : 3) : 1;
                        let firstOpenIdx = null;
                        if (getPayPoint) {
                          let scan = vp1Done ? 2 : 1; let guard = 0;
                          while (guard++ < 200) {
                            const payPoint = getPayPoint(scan, matrixSize, lastTrig);
                            if (totalEntriesMade < payPoint) { firstOpenIdx = scan; break; }
                            scan++;
                          }
                        }
                        let healthPct = 0;
                        let openDisplay = '—';
                        // Count current open VPs (matches card window rules)
                        let openCount = 0;
                        if (getPayPoint) {
                          let scan2 = vp1Done ? 2 : 1; let guard2 = 0;
                          while (openCount < windowLen && guard2++ < 500) {
                            const pp = getPayPoint(scan2, matrixSize, lastTrig);
                            const isClosed = totalEntriesMade >= pp;
                            if (!isClosed) openCount++;
                            scan2++;
                          }
                        } else {
                          openCount = windowLen; // fallback if paypoint helper missing
                        }
                        if (firstOpenIdx !== null) {
                          let fill = 0; const baseline = (matrixSize === 4 ? 20 : 4);
                          if (!vp1Done) {
                            fill = filledByIdx ? filledByIdx(firstOpenIdx, totalEntriesMade, matrixSize, lastTrig) : 0;
                          } else {
                            fill = prefFilled ? prefFilled(firstOpenIdx, totalEntriesMade, lastTrig, matrixSize) : baseline;
                            fill = Math.max(fill, baseline);
                          }
                          healthPct = Math.max(0, Math.min(100, Math.round((Math.min(fill, sSize) / sSize) * 100)));
                          // Show only the currently filling VP as X/Size
                          try {
                            openDisplay = `${Math.min(fill, sSize)}/${sSize}`;
                          } catch {}
                        }

                        // Active entries = entries in cycle minus number of paid paypoints
                        let activeEntries = null;
                        try {
                          const getSpacing = (typeof getPaySpacing === 'function') ? getPaySpacing : null;
                          if (getSpacing && sSize) {
                            const spacing = getSpacing(matrixSize);
                            let paid = 0;
                            if (entriesInCycle >= sSize) {
                              paid = 1 + Math.floor(Math.max(0, entriesInCycle - sSize) / Math.max(1, spacing));
                            }
                            activeEntries = Math.max(0, entriesInCycle - paid);
                          }
                        } catch {}

                        // Days since last entry (for health color aging)
                        let ageDays = 0;
                        try {
                          const cacheTs = (window.__LastEntryCache || {})[cfg.vault];
                          if (cacheTs) {
                            const nowSec = Math.floor(Date.now()/1000);
                            const elapsed = Math.max(0, nowSec - Number(cacheTs));
                            ageDays = Math.min(36, Math.floor(elapsed / 86400));
                          }
                        } catch {}

                        // Allowance check only if account is known
                        let allowance = null, approved = false;
                        if (account) {
                          try {
                            allowance = await erc20.allowance(account, cfg.vault);
                            approved = entryFeeBN ? allowance.gte(entryFeeBN) : allowance && !allowance.isZero();
                          } catch {}
                        }

                        if (!ignore) setRow({
                          entryFee: entryFeeBN,
                          payout: payoutBN,
                          decimals,
                          allowance,
                          approved,
                          vaultBalance: vBalBN,
                          activeEntries: (activeEntries===null? '—' : activeEntries),
                          openVPs: openDisplay,
                          healthPct,
                          ageDays
                        });
                      } catch {}
                    })();
                    return () => { ignore = true; };
                  }, [account, cfg?.vault, cfg?.token, cfg?.abiKey]);

                  // Inline handlers (approve/join) for this row
                  const [busy, setBusy] = React.useState(false);
                  const approveIndicator = row.approved ? '💚' : '❤️';

                  async function handleRowApprove() {
                    if (!window.ethereum || !cfg?.vault) return;
                    try {
                      setBusy(true);
                      const provider = new ethers.providers.Web3Provider(window.ethereum);
                      const signer = provider.getSigner();
                      const network = await provider.getNetwork();
                      const wanted = Number(window.__READ_CHAIN_ID || 943);
                      if (Number(network.chainId) !== wanted) { alert(`Switch to ${wanted===943?'PulseChain Testnet V4': wanted===369?'PulseChain Mainnet':('Chain '+wanted)}`); return; }
                      const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], signer);
                      // Resolve token dynamically when possible
                      let actualToken = cfg.token;
                      try { if (typeof vault.TOKEN === 'function') { const t = await vault.TOKEN(); if (t) actualToken = t; } } catch {}
                      const vCode = await provider.getCode(cfg.vault);
                      const tCode = actualToken ? await provider.getCode(actualToken) : '0x';
                      if (vCode === '0x' || tCode === '0x') { alert('Vault or Token not deployed on this network.'); return; }
                      const token = new ethers.Contract(actualToken, ['function approve(address,uint256) returns (bool)'], signer);
                      const toApprove = row.entryFee ? row.entryFee.mul(ethers.BigNumber.from('10')) : ethers.utils.parseUnits('1000', row.decimals || 18);
                      const tx = await token.approve(cfg.vault, toApprove);
                      await tx.wait();
                    } catch (e) {
                      // swallow for slim UI
                    } finally { setBusy(false); try { setRefreshStats(x=>x+1); } catch {} }
                  }

                  async function handleRowJoin() {
                    if (!window.ethereum || !cfg?.vault) return;
                    try {
                      setBusy(true);
                      const provider = new ethers.providers.Web3Provider(window.ethereum);
                      const signer = provider.getSigner();
                      const network = await provider.getNetwork();
                      const wanted = Number(window.__READ_CHAIN_ID || 943);
                      if (Number(network.chainId) !== wanted) { alert(`Switch to ${wanted===943?'PulseChain Testnet V4': wanted===369?'PulseChain Mainnet':('Chain '+wanted)}`); return; }
                      const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], signer);
                      try { if (vault.callStatic && vault.callStatic.JOIN) { await vault.callStatic.JOIN(); } } catch (pre) { alert('Cannot join right now.'); return; }
                      const tx = await vault.JOIN();
                      await tx.wait();
                    } catch (e) {
                    } finally { setBusy(false); try { setRefreshStats(x=>x+1); } catch {} }
                  }

                  // Render row
                  const short = (addr) => addr ? (addr.slice(0,6)+'…'+addr.slice(-4)) : '—';
                  const fmt = (bn, dec=row.decimals) => bn ? ((()=>{ try { return ethers.utils.formatUnits(bn, dec); } catch { return '—'; } })()) : '—';
                  return (
                    <>
                      <tr style={{fontSize:'.9rem'}}>
                        <td
                          style={{padding:'8px 10px', cursor:'pointer', textDecoration:'none', color:'#9f9'}}
                          title="Open token page"
                          onClick={() => { try { setCarouselIdx(originalIdx); } catch {} try { const slug = typeof slugifyToken==='function'? slugifyToken(token.name):null; if (slug) { try { window.__ALLOW_HASH_NAV = true; } catch {} history.replaceState(null,'','#page='+slug); setTimeout(()=>{ try { window.__ALLOW_HASH_NAV = false; } catch {} }, 250); } } catch {} }}
                        >
                          {token.name}
                          <span
                            onClick={(e)=>{ try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{}; try { addTokenToMetaMask(cfg); } catch {} }}
                            title={'Add token to MetaMask' + (cfg?.token ? ' ('+cfg.token.slice(0,6)+'…'+cfg.token.slice(-4)+')' : '')}
                            style={{cursor:'pointer', display:'inline', marginLeft:'6px'}}
                          >🦊</span>
                        </td>
                        <td style={{padding:'8px 10px', fontFamily:'monospace'}}>{short(cfg.token)}</td>
                        <td style={{padding:'8px 10px', textAlign:'right'}}>{fmt(row.entryFee)}</td>
                        <td style={{padding:'8px 10px', textAlign:'right'}}>{fmt(row.payout)}</td>
                        <td style={{padding:'8px 10px', textAlign:'center'}}>{row.activeEntries ?? '—'}</td>
                        <td style={{padding:'8px 10px', textAlign:'center'}}>{row.openVPs ?? '—'}</td>
                        <td style={{padding:'8px 10px', textAlign:'center'}}>
                          {(() => {
                            const smallBtn = {
                              width: '28px',
                              height: '24px',
                              display: 'inline-flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              background: '#000',
                              color: '#00ff00',
                              border: '1.5px solid #00ff00',
                              borderRadius: '10px',
                              fontWeight: 700,
                              letterSpacing: '0.03em',
                              cursor: (busy || row.approved || !account) ? 'not-allowed' : 'pointer',
                              boxShadow: '0 6px 18px rgba(0,255,0,0.18)',
                              fontSize: '0.9rem',
                              opacity: (busy || (!account)) ? 0.6 : 1
                            };
                            const emoji = row.approved ? '💚' : '❤️';
                            return (
                              <button
                                title={row.approved ? 'Approved' : (account ? 'Approve' : 'Connect wallet to approve')}
                                onClick={(e) => { try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{}; if (!row.approved && account && !busy) handleRowApprove(); }}
                                disabled={busy || row.approved || !account}
                                style={smallBtn}
                              >{emoji}</button>
                            );
                          })()}
                        </td>
                        <td style={{padding:'8px 10px', textAlign:'center'}}>
                          {(() => {
                            const btnStyle = {
                              padding: '4px 10px',
                              fontSize: '.85rem',
                              background: '#000',
                              color: '#00ff00',
                              border: '1.5px solid #00ff00',
                              borderRadius: '10px',
                              fontWeight: 700,
                              letterSpacing: '0.03em',
                              textTransform: 'uppercase',
                              cursor: (!row.approved || busy) ? 'not-allowed' : 'pointer',
                              boxShadow: '0 6px 18px rgba(0,255,0,0.18)',
                              opacity: (!row.approved || busy) ? .5 : 1
                            };
                            return (
                              <button onClick={(e)=>{ try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{}; handleRowJoin(); }} disabled={!row.approved||busy} title="Join" style={btnStyle}>ENTER</button>
                            );
                          })()}
                        </td>
                        <td style={{padding:'8px 10px', textAlign:'right'}}>{fmt(row.vaultBalance)}</td>
                      </tr>
                      <tr>
                        <td colSpan={9} style={{padding:'0 10px 6px 10px'}}>
                          {(() => {
                            // 3-color segmented bar (2px tall): green | orange (3-day band) | red tail
                            const d = Math.max(0, Math.min(36, Number(row.ageDays || 0)));
                            const total = 37;
                            const redLen = Math.max(0, d - 3);
                            const orangeLen = Math.min(3, d);
                            const redStart = total - redLen;
                            const orangeStart = redStart - orangeLen;
                            const blocks = Array.from({ length: total });
                            return (
                              <div style={{ display:'flex', gap:'2px', alignItems:'center', height:'2px' }}>
                                {blocks.map((_, i) => {
                                  let bg = 'hsl(120, 80%, 45%)'; // green
                                  if (i >= redStart) bg = '#ff3b30'; // red
                                  else if (i >= orangeStart) bg = '#ffa500'; // orange
                                  return <div key={i} style={{ flex: 1, height: '100%', background: bg, borderRadius: '1px' }} />
                                })}
                              </div>
                            );
                          })()}
                        </td>
                      </tr>
                    </>
                  );
                };

                // Toggle header with icons
                return (
                  <div>
                    <div style={{position:'relative',display:'flex',alignItems:'center',justifyContent:'space-between',margin:'8px 0 12px 0'}}>
                      {/* Left: label */}
                      <div style={{color:'#9f9',fontFamily:'monospace',fontSize:'.85rem',whiteSpace:'nowrap'}}>ALL matrices</div>

                      {/* Center: sort toolbar (absolutely centered) */}
                      {(() => {
                        const pref = (window.__ALLSort || {});
                        const isAbc = pref.mode==='abc';
                        const abcAsc = !isAbc ? true : (pref.dir!=='desc');
                        const isHealth = pref.mode==='health';
                        const healthDesc = !isHealth ? true : (pref.dir!=='asc');
                        const btnStyle = {
                          padding: '6px 10px',
                          fontSize: '.72rem',
                          background: '#000',
                          color: '#00ff00',
                          border: '1.5px solid #00ff00',
                          borderRadius: '10px',
                          fontWeight: 700,
                          letterSpacing: '0.03em',
                          textTransform: 'uppercase',
                          cursor: 'pointer',
                          boxShadow: '0 6px 18px rgba(0,255,0,0.18)',
                          lineHeight: 1.2,
                          whiteSpace:'nowrap'
                        };
                        const activeStyle = (active)=> active? { boxShadow:'0 0 12px rgba(0,255,0,0.5), 0 0 0 2px rgba(0,255,0,0.35), 0 6px 18px rgba(0,255,0,0.18)' } : {};
                        return (
                          <div style={{position:'absolute',left:'50%',transform:'translateX(-50%)',display:'inline-flex',alignItems:'center',gap:'8px',whiteSpace:'nowrap'}}>
                            <div style={{color:'#9f9',fontFamily:'monospace',fontSize:'0.85rem',whiteSpace:'nowrap'}}>Sort by:</div>
                            <button
                              style={{...btnStyle, ...activeStyle(isAbc)}}
                              title="Toggle A→Z / Z→A"
                              onClick={(e)=>{ try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{};
                                try { if (pref.mode !== 'abc') window.__ALLSort = { mode:'abc', dir:'asc' }; else window.__ALLSort = { mode:'abc', dir: (pref.dir==='desc' ? 'asc' : 'desc') }; } catch {}
                                try { setRefreshStats(x=>x+1); } catch {} }}
                            >{abcAsc ? '▲ ABC ▼' : '▼ CBA ▲'}</button>
                            <button
                              style={{...btnStyle, ...activeStyle(isHealth)}}
                              title="Toggle newest first / oldest first"
                              onClick={(e)=>{ try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{};
                                try { if (pref.mode !== 'health') window.__ALLSort = { mode:'health', dir:'desc' }; else window.__ALLSort = { mode:'health', dir: (pref.dir==='desc' ? 'asc' : 'desc') }; } catch {}
                                try { setRefreshStats(x=>x+1); } catch {} }}
                            >{healthDesc ? '💚 HEALTH 🧡' : '🧡 HEALTH 💚'}</button>
                            <span
                              role="button" aria-label="Clear sort" title="Clear sort (default order)"
                              style={{cursor:'pointer', userSelect:'none', fontSize:'1.0rem', lineHeight:1, padding:'2px 4px'}}
                              onClick={(e)=>{ try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{}; try { delete window.__ALLSort; } catch {}; try { setRefreshStats(x=>x+1); } catch {} }}
                            >🚫</span>
                          </div>
                        );
                      })()}

                      {/* Right: view toggle icons */}
                      <div style={{display:'inline-flex',gap:'10px',alignItems:'center'}}>
                        {(() => {
                          // Plain clickable pics; force no borders/outlines/shadows/filters/radius/background
                          const baseImg = {
                            cursor:'pointer', width:'25px', height:'25px',
                            border:'none', outline:'none', boxShadow:'none', filter:'none',
                            borderRadius: 0, background:'transparent', padding: 0, margin: 0,
                            WebkitTapHighlightColor: 'transparent', display:'inline-block'
                          };
                          return (
                            <>
            <img src="Pics/card.png" alt="Cards" title="Cards"
              data-no-nav
              onClick={(e)=>{ try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{}; try{ const slug = (typeof slugifyToken==='function')? slugifyToken('ALL') : 'all'; history.replaceState(null,'','#page='+slug); }catch{}; try { window.__ALLOW_HASH_NAV = false; } catch {}; setAllViewMode('cards'); }}
              style={baseImg} />
            <img src="Pics/table.png" alt="Table" title="Table"
              data-no-nav
              onClick={(e)=>{ try{ e.preventDefault && e.preventDefault(); e.stopPropagation && e.stopPropagation(); }catch{}; try{ const slug = (typeof slugifyToken==='function')? slugifyToken('ALL') : 'all'; history.replaceState(null,'','#page='+slug); }catch{}; try { window.__ALLOW_HASH_NAV = false; } catch {}; setAllViewMode('table'); }}
              style={baseImg} />
                            </>
                          );
                        })()}
                      </div>
                    </div>

                    {allViewMode === 'cards' ? (
                      <div className="token-grid">{matrixTokens.map(({token,originalIdx})=> <AllTokenCard key={(token.config?.vault||'')+token.name} token={token} originalIdx={originalIdx} />)}</div>
                    ) : (
                      <div style={{overflowX:'auto'}}>
        <table style={{width:'100%', borderCollapse:'collapse', fontSize:'.92rem'}}>
                          <thead>
                            <tr style={{textAlign:'left', borderBottom:'1px solid rgba(255,255,255,0.1)'}}>
                              <th style={{padding:'6px 10px'}}>Token</th>
                              <th style={{padding:'6px 10px'}}>Token Address</th>
          <th style={{padding:'6px 10px', textAlign:'right'}}>Entry Fee</th>
          <th style={{padding:'6px 10px', textAlign:'right'}}>Payout</th>
          <th style={{padding:'6px 10px', textAlign:'center'}}>Active Entries</th>
          <th style={{padding:'6px 10px', textAlign:'center'}}>openVP</th>
          <th style={{padding:'6px 10px', textAlign:'center'}}>Approve(d)</th>
          <th style={{padding:'6px 10px', textAlign:'center'}}>Join</th>
          <th style={{padding:'6px 10px', textAlign:'right'}}>Vault Balance</th>
                            </tr>
                          </thead>
                          <tbody>
                            {matrixTokens.map(({token, originalIdx}) => (
                              <AllTokenRow key={(token.config?.vault||'')+token.name} token={token} originalIdx={originalIdx} />
                            ))}
                          </tbody>
                        </table>
                      </div>
                    )}
                  </div>
                );
              })()}
            </>;
          })()}
                    </div>
                  </div>
                ) : isMatrixToken ? (
                  account ? (
                    <>
                    <div className="INFO-card" style={{width:'65%', marginLeft:'auto', marginRight:'auto'}}>
                      {/* Use vaultData for live contract values, fallback to vaultStats if unavailable */}
                      {/* Decimal-align values; left-align labels; right-align token name */}
                      <div className="INFO-metrics" style={{marginLeft:0, padding:'0 1.2em', maxWidth:'100%', boxSizing:'border-box'}}>
                        {(() => {
                          const name = tokens[carouselIdx].name;
                          const decs = (vaultData && (vaultData.decimals || vaultData.DECIMALS)) || (tokens[carouselIdx].config?.decimals) || 18;
                          const toFixedPlaces = 2; // display precision
                          const fmtUnitsOr = (bn, fallbackStr) => {
                            try {
                              if (bn && ethers.BigNumber.isBigNumber(bn)) {
                                const v = parseFloat(ethers.utils.formatUnits(bn, decs));
                                if (isFinite(v)) return v.toFixed(toFixedPlaces);
                              }
                            } catch {}
                            try {
                              if (typeof fallbackStr === 'string' || typeof fallbackStr === 'number') {
                                const v = parseFloat(String(fallbackStr));
                                if (isFinite(v)) return v.toFixed(toFixedPlaces);
                              }
                            } catch {}
                            return (0).toFixed(toFixedPlaces);
                          };
                          const splitParts = (s) => {
                            const str = String(s);
                            const idx = str.indexOf('.');
                            if (idx === -1) return { i: str, f: ''.padEnd(toFixedPlaces, '0') };
                            const i = str.slice(0, idx);
                            let f = str.slice(idx + 1);
                            if (f.length < toFixedPlaces) f = f.padEnd(toFixedPlaces, '0');
                            return { i, f };
                          };

                          const entryStr = fmtUnitsOr(vaultData && vaultData.ENTRY_FEE, vaultStats && vaultStats.entryFee);
                          const payoutStr = fmtUnitsOr(vaultData && vaultData.PAYOUT_AMOUNT, vaultStats && vaultStats.payout);
                          // Vault balance may come as BN (vaultData) or a pre-formatted string (vaultStats)
                          const vBalStr = (() => {
                            try {
                              if (vaultData && vaultData.vaultBalance) {
                                const v = parseFloat(ethers.utils.formatUnits(vaultData.vaultBalance, decs));
                                if (isFinite(v)) return v.toFixed(toFixedPlaces);
                              }
                            } catch {}
                            try {
                              const s = vaultStats && vaultStats.vaultBalance;
                              if (s !== undefined && s !== null) {
                                const v = parseFloat(String(s));
                                if (isFinite(v)) return v.toFixed(toFixedPlaces);
                              }
                            } catch {}
                            return (0).toFixed(toFixedPlaces);
                          })();
                          const approvedStr = fmtUnitsOr(vaultData && vaultData.approvedLimit, vaultStats && vaultStats.approvedLimit);

                          const R = ({ label, valueStr, hint }) => {
                            const { i, f } = splitParts(valueStr);
                            return (
                              <>
                                <div style={{textAlign:'left'}}>{label}{hint ? <span style={{marginLeft:'0.35em'}} title={hint}>💡</span> : null}</div>
                                <div style={{display:'grid',gridTemplateColumns:'1fr auto auto',alignItems:'baseline',fontFamily:'monospace'}}>
                                  <div style={{textAlign:'right'}}>{i}</div>
                                  <div>.</div>
                                  <div style={{minWidth: `${toFixedPlaces}ch`}}>{f}</div>
                                </div>
                                <div style={{textAlign:'right',opacity:0.9}}>{name}</div>
                              </>
                            );
                          };

                          return (
                            <div style={{
                              display:'grid',
                              gridTemplateColumns:'auto 1fr auto',
                              rowGap:'0.25em',
                              columnGap:'0.8em',
                              alignItems:'baseline'
                            }}>
                              {R({ label:'🪙 Entry Fee', valueStr: entryStr })}
                              {R({ label:'💰 Payout', valueStr: payoutStr })}
                              {R({ label:'🔐 Vault Balance', valueStr: vBalStr })}
                              {R({ label:'✅ Approved Limit', valueStr: approvedStr, hint:'Default set to 10x entry fee for approval for the vault contract to spend.' })}
                            </div>
                          );
                        })()}

                        {vaultData && vaultData.vaultToken && vaultData.configToken && vaultData.vaultToken.toLowerCase() !== vaultData.configToken.toLowerCase() && (
                          <div style={{color:'#ff6b6b', marginTop:'0.5em'}}>
                            ⚠ Token mismatch. Vault.TOKEN {vaultData.vaultToken.slice(0,6)}...{vaultData.vaultToken.slice(-4)} vs Config {vaultData.configToken.slice(0,6)}...{vaultData.configToken.slice(-4)}
                          </div>
                        )}
                      </div>
                      

                      {(() => {
                        const cfg = tokens[carouselIdx].config;
                        const decs = (vaultData && vaultData.decimals) || cfg?.decimals || 18;
                        const entryFeeBN = vaultData && vaultData.ENTRY_FEE ? vaultData.ENTRY_FEE : null;
                        const approvedLimitBN = vaultData && vaultData.approvedLimit ? vaultData.approvedLimit : null;
                        const userBalBN = vaultData && vaultData.userBalance ? vaultData.userBalance : null;
                        const hasAllowance = entryFeeBN && approvedLimitBN ? approvedLimitBN.gte(entryFeeBN) : false;
                        const hasBalance = entryFeeBN && userBalBN ? userBalBN.gte(entryFeeBN) : false;
                        const canEnterStatus = (vaultData && vaultData.myStatus)
                          ? Boolean(vaultData.myStatus.canEnter)
                          : true; // if unknown, don't block
                        const needsApprove = !hasAllowance;

            async function handleApprove() {
                          try {
              setFreezeSel(true);
              try { const slug = slugifyToken(tokens[carouselIdx].name); const desired = '#page=' + slug; if (window.location.hash !== desired) history.replaceState(null, '', desired); } catch {}
                            if (!window.ethereum) { setTxMsg('No wallet found.'); return; }
                            if (!cfg?.token || !cfg?.vault) { setTxMsg('Config error.'); return; }
                            const provider = new ethers.providers.Web3Provider(window.ethereum);
                            const signer = provider.getSigner();
                            const network = await provider.getNetwork();
                            const wanted = Number(window.__READ_CHAIN_ID||943);
                            const name = wanted===943?'PulseChain Testnet V4':(wanted===369?'PulseChain Mainnet':`Chain ${wanted}`);
                            if (Number(network.chainId) !== wanted) { setTxMsg(`Wrong network, use ${name} (${wanted}). Current: ${network.chainId}`); return; }
                            // Determine actual token from vault if available (and deployed on this network)
                            let actualToken = cfg.token;
                            try {
                              const onchain = await vault.TOKEN();
                              const onchainCode = await provider.getCode(onchain);
                              if (onchainCode && onchainCode !== '0x') actualToken = onchain;
                            } catch {}
                            // Verify code exists on current network (precise and resilient)
                            const [vaultCode, tokenCode] = await Promise.all([
                              provider.getCode(cfg.vault),
                              provider.getCode(actualToken)
                            ]);
                            if (vaultCode === '0x' || tokenCode === '0x') {
                              // No local dev fallback in testnet mode
                              const which = vaultCode === '0x' ? 'Vault' : 'Token';
                              setTxMsg(`${which} not deployed on this network.`);
                              return;
                            }
                            const tokenAbi = [
                              "function approve(address spender, uint256 amount) public returns (bool)",
                              "function balanceOf(address account) view returns (uint256)"
                            ];
                            const token = new ethers.Contract(actualToken, tokenAbi, signer);
                            // Approve 10x entry fee by default
                            const toApprove = entryFeeBN ? entryFeeBN.mul(ethers.BigNumber.from('10')) : ethers.utils.parseUnits('1000', decs);
                            setTxMsg(`Approving ${ethers.utils.formatUnits(toApprove, decs)} ${tokens[carouselIdx].name}...`);
                            const tx = await token.approve(cfg.vault, toApprove);
                            setTxMsg('Waiting for confirmation...');
                            await tx.wait();
                            setTxMsg('✅ Approved! You can now JOIN.');
                            // Optimistically update allowance locally so UI enables JOIN immediately
                            try {
                              setVaultData(prev => (prev ? { ...prev, approvedLimit: toApprove } : prev));
                            } catch {}
                            // Refresh the per-vault cache entry too, to avoid stale cache hiding the update
                            try {
                              const cacheKey = String(cfg.vault || '').toLowerCase();
                              const cached = statsCacheRef.current.get(cacheKey) || { t: 0, stats: null, data: null };
                              statsCacheRef.current.set(cacheKey, {
                                t: Date.now(),
                                stats: cached.stats,
                                data: { ...(cached.data || {}), approvedLimit: toApprove }
                              });
                            } catch {}
                            // Light background refresh after a short delay to reconcile with RPC state
                            try { setTimeout(() => setRefreshStats(x => x + 1), 3000); } catch {}
                          } catch (err) {
                            if (err && err.code === 4001) setTxMsg('❌ Cancelled by user');
                            else setTxMsg(`❌ Approval failed: ${err?.message || 'Unknown error'}`);
                          } finally {
                            try { setFreezeSel(false); } catch {}
                          }
                        }

            async function handleJoin() {
                          try {
                            setFreezeSel(true);
                            try { const slug = slugifyToken(tokens[carouselIdx].name); const desired = '#page=' + slug; if (window.location.hash !== desired) history.replaceState(null, '', desired); } catch {}
                            if (!window.ethereum) { setTxMsg('No wallet found.'); return; }
                            if (!cfg?.vault) { setTxMsg('Config error.'); return; }
                            const provider = new ethers.providers.Web3Provider(window.ethereum);
                            const signer = provider.getSigner();
                            const network = await provider.getNetwork();
                            const wanted = Number(window.__READ_CHAIN_ID||943);
                            const name = wanted===943?'PulseChain Testnet V4':(wanted===369?'PulseChain Mainnet':`Chain ${wanted}`);
                            if (Number(network.chainId) !== wanted) { setTxMsg(`Wrong network, use ${name} (${wanted}). Current: ${network.chainId}`); return; }
              // Verify code exists on current network
              const vaultCode = await provider.getCode(cfg.vault);
              if (vaultCode === '0x') { setTxMsg('Vault not deployed on this network.'); return; }
                            const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], signer);
                            // Ensure JOIN exists
                            try { vault.interface.encodeFunctionData('JOIN', []); } catch { setTxMsg('❌ JOIN not found on vault'); return; }
                            // Optional MY_STATUS re-check using read provider to get latest reason
                            if (typeof vault.MY_STATUS === 'function' && account) {
                              try {
                                const read = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);
                                const s = await read.MY_STATUS({ from: account });
                                const can = Boolean(s.canEnter ?? s[0]);
                                const msg = s.statusMessage ?? s[5] ?? '';
                                if (!can) {
                                  setTxMsg(`❌ Cannot join: ${msg || 'precondition failed'}`);
                                  return;
                                }
                              } catch {}
                            }
                            // Pre-flight: simulate JOIN to surface revert reason
                            try {
                              await vault.callStatic.JOIN();
                            } catch (err) {
                              const reason = (err && (err.error && err.error.message))
                                || err?.reason
                                || (typeof err?.message === 'string' ? err.message : '')
                                || 'revert';
                              // Clean up verbose provider messages
                              const pretty = reason.replace(/^execution reverted:?\s*/i, '')
                                                  .replace(/VM Exception while processing transaction:\s*/i, '')
                                                  .replace(/Internal JSON-RPC error\.:?\s*/i, '')
                                                  .trim();
                              setTxMsg(`❌ Cannot join: ${pretty}`);
                              return;
                            }
                            setTxMsg('Sending transaction...');
                            const tx = await vault.JOIN();
                            setTxMsg('Waiting for confirmation...');
                            await tx.wait();
                            setTxMsg('✅ Entered the MATRIX!');
                            setRefreshStats(x => x + 1);
                          } catch (err) {
                            if (err && err.code === 4001) setTxMsg('❌ Transaction cancelled by user');
                            else setTxMsg(`❌ JOIN failed: ${err?.message || 'Unknown error'}`);
                          } finally { setFreezeSel(false); }
                        }

                        return (
                          <div style={{width:'100%', display:'flex', flexDirection:'column', alignItems:'center'}}>
                            {needsApprove ? (
                              <button
                                style={{
                                  marginTop: '0.6em',
                                  background: '#000',
                                  border: '2px solid #00ff00',
                                  borderRadius: '1em',
                                  padding: '0.9em 2em',
                                  fontSize: '1.0em',
                                  fontWeight: 'bold',
                                  color: '#00ff00',
                                  cursor: 'pointer',
                                  transition: 'all 0.3s ease',
                                  fontFamily: 'monospace',
                                  textTransform: 'uppercase',
                                  letterSpacing: '0.1em',
                                  boxShadow: 'none'
                                }}
                                onMouseEnter={(e) => {
                                  e.target.style.transform = 'translateY(-2px)';
                                  e.target.style.boxShadow = '0 8px 25px rgba(0, 255, 0, 0.4)';
                                  e.target.style.background = 'rgba(0, 255, 0, 0.1)';
                                }}
                                onMouseLeave={(e) => {
                                  e.target.style.transform = 'translateY(0)';
                                  e.target.style.boxShadow = 'none';
                                  e.target.style.background = '#000';
                                }}
                                onClick={handleApprove}
                              >
                                Approve {tokens[carouselIdx].name}
                              </button>
                            ) : hasBalance && canEnterStatus ? (
                              <button
                                style={{
                                  marginTop: '0.6em',
                                  background: '#000',
                                  border: '2px solid #00ff00',
                                  borderRadius: '1em',
                                  padding: '0.9em 2em',
                                  fontSize: '1.0em',
                                  fontWeight: 'bold',
                                  color: '#00ff00',
                                  cursor: 'pointer',
                                  transition: 'all 0.3s ease',
                                  fontFamily: 'monospace',
                                  textTransform: 'uppercase',
                                  letterSpacing: '0.1em',
                                  boxShadow: 'none'
                                }}
                                onMouseEnter={(e) => {
                                  e.target.style.transform = 'translateY(-2px)';
                                  e.target.style.boxShadow = '0 8px 25px rgba(0, 255, 0, 0.4)';
                                  e.target.style.background = 'rgba(0, 255, 0, 0.1)';
                                }}
                                onMouseLeave={(e) => {
                                  e.target.style.transform = 'translateY(0)';
                                  e.target.style.boxShadow = 'none';
                                  e.target.style.background = '#000';
                                }}
                                onClick={handleJoin}
                              >
                                ENTER the MATRIX
                              </button>
                            ) : (
                              <button
                                style={{
                                  marginTop: '0.6em',
                                  background: '#111',
                                  border: '2px solid #666',
                                  borderRadius: '1em',
                                  padding: '0.9em 2em',
                                  fontSize: '1.0em',
                                  fontWeight: 'bold',
                                  color: '#aaa',
                                  cursor: 'not-allowed',
                                  fontFamily: 'monospace',
                                  textTransform: 'uppercase',
                                  letterSpacing: '0.1em'
                                }}
                                disabled
                                title={
                                  !hasBalance ? 'Insufficient token balance for entry fee' : (
                                    canEnterStatus ? 'Not available' : (vaultData && vaultData.myStatus && vaultData.myStatus.statusMessage) || 'Cannot enter now'
                                  )
                                }
                              >
                                {!hasBalance ? (
                                  <>Insufficient {tokens[carouselIdx].name} balance</>
                                ) : (
                                  <>{(vaultData && vaultData.myStatus && vaultData.myStatus.statusMessage) || 'Cannot enter now'}</>
                                )}
                              </button>
                            )}
                          </div>
                        );
                      })()}
                      {txMsg && <div style={{marginTop:'0.7em',color:txMsg.startsWith('Error')? '#ff6b6b':'#ffd93d',fontWeight:'bold', fontSize:'0.98em'}}>{txMsg}</div>}
                    </div>
                    {/* Open VP's section - width tracks OPEN-card (75% of MAIN-card) */}
                    <div style={{marginTop:'1.2em', width:'100%', alignSelf:'stretch'}}>
                      <div style={{
                        fontWeight:400,
                        fontSize:'1.2em',
                        color:'#00ff00',
                        textAlign:'left',
                        letterSpacing:'0.01em',
                        display:'flex',
                        alignItems:'center',
                        width:'75%', // match .OPEN-card width
                        boxSizing:'border-box',
                        marginLeft:'auto',
                        marginRight:'auto',
                        marginBottom:'0.5em'
                      }}>Open VP's:</div>
            <div className="OPEN-card">
            {openVPs.length === 0 ? (
                          <div style={{color:'#00ff00'}}>No open VP's yet.</div>
                        ) : (
              <div style={{color:'#00ff00', paddingBottom:'1.8em'}}>
              {openVPs.map(data => (
                              <div key={data.id}>
                                {data.nextOpenVPs && (
                                  <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: tokens[carouselIdx].name.includes('4x4') ? 'repeat(4, 1fr)' : 'repeat(3, 1fr)',
                                    gap: '0.75em',
                                    marginBottom: '1em'
                                  }}>
                                    {data.nextOpenVPs.map((vp) => (
                                      <div key={vp.tokenId} style={{
                                        padding: tokens[carouselIdx].name.includes('4x4') ? '0.75em' : '1em',
                                        background: 'rgba(0,0,0,0.6)',
                                        border: '2px solid #00ff88',
                                        borderRadius: '0.8em',
                                        textAlign: 'center'
                                      }}>
                                        <div style={{
                                          fontSize: tokens[carouselIdx].name.includes('4x4') ? '1em' : '1.1em',
                                          fontWeight: 'bold',
                                          color: '#00ff88',
                                          marginBottom: '0.5em'
                                        }}>
                                          💚 VP#{vp.tokenId}
                                        </div>
                                        <div style={{ fontSize: tokens[carouselIdx].name.includes('4x4') ? '0.75em' : '0.8em', color: '#00ff00' }}>
                                          {vp.filledCount}/{vp.structureSize || (tokens[carouselIdx].name.includes('3x3') ? 13 : 85)} filled
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                )}
                              </div>
                            ))}
                            <div style={{marginTop:'0.4em', fontSize:'0.75em', color:'#00ff00', textAlign:'left'}}>
                              Your positions: {userCyclePositions.length ? userCyclePositions.map(id=>`#${id}`).join(', ') : '—'}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                    {/* VIEW section below OPEN-card (single card only) */}
                    <ViewMatrixSection carouselIdx={carouselIdx} tokens={tokens} account={account} />
                    {/* HISTORY section below OPEN-card */}
                    <HistorySection carouselIdx={carouselIdx} tokens={tokens} account={account} refreshStats={refreshStats} />
                    {/* Developer Section directly below OPEN-card and HISTORY-card */}
                    <DeveloperSection carouselIdx={carouselIdx} tokens={tokens} account={account} />
                    </>
                  ) : (
                    <div id="all-view-root">
                      <button
                        style={{
                          marginTop: '1.2em',
                          background: '#000',
                          border: '2px solid #00ff00',
                          borderRadius: '1em',
                          padding: '1em 2em',
                          fontSize: '1.1em',
                          fontWeight: 'bold',
                          color: '#00ff00',
                          cursor: 'pointer',
                          margin: '1em 0',
                          transition: 'all 0.3s ease',
                          fontFamily: 'monospace',
                          textTransform: 'uppercase',
                          letterSpacing: '0.1em',
                          boxShadow: 'none'
                        }}
                        onMouseEnter={(e) => {
                          e.target.style.transform = 'translateY(-2px)';
                          e.target.style.boxShadow = '0 8px 25px rgba(0, 255, 0, 0.4)';
                          e.target.style.background = 'rgba(0, 255, 0, 0.1)';
                        }}
                        onMouseLeave={(e) => {
                          e.target.style.transform = 'translateY(0)';
                          e.target.style.boxShadow = 'none';
                          e.target.style.background = '#000';
                        }}
                        onClick={connectWallet}
                      >
                        CONNECT Wallet
                      </button>
                      
                      {txMsg && <div style={{marginTop:'0.7em',color:txMsg.startsWith('Error')? '#ff6b6b':'#ffd93d',fontWeight:'bold', fontSize:'0.98em'}}>{txMsg}</div>}
                    </div>
                  )
                ) : currentToken.name === 'Factory' ? (
                  (() => {
                    function FactoryCard(){
                      const [tokenAddress, setTokenAddress] = React.useState('');
                      const [entryAmount, setEntryAmount] = React.useState('');
                      const [vpSize, setVpSize] = React.useState('');
                      const [status, setStatus] = React.useState('');
                      const [busy, setBusy] = React.useState(false);
                      const [checking, setChecking] = React.useState(false);
                      const [tokenInfo, setTokenInfo] = React.useState(null); // {name,symbol,decimals,source}
                      const [existingWarnings, setExistingWarnings] = React.useState({ loading: false, lines: [] });
                      // Token decimals are auto-detected; no manual input in UI

                      // Shared sizing for all form fields
                      const FIELD_MAX_WIDTH = 560;
                      const fieldWrapStyle = { width:'100%', maxWidth: FIELD_MAX_WIDTH };
                      const baseField = {
                        width:'100%',
                        height:'50px',
                        lineHeight:'50px',
                        padding:'0 0.8em',
                        borderRadius:'0.6em',
                        border:'1px solid #444',
                        background:'rgba(0,0,0,0.5)',
                        color:'#fff',
                        fontFamily:'monospace',
                        boxSizing:'border-box'
                      };
                      const inputStyle = baseField;
                      const selectStyle = { ...baseField, cursor:'pointer', appearance:'none', WebkitAppearance:'none', MozAppearance:'none' };

                      // Minimal CSS for disclaimer matching FAQ
          React.useEffect(() => {
                        const id = 'factory-faq-styles';
                        if (!document.getElementById(id)) {
                          const s = document.createElement('style');
                          s.id = id;
                          s.textContent = `
                            .disclaimer-box{border:1px solid #ff3030;background:rgba(80,0,0,0.30);padding:0.9em 1em;border-radius:0.8em;box-shadow:0 0 6px rgba(255,0,0,0.25);} 
                            .highlight-box{background:rgba(0,100,0,0.15);border-left:4px solid rgba(0,255,0,0.5);padding:0.8em 1em;border-radius:0.6em;} 
            .warning-box{background:rgba(80,0,0,0.30);border-left:4px solid #ff3030;padding:0.8em 1em;border-radius:0.6em;color:#ffd1d1;}
            /* Factory field normalization */
            .factory-card input, .factory-card select { height:50px; line-height:50px; padding:0 0.8em; border-radius:0.6em; border:1px solid #444; background:rgba(0,0,0,0.5); color:#fff; font-family:monospace; box-sizing:border-box; }
            .factory-card select { appearance:none; -webkit-appearance:none; -moz-appearance:none; cursor:pointer; }
            .factory-card input[type=number]::-webkit-outer-spin-button,
            .factory-card input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
            .factory-card input[type=number] { -moz-appearance: textfield; }
            /* Accordion */
                            .factory-accordion summary { list-style:none; cursor:pointer; background:rgba(0,60,0,0.18); border:1px solid rgba(0,255,0,0.18); color:#b9ffb9; padding:0.8em 1em; border-radius:0.6em; font-weight:600; }
            .factory-accordion summary::-webkit-details-marker { display:none; }
            .factory-accordion[open] summary { border-bottom-left-radius:0; border-bottom-right-radius:0; }
                            .factory-accordion .accordion-content { border:1px solid rgba(0,255,0,0.18); border-top:none; padding:0.9em 1em; border-bottom-left-radius:0.6em; border-bottom-right-radius:0.6em; background:rgba(0,30,0,0.18); }
                          `;
                          document.head.appendChild(s);
                        }
                      }, []);

                      function isValidAddress(addr){ return /^0x[a-fA-F0-9]{40}$/.test(String(addr||'')); }

                      // Recognize token strictly on the selected read network only (no cross-chain probes)
                      React.useEffect(() => {
                        let ignore = false;
                        const addr = tokenAddress;
                        if (!isValidAddress(addr)) { setTokenInfo(null); return; }
                        const delay = setTimeout(async () => {
                          setChecking(true);
                          const wanted = Number(window.__READ_CHAIN_ID || localStorage.getItem('READ_CHAIN_ID') || 943);
                          const url = (window.PULSE_RPC && window.PULSE_RPC[wanted]) || (wanted===369 ? 'https://rpc.pulsechain.com' : 'https://rpc.v4.testnet.pulsechain.com');
                          const RPCS = [ { url, name: wanted===369 ? 'PulseChain Mainnet' : 'PulseChain Testnet v4' } ];
                          const abi = [
                            'function name() view returns (string)',
                            'function symbol() view returns (string)',
                            'function decimals() view returns (uint8)'
                          ];
                          let found = null;
                          for (const r of RPCS) {
                            try {
                              const prov = new ethers.providers.JsonRpcProvider(r.url);
                              const c = new ethers.Contract(addr, abi, prov);
                              const [name, symbol, decimals] = await Promise.all([
                                c.name().catch(() => null),
                                c.symbol().catch(() => null),
                                c.decimals().catch(() => null)
                              ]);
                              if (name && symbol && (decimals !== null)) { found = { name, symbol, decimals, source: r.name }; break; }
                            } catch {}
                          }
                          if (!ignore) setTokenInfo(found);
                          setChecking(false);
                        }, 400);
                        return () => { ignore = true; clearTimeout(delay); };
                      }, [tokenAddress]);

                      // No manual decimals; we rely on tokenInfo.decimals or on-chain fetch during deploy

                      // Scan existing matrices for this token across known sources and warn per size with amounts
                      React.useEffect(() => {
                        let cancelled = false;
                        const addr = (tokenAddress || '').toLowerCase();
                        if (!isValidAddress(addr)) { setExistingWarnings({ loading: false, lines: [] }); return; }
                        const delay = setTimeout(async () => {
                          try {
                            setExistingWarnings({ loading: true, lines: [] });
                            const fromA = Array.isArray(window.coinConfigs) ? window.coinConfigs : [];
                            const fromB = Array.isArray(window.coinConfigsData) ? window.coinConfigsData : [];
                            const byVault = new Map();
                            for (const c of [...fromA, ...fromB]) {
                              if (!c || !c.vault || !c.token) continue;
                              if (String(c.token).toLowerCase() !== addr) continue;
                              const k = String(c.vault).toLowerCase();
                              if (!byVault.has(k)) byVault.set(k, c);
                            }
                            const entries = Array.from(byVault.values());
                            if (entries.length === 0) { if (!cancelled) setExistingWarnings({ loading: false, lines: [] }); return; }

                            const providers = [];
                            if (window.ethereum) { try { providers.push({ prov: new ethers.providers.Web3Provider(window.ethereum), name: 'Wallet' }); } catch {} }
                            // Use only the selected read network
                            try {
                              const wanted = Number(window.__READ_CHAIN_ID || localStorage.getItem('READ_CHAIN_ID') || 943);
                              const url = (window.PULSE_RPC && window.PULSE_RPC[wanted]) || (wanted===369 ? 'https://rpc.pulsechain.com' : 'https://rpc.v4.testnet.pulsechain.com');
                              const name = wanted===369 ? 'PulseChain Mainnet' : 'PulseChain Testnet v4';
                              providers.push({ prov: new ethers.providers.JsonRpcProvider(url), name });
                            } catch {}

                            const decimals = (tokenInfo && tokenInfo.decimals != null) ? tokenInfo.decimals : (entries.find(e => e && e.decimals != null)?.decimals ?? 18);
                            const linesMap = new Map(); // size -> Set(amount)

                            for (const c of entries) {
                              const is4 = (Number(c.vpSize) === 4) || (/4x4/i.test(String(c.abiKey || ''))) || (/4x4/.test(String(c.name || '')));
                              const rawKey = c.abiKey || (is4 ? 'PuMa4x4' : 'PuMa3x3');
                              const abiKey = (window.AllVaultABI && window.AllVaultABI[rawKey]) ? rawKey : (is4 ? 'PuMa4x4' : 'PuMa3x3');
                              const abi = window.AllVaultABI && window.AllVaultABI[abiKey];
                              let amountFmt = null;
                              if (abi) {
                                for (const pr of providers) {
                                  try {
                                    const code = await pr.prov.getCode(c.vault);
                                    if (code && code !== '0x') {
                                      const vault = new ethers.Contract(c.vault, abi, pr.prov);
                                      const fee = await vault.ENTRY_FEE();
                                      amountFmt = ethers.utils.formatUnits(fee, decimals);
                                      break;
                                    }
                                  } catch {}
                                }
                              }
                              const size = is4 ? '4x4' : '3x3';
                              const set = linesMap.get(size) || new Set();
                              set.add(amountFmt ?? '?');
                              linesMap.set(size, set);
                            }

                            const label = (tokenInfo && tokenInfo.symbol) ? String(tokenInfo.symbol).toUpperCase() : 'Token';
                            const lines = Array.from(linesMap.entries()).map(([size, amounts]) => {
                              const list = Array.from(amounts).join(', ');
                              return `${label} already exists in ${size} + ${list}`;
                            });
                            if (!cancelled) setExistingWarnings({ loading: false, lines });
                          } catch {
                            if (!cancelled) setExistingWarnings({ loading: false, lines: [] });
                          }
                        }, 450);
                        return () => { cancelled = true; clearTimeout(delay); };
                      }, [tokenAddress, tokenInfo?.decimals, tokenInfo?.symbol]);

                      async function loadNewMatrixArtifact(){
                        const urls = [
                          'vendor/NewMatrix.artifact.json',
                          './vendor/NewMatrix.artifact.json',
                          '/vendor/NewMatrix.artifact.json',
                          '/frontend/vendor/NewMatrix.artifact.json',
                          'artifacts/contracts/NewMatrix.sol/NewMatrix.json',
                          './artifacts/contracts/NewMatrix.sol/NewMatrix.json',
                          '/artifacts/contracts/NewMatrix.sol/NewMatrix.json',
                          '../artifacts/contracts/NewMatrix.sol/NewMatrix.json',
                          '/frontend/../artifacts/contracts/NewMatrix.sol/NewMatrix.json'
                        ];
                        const tried = [];
                        for (const u of urls) {
                          try {
                            const r = await fetch(u, { cache: 'no-cache' });
                            if (!r.ok) { tried.push(`${u} (${r.status})`); continue; }
                            const j = await r.json();
                            const abi = j.abi; const raw = j.bytecode || j.evm?.bytecode?.object || '';
                            const bytecode = raw.startsWith('0x') ? raw : ('0x'+raw);
                            if (abi && bytecode && bytecode.length > 2) return { abi, bytecode };
                            tried.push(`${u} (missing abi/bytecode)`);
                          } catch(e){ tried.push(`${u} (${e?.message||'err'})`); }
                        }
                        throw new Error('NewMatrix artifact not found: ' + tried.join(' | '));
                      }

                      async function createMatrix(){
                        try {
                          if (!window.ethereum) { setStatus('Please install a Web3 wallet (MetaMask/Rabby/IM).'); return; }
                          if (!isValidAddress(tokenAddress)) { setStatus('Invalid token address.'); return; }
                          const vp = String(vpSize) === '3' ? 3 : (String(vpSize) === '4' ? 4 : 0);
                          if (!vp) { setStatus('Pick VP Size (3 or 4).'); return; }
                          setBusy(true); setStatus('Loading artifact...');
                          const { abi, bytecode } = await loadNewMatrixArtifact();
                          setStatus('Connecting wallet...');
                          const provider = new ethers.providers.Web3Provider(window.ethereum);
                          const signer = provider.getSigner();
                          const net = await provider.getNetwork();
                          // Prefer recognized decimals; otherwise fetch via wallet provider
                          setStatus(`Preparing entry fee (decimals)…`);
                          let decimals;
                          if (tokenInfo?.decimals != null) {
                            decimals = Number(tokenInfo.decimals);
                          } else {
                            try { const erc = new ethers.Contract(tokenAddress, ['function decimals() view returns (uint8)'], provider); decimals = await erc.decimals(); } catch {}
                            if (decimals == null) decimals = 18;
                          }
                          // Normalize single decimal entry string to token decimals
                          const rawStr = String(entryAmount || '').trim();
                          if (!rawStr) { setStatus('Enter an entry amount (e.g., 0.1234).'); setBusy(false); return; }
                          const cleaned = rawStr.replace(/,/g, '');
                          if (!/^\d*(?:\.\d*)?$/.test(cleaned)) { setStatus('Invalid amount format. Use digits and a single dot.'); setBusy(false); return; }
                          let [intPart, fracPart = ''] = cleaned.split('.');
                          if (!intPart) intPart = '0';
                          intPart = intPart.replace(/^0+(?=\d)/, '');
                          fracPart = String(fracPart || '');
                          if (decimals > 0) {
                            if (fracPart.length > decimals) fracPart = fracPart.slice(0, decimals);
                            // Pad to exact decimals to avoid parseUnits surprises
                            fracPart = fracPart.padEnd(decimals, '0');
                          } else {
                            fracPart = '';
                          }
                          const amountStr = decimals > 0 ? `${intPart}.${fracPart}` : `${intPart}`;
                          try {
                            const nonZero = BigInt(intPart || '0') > 0n || /[1-9]/.test(fracPart);
                            if (!nonZero) { setStatus('Enter a non-zero amount.'); setBusy(false); return; }
                          } catch {}
                          const entryWei = ethers.utils.parseUnits(amountStr, decimals);
                          setStatus('Deploying NewMatrix...');
                          const fac = new ethers.ContractFactory(abi, bytecode, signer);
                          const contract = await fac.deploy(tokenAddress, entryWei, vp);
                          await contract.deployed();
                          const address = contract.address;
                          setStatus(`✅ Deployed at ${address}`);

                          // Auto-approve and fund first mandatory entry
                          try {
                            setStatus('🧪 Approving vault to spend entry fee...');
                            const erc20 = new ethers.Contract(tokenAddress, [
                              'function approve(address spender, uint256 amount) returns (bool)'
                            ], signer);
                            const approveTx = await erc20.approve(address, entryWei);
                            await approveTx.wait();
                            setStatus(`✅ Approved • ${approveTx.hash}`);

                            setStatus('🔐 Funding entry #1 (JOIN)...');
                            const vault = new ethers.Contract(address, abi, signer);
                            const joinTx = await vault.JOIN();
                            await joinTx.wait();
                            setStatus(`✅ Entry #1 funded • ${joinTx.hash}`);
                          } catch (fundErr) {
                            setStatus('❌ Funding step failed: ' + (fundErr?.message || fundErr));
                            throw fundErr;
                          }

                          // Attach to UI: add to coinConfigs and notify
                          try {
                            const abiKey = vp === 3 ? 'PuMa3x3' : 'PuMa4x4';
                            const cfg = { name: 'newMatrix', vault: address, token: tokenAddress, abiKey, decimals, color:'#00c3ff', chainId: Number(net.chainId) };
                            const base = Array.isArray(window.coinConfigs) ? [...window.coinConfigs] : [];
                            const keyOf = (x)=> ((x?.vault||'').toLowerCase() + '::' + String(Number(x?.chainId || net.chainId)));
                            const key = keyOf(cfg);
                            const map = new Map(base.map(b => [keyOf(b), b]));
                            map.set(key, cfg);
                            const next = Array.from(map.values());
                            window.coinConfigs = next;
                            try { window.dispatchEvent(new CustomEvent('coinConfigsReady', { detail: { chainId: Number(net.chainId), count: base.length, source: 'factory' } })); } catch {}
                            setStatus(prev => prev + ' • Added to UI');

                            // Also update coinConfigsData so ALL-card sees it even before any downloads/merges
                            const baseData = Array.isArray(window.coinConfigsData) ? [...window.coinConfigsData] : [];
                            const entryData = { name: 'newMatrix', vault: address, token: tokenAddress, abiKey, vpSize: vp, chainId: Number(net.chainId), color:'#00c3ff', decimals };
                            const key2 = (x)=> ((x?.vault||'').toLowerCase() + '::' + String(Number(x?.chainId || net.chainId)));
                            const map2 = new Map(baseData.map(b => [key2(b), b]));
                            map2.set(key2(entryData), entryData);
                            window.coinConfigsData = Array.from(map2.values());

                            // Fire a deployment event (listeners will refresh tokens)
                            try { window.dispatchEvent(new CustomEvent('newContractDeployed', { detail: { contractName: 'newMatrix', address, token: tokenAddress, abiKey, vpSize: vp, chainId: Number(net.chainId) } })); } catch {}

                            // Publish to public matrices DB (Google Sheets) like Factory.html
                            try {
                              const __isProdHost = (function(h){ try{ return /(^|\.)pulsematrix\.app$/i.test(h||''); }catch{ return false; } })(location && location.hostname);
                              const MATRICES_API_URL = (window.MATRICES_API_URL || (__isProdHost?null:localStorage.getItem('MATRICES_API_URL')) || 'https://script.google.com/macros/s/AKfycbyEyspSK4xDspCjOnbacvtqIVER9Di9m2zHw4go3y46rr0AZlTrc8Lg-HgVCApQbP0L_Q/exec');
                              let receipt = '';
                              try { const read = new ethers.Contract(address, abi, provider); if (read.getReceiptContract) receipt = await read.getReceiptContract(); } catch {}
                              const payload = { name: 'newMatrix', vault: address, receipt, token: tokenAddress, abiKey, vpSize: vp, chainId: Number(net.chainId), color: '#00c3ff', decimals, approved: true, active: true };
                              try { if(!__isProdHost) localStorage.setItem('MATRICES_API_URL', MATRICES_API_URL); } catch {}
                              await fetch(MATRICES_API_URL, { method: 'POST', mode: 'no-cors', headers: { 'content-type': 'text/plain;charset=utf-8' }, body: JSON.stringify(payload) });
                              setStatus(prev => prev + ' • Published to DB');
                            } catch (postErr) {
                              // Non-blocking
                              try { console.warn('DB publish failed:', postErr); } catch {}
                            }
                          } catch {}

                          // Reset inputs
                          setTokenAddress(''); setEntryAmount(''); setVpSize('');
                        } catch (e) {
                          setStatus('❌ Deployment failed: ' + (e?.message || e));
                        } finally { setBusy(false); }
                      }

                      return (
                        <div className="factory-card" style={{width:'100%', display:'flex', flexDirection:'column', alignItems:'center', marginTop:'1.2em'}}>
                          <div style={{width:'85%', textAlign:'left', color:'#00ff00'}}>
                            <div className="disclaimer-box" style={{marginBottom:'0.9em'}}>
                              <div style={{color:'#ffd1d1', margin:0, fontWeight:700}}>
                                ⚠️ EASY 3 STEP MATRIX FACTORY - PERMANENT CREATION - Once deployed, the MATRIX becomes IMMUTABLE and cannot be modified or deleted! ⚠️
                              </div>
                            </div>
                            <details className="factory-accordion" style={{marginBottom:'0.9em'}}>
                              <summary>🏭 Factory Overview — Easy 1•2•3 Deploy ▲ ▼</summary>
                              <div className="accordion-content">
                                <div className="highlight-box">
                                  <h5>💚 Easy 1•2•3 Deploy</h5>
                                  <ol style={{margin:'0.2em 0 0 1.2em'}}>
                                    <li>Enter any ERC20/PRC20 token contract address</li>
                                    <li>Choose 3x3 (faster) or 4x4 (higher risk/rewards)</li>
                                    <li>Set your custom entry amount.     ⚠️ You MUST also pay for the #1 Entry ⚠️</li>
                                    <li>Click 'One-Click DEPLOY' - Confirm deployment - Approve spending - Confirm transaction </li>
                                  </ol>
                                </div>
                                <div className="highlight-box">
                                  <h5>How It Works</h5>
                                  <ul>
                                    <li>Enter any ERC20 token contract address</li>
                                    <li>Set your custom entry amount</li>
                                    <li>Choose 3x3 (faster) or 4x4 (higher rewards)</li>
                                    <li>Factory generates complete Solidity contract</li>
                                    <li>Contract compiles and deploys automatically</li>
                                    <li>Universal auto-pay system activates immediately</li>
                                    <li>Research fund allocation configured automatically</li>
                                    <li>Your custom MATRIX is live and ready!</li>
                                  </ul>
                                </div>
                                <div className="highlight-box">
                                  <h5>Benefits</h5>
                                  <ul>
                                    <li>No coding required</li>
                                    <li>Proven VP MATRIX mechanics</li>
                                    <li>Universal auto-pay system (no manual claims)</li>
                                    <li>Built-in EOL safety net for all participants</li>
                                    <li>Automatic research fund allocation</li>
                                    <li>Fully autonomous - NO ADMIN KEYS, immutable operation</li>
                                    <li>Community building tool</li>
                                  </ul>
                                </div>
                                <div className="highlight-box">
                                  <h5>Important Notes</h5>
                                  <ul>
                                    <li>Contract deployment requires ETH/PLS for gas</li>
                                    <li>You are responsible for your token's legitimacy</li>
                                    <li>Matrix parameters cannot be changed after creation</li>
                                    <li>Ensure your token contract is verified</li>
                                    <li>Test on testnetV4 first</li>
                                  </ul>
                                </div>
                              </div>
                            </details>
                            <div className="OPEN-card" style={{width:'100%'}}>
                              {/* Centered CONNECT Wallet like coin info cards */}
                              {!account && (
                                <div style={{display:'flex', justifyContent:'center', marginBottom:'0.6em'}}>
                                  <button
                                    onClick={connectWallet}
                                    style={{
                                      background: '#000',
                                      border: '2px solid #00ff00',
                                      borderRadius: '1em',
                                      padding: '1em 2em',
                                      fontSize: '1.1em',
                                      fontWeight: 'bold',
                                      color: '#00ff00',
                                      cursor: 'pointer',
                                      margin: '1em 0',
                                      transition: 'all 0.3s ease',
                                      fontFamily: 'monospace',
                                      textTransform: 'uppercase',
                                      letterSpacing: '0.1em',
                                      boxShadow: 'none'
                                    }}
                                    onMouseEnter={(e) => {
                                      e.target.style.transform = 'translateY(-2px)';
                                      e.target.style.boxShadow = '0 8px 25px rgba(0, 255, 0, 0.4)';
                                      e.target.style.background = 'rgba(0, 255, 0, 0.1)';
                                    }}
                                    onMouseLeave={(e) => {
                                      e.target.style.transform = 'translateY(0)';
                                      e.target.style.boxShadow = 'none';
                                      e.target.style.background = '#000';
                                    }}
                                  >
                                    CONNECT Wallet
                                  </button>
                                </div>
                              )}
                              <div style={{fontSize:'1.2em', color:'#ffd93d', margin:'0.2em 0 0.8em', fontWeight:600}}>Create New Matrix</div>
                              {/* Vertical form: Address, VP Size, Entry Amount */}
                              <div style={{display:'flex', flexDirection:'column', gap:'0.9em'}}>
                                <div style={fieldWrapStyle}>
                                  <div style={{display:'flex', alignItems:'center', gap:'0.6em', marginBottom:'0.35em'}}>
                                    <div style={{color:'#ffd93d', fontSize:'0.95em'}}>Token Contract Address *</div>
                                    {tokenInfo && (
                                      <span title={`Recognized on ${tokenInfo.source}: ${tokenInfo.name} (${tokenInfo.symbol})`} style={{color:'#00ff88', fontWeight:700}}>✅</span>
                                    )}
                                  </div>
                                  <input value={tokenAddress} onChange={e=>setTokenAddress(e.target.value)} placeholder="0x..." style={inputStyle} />
                                  {tokenAddress && !isValidAddress(tokenAddress) && <div style={{color:'#ff6b6b', fontSize:'0.85em', marginTop:'0.3em'}}>❌ Invalid address</div>}
                                  {isValidAddress(tokenAddress) && (checking ? (
                                    <div style={{color:'#ffd93d', fontSize:'0.85em', marginTop:'0.3em'}}>🔍 Checking Testnet v4 → PulseChain…</div>
                                  ) : tokenInfo ? (
                                    <div style={{color:'#00ff88', fontSize:'0.85em', marginTop:'0.3em'}}>Recognized on {tokenInfo.source}: {tokenInfo.name} ({tokenInfo.symbol}), decimals {tokenInfo.decimals}</div>
                                  ) : (
                                    <div style={{color:'#ffae42', fontSize:'0.85em', marginTop:'0.3em'}}>Not found on the checked networks</div>
                                  ))}
                                  {/* Existing matrices warning per size */}
                                  {isValidAddress(tokenAddress) && (
                                    existingWarnings.loading ? (
                                      <div style={{color:'#ffd93d', fontSize:'0.85em', marginTop:'0.3em'}}>Scanning existing matrices…</div>
                                    ) : (
                                      existingWarnings.lines.length > 0 && (
                                        <div className="warning-box" style={{marginTop:'0.4em'}}>
                                          {existingWarnings.lines.map(line => (
                                            <div key={line}>⚠️ {line}</div>
                                          ))}
                                        </div>
                                      )
                                    )
                                  )}
                                </div>
                                {/* Decimals UI removed: auto-detected from token */}
                                <div style={fieldWrapStyle}>
                                  <div style={{color:'#ffd93d', fontSize:'0.95em', marginBottom:'0.35em'}}>VP Size *</div>
                                  <select value={vpSize} onChange={e=>setVpSize(e.target.value)} style={selectStyle}>
                                    <option value="">Select…</option>
                                    <option value="3">3x3 Matrix (Fast)</option>
                                    <option value="4">4x4 Matrix (High Stakes)</option>
                                  </select>
                                </div>
                                <div style={fieldWrapStyle}>
                                  <div style={{color:'#ffd93d', fontSize:'0.95em', marginBottom:'0.35em'}}>Entry Amount *</div>
                                  <input
                                    type="text"
                                    inputMode="decimal"
                                    value={entryAmount}
                                    onChange={e=>{
                                      const val = (e.target.value || '').replace(/,/g,'');
                                      // permit only digits and a single dot
                                      if (/^\d*(?:\.\d*)?$/.test(val) || val === '') setEntryAmount(val);
                                    }}
                                    placeholder="e.g., 0.1234"
                                    style={inputStyle}
                                  />
                                  <div style={{color:'#aaa', fontSize:'0.85em', marginTop:'0.3em'}}>
                                    We'll normalize to the token's decimals. Extra fractional digits are truncated.
                                  </div>
                                  <div style={{color:'#00ff88', fontSize:'0.85em', marginTop:'0.3em'}}>
                                    {(() => {
                                      const d = (tokenInfo?.decimals ?? 18);
                                      const raw = String(entryAmount || '').trim().replace(/,/g,'');
                                      if (!/^\d*(?:\.\d*)?$/.test(raw)) return '';
                                      let [ip, fp=''] = raw.split('.');
                                      if (!ip) ip = '0';
                                      if (!Number.isFinite(d)) return '';
                                      if (d <= 0) return `Preview: ${ip} tokens`;
                                      const fp2 = (fp||'').slice(0, d).padEnd(d, '0');
                                      return `Preview: ${ip}.${fp2} tokens`;
                                    })()}
                                  </div>
                                </div>
                              </div>
                              <div style={{textAlign:'center', marginTop:'1.0em'}}>
                                <button disabled={(() => { const addrOK = isValidAddress(tokenAddress); const accOK = !!account; const vpOK = !!vpSize; const d = (tokenInfo?.decimals ?? 18); const raw = String(entryAmount || '').trim(); if (!raw) return true; const cleaned = raw.replace(/,/g,''); if (!/^\d*(?:\.\d*)?$/.test(cleaned)) return true; let [ip, fp=''] = cleaned.split('.'); if (!ip) ip='0'; const fp2 = (Number.isFinite(d) && d>0) ? (fp||'').slice(0,d).padEnd(d,'0') : ''; const nonZero = (function(){ try { return (BigInt(ip||'0') > 0n) || /[1-9]/.test(fp2); } catch { return false; } })(); return busy || !accOK || !addrOK || !vpOK || !nonZero; })()} onClick={createMatrix} style={{background:'#000',border:'2px solid #00ff00',borderRadius:'1em',padding:'0.9em 2em',fontSize:'1.0em',fontWeight:'bold',color:'#00ff00',cursor: busy? 'wait':'pointer',textTransform:'uppercase',letterSpacing:'0.1em', opacity: (() => { const addrOK = isValidAddress(tokenAddress); const accOK = !!account; const vpOK = !!vpSize; const d = (tokenInfo?.decimals ?? 18); const raw = String(entryAmount || '').trim(); if (!raw) return 0.6; const cleaned = raw.replace(/,/g,''); if (!/^\d*(?:\.\d*)?$/.test(cleaned)) return 0.6; let [ip, fp=''] = cleaned.split('.'); if (!ip) ip='0'; const fp2 = (Number.isFinite(d) && d>0) ? (fp||'').slice(0,d).padEnd(d,'0') : ''; const nonZero = (function(){ try { return (BigInt(ip||'0') > 0n) || /[1-9]/.test(fp2); } catch { return false; } })(); return (busy || !accOK || !addrOK || !vpOK || !nonZero) ? 0.6 : 1; })()}}>
                                  {busy ? 'Auto-Deploying…' : 'ONE-CLICK DEPLOY'}
                                </button>
                              </div>
                              {status && (
                                <div style={{marginTop:'0.9em', padding:'0.8em 1em', borderRadius:'0.6em', border:'1px solid rgba(255,255,255,0.2)', background:'rgba(0,255,0,0.06)', color:'#00ff88'}}>{status}</div>
                              )}
                            </div>
                            {/* Removed informational "What happens?" box per request */}
                          </div>
                        </div>
                      );
                    }
                    return <FactoryCard/>;
                  })()
                ) : (
                  <div style={{
                    marginTop: '2em',
                    background: 'rgba(30,30,30,0.7)',
                    borderRadius: '1.2em',
                    padding: '2em 2.2em',
                    fontSize: '1.2em',
                    color: '#ffd93d',
                    boxShadow: '0 2px 8px #0004',
                    minWidth: '270px',
                    maxWidth: '350px',
                    marginLeft: 'auto',
                    marginRight: 'auto',
                    textAlign: 'center',
                    fontWeight: 500
                  }}>
                    {currentToken.desc}
                  </div>
                )}
                {/* Free claim button (matrix style) for PuMa-only with 1h cooldown) */}
                {currentToken.name && currentToken.name.includes('PuMa') && canClaimPuMa() && (
                  <div style={{
                    position: 'fixed',
                    right: '8vw',
                    bottom: 40,
                    transform: 'none',
                    zIndex: 9999,
                    width: 'auto',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'flex-end',
                    pointerEvents: 'auto'
                  }}>
                    <button
                      style={{
                        background: '#000',
                        color: '#00ff00',
                        border: '1.5px solid #00ff00',
                        borderRadius: '0.8em',
                        padding: '0.35em 1.1em',
                        fontSize: '0.95em',
                        fontWeight: 'bold',
                        cursor: 'pointer',
                        marginBottom: '2px',
                        zIndex: 201,
                        boxShadow: '0 6px 18px rgba(0,255,0,0.2)'
                      }}
                      onClick={freeClaimPuMa}
                      onMouseEnter={(e) => { e.target.style.background = 'rgba(0,255,0,0.10)'; }}
                      onMouseLeave={(e) => { e.target.style.background = '#000'; }}
                    >
                      free claim
                    </button>
                    <span style={{ fontSize: '0.7em', color: '#00ff00', opacity: 0.8, marginTop: '1px', fontWeight: 500 }}>1x/Hour</span>
                  </div>
                )}
                {currentToken.name && currentToken.name.includes('PuMa') && !canClaimPuMa() && (
                  <div style={{
                    position: 'fixed',
                    right: '8vw',
                    bottom: 40,
                    transform: 'none',
                    zIndex: 9999,
                    width: 'auto',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'flex-end',
                    pointerEvents: 'none',
                    opacity: 0.85
                  }}>
                    <button
                      style={{
                        background: '#111',
                        color: '#0f0',
                        border: '1.5px solid #0a0',
                        borderRadius: '0.8em',
                        padding: '0.35em 1.1em',
                        fontSize: '0.95em',
                        fontWeight: 'bold',
                        cursor: 'not-allowed',
                        opacity: 0.7,
                        marginBottom: '2px',
                        zIndex: 201,
                        boxShadow: '0 2px 8px #0008'
                      }}
                      disabled
                    >
                      free claim
                    </button>
                    <Countdown lastClaim={lastPuMaClaim} />
                  </div>
                )}
              </div>
            </div>
            {/* Support Development - fixed footer (always visible above content) */}
            <div style={{
              position: 'fixed',
              left: 0,
              bottom: 0,
              width: '100%',
              zIndex: 3000,
              background: 'rgba(0,0,0,0.35)',
              borderTop: '1px solid rgba(0,255,0,0.18)',
              backdropFilter: 'none',
              textAlign: 'center',
              fontFamily: 'monospace',
              padding: '0.25em 0.6em',
              boxSizing: 'border-box'
            }}>
              <span style={{color: '#9f9', fontSize: '0.9em', fontWeight: 'bold', marginRight: '0.6em', opacity: 0.9}}>
                Support Development:
              </span>
              <span style={{color: '#9f9', fontSize: '0.72em', wordBreak: 'break-all', letterSpacing: '0.03em', marginRight: '0.8em', opacity: 0.9}}>
                PLS: 0x24e9f5339551f94b54109b6ac7d71426c89ba211
              </span>
              <a href="https://t.me/PulseMatrix_app" target="_blank" rel="noopener noreferrer" style={{color: '#00ff00', fontSize: '0.9em', textDecoration: 'none'}}>
                📱 t.me/PulseMatrix_app
              </a>
            </div>

            {/* Developer Section is now shown directly under OPEN-card above */}
          </div>
        </>
      );
    }

    // --- EOL Timer Component 
    function EOLTimer({ carouselIdx, tokens, account }) {
      const [eolTime, setEolTime] = React.useState(null);
      const [minEntriesMet, setMinEntriesMet] = React.useState(false);
      const [now, setNow] = React.useState(Math.floor(Date.now() / 1000));
      const [eolMessage, setEolMessage] = React.useState('');

      React.useEffect(() => {
        const timer = setInterval(() => setNow(Math.floor(Date.now() / 1000)), 1000);
        return () => clearInterval(timer);
      }, []);

      // Keep hash updated with current page slug (avoid push for history spam)
      // But don't override an existing hash for a different page while tokens are still loading/reordering
      React.useEffect(() => {
        try {
          const currentSlug = slugifyToken(tokens[carouselIdx].name);
          const m = window.location.hash.match(/page=([^&]+)/i);
          const hashSlug = m && m[1] ? m[1].toLowerCase() : null;
          // If a hash exists and does NOT match the current selection, do not overwrite it here
          if (hashSlug && hashSlug !== currentSlug) return;
          const desired = '#page=' + currentSlug;
          if (window.location.hash !== desired) {
            history.replaceState(null, '', desired);
          }
        } catch {}
      }, [carouselIdx, tokens]);

      // Respond to manual hash changes / back-forward navigation
      React.useEffect(() => {
        function onHash(){
          try {
            const m = window.location.hash.match(/page=([^&]+)/i);
            const slug = m && m[1] ? m[1].toLowerCase() : '';
            if (slug && slug !== slugifyToken('Comprehensive Documentation & FAQ')) {
              defaultPageLockRef.current = false;
            }
          } catch {}
          setCarouselIdx(getIndexFromHash());
        }
        window.addEventListener('hashchange', onHash);
        return () => window.removeEventListener('hashchange', onHash);
      }, []);

      // Function to fetch a single vault row (used by ALL page)
      async function fetchVaultRow(index, cfg, force=false){
        if(!cfg || !cfg.vault || !cfg.token) return;
        if(!account && !force) return; // need account for allowance/balance
        try {
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const network = await provider.getNetwork();
          if (Number(network.chainId) !== 943 && Number(network.chainId) !== 369) return;
          const read = provider;
          const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], read);
          const tokenAbi = ["function allowance(address owner,address spender)view returns(uint256)","function balanceOf(address) view returns(uint256)","function decimals() view returns(uint8)"];
          const token = new ethers.Contract(cfg.token, tokenAbi, read);
          const [decimals, entryFee, payoutAmount, vBal, myStatus, allowance, userBal] = await Promise.all([
            (async()=>{try{return await token.decimals();}catch{return cfg.decimals||18;}})(),
            (async()=>{try{return await vault.ENTRY_FEE();}catch{return null;}})(),
            (async()=>{try{return await vault.PAYOUT_AMOUNT();}catch{return null;}})(),
            (async()=>{try{return await read.getBalance ? null : null;}catch{return null;}})(),
            (async()=>{try{return account? await vault.MY_STATUS({from:account}): null;}catch{return null;}})(),
            (async()=>{try{return account? await token.allowance(account,cfg.vault): null;}catch{return null;}})(),
            (async()=>{try{return account? await token.balanceOf(account): null;}catch{return null;}})()
          ]);
          // vaultBalance retrieval (if function exists)
          let vaultBalance = null;
          try { if (vault.vaultBalance) vaultBalance = await vault.vaultBalance(); } catch {}
          setAllVaultData(d => ({...d,[index]:{decimals, ENTRY_FEE:entryFee, PAYOUT_AMOUNT:payoutAmount, vaultBalance, myStatus, approvedLimit:allowance, userBalance:userBal}}));
        } catch {}
      }

      // Effect: load data for ALL page when opened or when account changes
      React.useEffect(()=>{
        if (tokens[carouselIdx] && tokens[carouselIdx].name === 'ALL') {
          tokens.forEach((t,i)=>{ if(t.matrixSize && t.config) fetchVaultRow(i,t.config); });
        }
      }, [carouselIdx, account]);

      React.useEffect(() => {
        async function fetchEOLTimeAndEntries() {
          if (!tokens[carouselIdx]?.config) {
            setEolTime(null);
            setMinEntriesMet(false);
            return;
          }
          if (!window.ethereum || !account) {
            setEolTime(null);
            setMinEntriesMet(false);
            return;
          }
          try {
            const cfg = tokens[carouselIdx].config;
            const abi = window.AllVaultABI && window.AllVaultABI[cfg.abiKey] ? window.AllVaultABI[cfg.abiKey] : [];
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const vault = new ethers.Contract(cfg.vault, abi, provider);
            const triggerTime = await vault.getEOLTriggerTime();
            if (triggerTime !== undefined && triggerTime !== null) {
              let n = 0;
              if (typeof triggerTime === 'object' && triggerTime._isBigNumber) n = Number(triggerTime.toString());
              else if (typeof triggerTime === 'string' || typeof triggerTime === 'number') n = Number(triggerTime);
              if (!isNaN(n) && n > 1000000000 && n < 9999999999) setEolTime(n); else setEolTime(null);
            } else {
              setEolTime(null);
            }
            let currentEntries = 0; let minEntries = 4;
            try { const nextTokenId = await vault.nextTokenId(); currentEntries = Number(nextTokenId) - 1; } catch {}
            try {
              if (vault.getMinEntriesForEOL) {
                const minEntriesFromContract = await vault.getMinEntriesForEOL();
                minEntries = Number(minEntriesFromContract);
              } else {
                const params = await vault.params();
                if (params && params.MIN_ENTRIES_FOR_EOL) minEntries = Number(params.MIN_ENTRIES_FOR_EOL);
              }
            } catch {}
            setMinEntriesMet(currentEntries >= minEntries);
          } catch (error) {
            setEolTime(null);
            setMinEntriesMet(false);
          }
        }
        fetchEOLTimeAndEntries();
      }, [carouselIdx, tokens, account]);

      async function triggerEOL() {
        if (!tokens[carouselIdx]?.config) return;
        try {
          const cfg = tokens[carouselIdx].config;
          const abi = window.AllVaultABI && window.AllVaultABI[cfg.abiKey] ? window.AllVaultABI[cfg.abiKey] : [];
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const signer = provider.getSigner();
          const vault = new ethers.Contract(cfg.vault, abi, signer);
          const fnName = 'triggerEOL';
          // Fetch actual trigger reward from contract for accurate UI
          let rewardAmount = null; let tokenSymbol = tokens[carouselIdx]?.name || 'tokens';
          try {
            const [bonusRaw, symMaybe] = await Promise.all([
              vault.EOLTriggerBonus ? vault.EOLTriggerBonus() : vault.ENTRY_FEE(),
              (async ()=>{ try { const t = await vault.TOKEN(); const erc = new ethers.Contract(t,["function symbol() view returns(string)","function decimals() view returns(uint8)"] , signer); const s=await erc.symbol().catch(()=>null); return s||tokenSymbol; } catch { return tokenSymbol; } })()
            ]);
            tokenSymbol = symMaybe || tokenSymbol;
            const decimals = cfg.decimals || 18;
            rewardAmount = parseFloat(ethers.utils.formatUnits(bonusRaw, decimals));
          } catch {}
          setEolMessage('Triggering EOL...');
          const tx = await vault[fnName]();
          setEolMessage('EOL transaction sent, waiting for confirmation...');
          await tx.wait();
          if (rewardAmount != null) setEolMessage(`🎉 You unlocked the matrix! Reward: ${rewardAmount.toFixed(4)} ${tokenSymbol}`);
          else setEolMessage(`🎉 You unlocked the matrix!`);
          setTimeout(() => { setEolMessage(''); }, 10000);
        } catch (error) {
          setEolMessage('EOL trigger failed: ' + (error?.message || error));
          setTimeout(() => { setEolMessage(''); }, 10000);
        }
      }

      if (!eolTime || isNaN(Number(eolTime))) {
        return (
          <div style={{position:'relative'}}>
            <span style={{cursor:'not-allowed',opacity:0.5}} title="EOL not available">🪠</span>
            <span style={{color:'white',fontSize:'0.6em',fontWeight:500,marginLeft:'0.2em'}}>-</span>
            {eolMessage && (
              <div style={{position:'absolute',top:'100%',left:'50%',transform:'translateX(-50%)',background:'rgba(0,0,0,0.9)',color:'#fff',padding:'0.5em',borderRadius:'0.5em',fontSize:'0.8em',whiteSpace:'nowrap',zIndex:1000,marginTop:'0.2em'}}>
                {eolMessage}
              </div>
            )}
          </div>
        );
      }

  const secondsLeft = Number(eolTime) - now;
  const timeReached = secondsLeft <= 0;
  const canTrigger = timeReached && minEntriesMet;

      if (timeReached && !minEntriesMet) {
        return (
          <div style={{position:'relative'}}>
            <span style={{cursor:'not-allowed',opacity:0.5}} title="EOL time reached but not enough entries for trigger">🪠</span>
            <span style={{color:'white',fontSize:'0.6em',fontWeight:500,marginLeft:'0.2em'}}>0:00</span>
            {eolMessage && (
              <div style={{position:'absolute',top:'100%',left:'50%',transform:'translateX(-50%)',background:'rgba(0,0,0,0.9)',color:'#fff',padding:'0.5em',borderRadius:'0.5em',fontSize:'0.8em',whiteSpace:'nowrap',zIndex:1000,marginTop:'0.2em'}}>
                {eolMessage}
              </div>
            )}
          </div>
        );
      }

      if (canTrigger) {
        return (
          <div style={{position:'relative'}}>
            <span style={{cursor:'pointer'}} title="Unclog the matrix" onClick={triggerEOL}>🪠</span>
            <span style={{color:'white',fontSize:'0.6em',fontWeight:500,marginLeft:'0.2em',cursor:'pointer'}} onClick={triggerEOL} title="Unclog the matrix">0:00 💛</span>
            {eolMessage && (
              <div style={{position:'absolute',top:'100%',left:'50%',transform:'translateX(-50%)',background:'rgba(0,0,0,0.9)',color:'#fff',padding:'0.5em',borderRadius:'0.5em',fontSize:'0.8em',whiteSpace:'nowrap',zIndex:1000,marginTop:'0.2em'}}>
                {eolMessage}
              </div>
            )}
          </div>
        );
      }

      let display = '';
      if (secondsLeft >= 86400) {
        const days = Math.floor(secondsLeft / 86400);
        const hours = Math.floor((secondsLeft % 86400) / 3600);
        display = `${days}d ${hours}h`;
      } else if (secondsLeft >= 3600) {
        const hours = Math.floor(secondsLeft / 3600);
        const min = Math.floor((secondsLeft % 3600) / 60);
        display = `${hours}:${min.toString().padStart(2,'0')}`;
      } else {
        const min = Math.floor(secondsLeft / 60);
        const sec = secondsLeft % 60;
        display = `${min}:${sec.toString().padStart(2,'0')}`;
      }
      return (
        <div style={{position:'relative'}}>
          <span style={{cursor:'not-allowed',opacity:0.5}} title="EOL timer running - wait for 0:00">🪠</span>
          <span style={{color:'white',fontSize:'0.6em',fontWeight:500,marginLeft:'0.2em'}}>{display}</span>
          {eolMessage && (
            <div style={{position:'absolute',top:'100%',left:'50%',transform:'translateX(-50%)',background:'rgba(0,0,0,0.9)',color:'#fff',padding:'0.5em',borderRadius:'0.5em',fontSize:'0.8em',whiteSpace:'nowrap',zIndex:1000,marginTop:'0.2em'}}>
              {eolMessage}
            </div>
          )}
        </div>
      );
    }

    // --- HISTORY Section  ---
    function HistorySection({ carouselIdx, tokens, account, refreshStats }) {
      const [expanded, setExpanded] = React.useState(false);
      const [historyData, setHistoryData] = React.useState([]);
      const [loading, setLoading] = React.useState(false);
      const [userHasTokens, setUserHasTokens] = React.useState(false);
      const [hideClosed, setHideClosed] = React.useState(false);
      const [page, setPage] = React.useState(0);
      const PER_PAGE = 25;

  function getColorEmoji(colorStatus) {
        switch(Number(colorStatus)) {
          case 0: return '💚';
          case 1: return '💛';
          case 2: return '🧡';
          case 3: return '❤️';
          default: return '💚';
        }
      }
      function getColorDescription(colorStatus) {
        switch(Number(colorStatus)) {
          case 0: return 'Active';
          case 1: return 'Ready';
          case 2: return 'Auto-payable';
          case 3: return 'Paid';
          default: return 'Active';
        }
      }
      function maskAddress(address) {
        if (!address || address === 'Unknown' || address === 'YOU' || address === 'Burned') return address;
        if (address.startsWith('0x') && address.length === 42) return `${address.slice(0,6)}...${address.slice(-4)}`;
        if (address.includes('...')) return address;
        return address.length > 10 ? `${address.slice(0,6)}...${address.slice(-4)}` : address;
      }

      React.useEffect(() => {
        async function fetchHistory() {
          setLoading(true);
          setHistoryData([]);
          setUserHasTokens(false);
          if (!tokens[carouselIdx]?.config || !account) { setLoading(false); return; }
          try {
            const cfg = tokens[carouselIdx].config;
            // Use wallet on Pulse networks or fall back to Testnet V4 RPC
            let provider = null;
            if (window.ethereum) {
              try { const wp = new ethers.providers.Web3Provider(window.ethereum); const net = await wp.getNetwork(); const cid = Number(net.chainId); if (cid === 943 || cid === 369) provider = wp; } catch {}
            }
            if (!provider) provider = new ethers.providers.JsonRpcProvider((window.PULSE_RPC && window.PULSE_RPC[943]) || 'https://rpc.v4.testnet.pulsechain.com');
            const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);

            let receipt = null;
            try {
              const addr = await vault.getReceiptContract();
              const abi = ["function balanceOf(address account, uint256 id) view returns (uint256)"];
              receipt = new ethers.Contract(addr, abi, provider);
            } catch {}

            // Helper: format to exactly 2 decimals with rounding
            function to2DecStr(str){
              try {
                if (str == null) return null;
                if (typeof str !== 'string') str = String(str);
                if (!str.includes('.')) return str + '.00';
                const parts = str.split('.');
                let intPart = parts[0];
                const frac0 = (parts[1] || '').padEnd(3, '0');
                const third = Number(frac0[2] || '0');
                let two = frac0.slice(0,2);
                if (third >= 5) {
                  let twoNum = Number(two) + 1;
                  if (twoNum >= 100) { intPart = String(BigInt(intPart) + 1n); two = '00'; }
                  else two = String(twoNum).padStart(2,'0');
                }
                return `${intPart}.${two}`;
              } catch { return str; }
            }
            const fmtBN2 = (bn) => {
              try { return to2DecStr(ethers.utils.formatUnits(bn, cfg.decimals || 18)); } catch { return null; }
            };

            // Matrix context for this vault
            const matrixSize = tokens[carouselIdx].name.includes('3x3') ? 3 : 4;
            const FULL_VP_SIZE = getVPStructureSize(matrixSize);

            // Build a map of tokenId -> amount from EOLPaid events (actual paid at EOL)
            const eolPaidAmountMap = new Map();
            try {
              const filter = vault.filters.EOLPaid();
              const logs = await vault.queryFilter(filter, 0, 'latest');
              for (const log of logs) {
                const tokenId = Number(log.args.tokenId);
                const amount = log.args.amount; // BigNumber
                eolPaidAmountMap.set(tokenId, amount);
              }
            } catch {}

            // Build a map of leader tokenId -> amount from Paid events (normal auto-pay of VP leader)
            const paidLeaderAmountMap = new Map();
            try {
              const filterPaid = vault.filters.Paid();
              const paidLogs = await vault.queryFilter(filterPaid, 0, 'latest');
              for (const log of paidLogs) {
                const vpId = Number(log.args.vpId);
                const amount = log.args.amount; // BigNumber
                const leaderTokenId = (vpId - 1) * FULL_VP_SIZE + 1;
                paidLeaderAmountMap.set(leaderTokenId, amount);
              }
            } catch {}

            const entries = [];
            let userHasAny = false;
            let nextId = 1;
            try { nextId = Number(await vault.nextTokenId()); } catch {}
            const totalEntries = Math.max(0, nextId - 1);

            // Pull EOL info for cycle-aware rendering
            let eolCycleCount = 0;
            let lastEOLTriggerEntry = 0;
            try { eolCycleCount = Number(await vault.EOLCycleCount()); } catch {}
            if (eolCycleCount > 0 && vault.EOLTriggerAtEntryId) {
              try { lastEOLTriggerEntry = Number(await vault.EOLTriggerAtEntryId(eolCycleCount)); } catch {}
            }

            // Pull payout amount once (for normal auto-pay entries)
            let payoutAmountWei = null;
            try { payoutAmountWei = await vault.PAYOUT_AMOUNT(); } catch {}

            for (let tokenId = 1; tokenId <= totalEntries; tokenId++) {
              try {
                let owner = 'Unknown'; let isUserToken = false; let foundOwner = false;
                if (receipt) {
                  try {
                    const bal = await receipt.balanceOf(account, tokenId);
                    if (bal && bal.toString() !== '0') {
                      owner = 'YOU'; isUserToken = true; userHasAny = true; foundOwner = true;
                    } else { owner = 'Other User'; foundOwner = true; }
                  } catch {}
                }

                let status = 0; // default active
                let paidAmount = null; // string when known
                let paidFlag = false;
                try { paidFlag = await vault.isPaid(tokenId); } catch {}
                if (paidFlag) {
                  status = 3;
                  if (!foundOwner) owner = 'Burned';
                } else {
                  let canAutoPayNow = false; try { canAutoPayNow = await vault.canAutoPay(tokenId); } catch {}
                  if (canAutoPayNow) status = 2; else status = 0;
                  if (!foundOwner) owner = 'Unknown';
                }

                const preEOL = (eolCycleCount > 0) && (tokenId <= (lastEOLTriggerEntry || 0));
                let payPoint;
                if (preEOL && lastEOLTriggerEntry) {
                  payPoint = lastEOLTriggerEntry; // show EOL trigger point for closed entries
                } else {
                  payPoint = getEntryPaymentPoint(tokenId, matrixSize, lastEOLTriggerEntry || 0);
                }
                // Compute paid flag: true if contract says paid, or (preEOL and receipt burned for original owner)
                let isPaid = !!paidFlag;
                if (!isPaid && preEOL && receipt && vault.tokenOwner) {
                  try {
                    const ownerAddr = await vault.tokenOwner(tokenId);
                    if (ownerAddr && ownerAddr !== '0x0000000000000000000000000000000000000000') {
                      const rbalOwner = await receipt.balanceOf(ownerAddr, tokenId);
                      if (rbalOwner && rbalOwner.toString() === '0') {
                        isPaid = true; // receipt burned in EOL payout
                      }
                    }
                  } catch {}
                }

        // Determine actual paid amount (prefer EOLPaid event amount; else fallback to PAYOUT_AMOUNT for auto-pays)
                if (isPaid) {
                  try {
                    if (eolPaidAmountMap.has(tokenId)) {
                      const amt = eolPaidAmountMap.get(tokenId);
          paidAmount = fmtBN2(amt);
                    } else if (paidLeaderAmountMap.has(tokenId)) {
                      const amt = paidLeaderAmountMap.get(tokenId);
          paidAmount = fmtBN2(amt);
                    } else if (paidFlag) {
                      const p = payoutAmountWei || await vault.PAYOUT_AMOUNT();
          paidAmount = fmtBN2(p);
                    } else if (preEOL) {
                      // EOL-paid but event not found (edge); show fallback so it's numeric
                      const p = payoutAmountWei || await vault.PAYOUT_AMOUNT();
          paidAmount = fmtBN2(p);
                    }
                  } catch {}
                }

                entries.push({ tokenId, status, owner, paidAmount, payPoint, isUserToken, preEOL, isPaid });
              } catch {}
            }

            entries.sort((a,b) => b.tokenId - a.tokenId);
            setHistoryData(entries);
            setUserHasTokens(userHasAny);
          } catch {}
          setLoading(false);
        }
        fetchHistory();
      }, [carouselIdx, account, refreshStats]);

      if (!tokens[carouselIdx].config) {
        return null;
      }

      const handleExpand = () => { if (userHasTokens) setExpanded(!expanded); };

  // Apply optional filter to hide closed/paid entries
  // When hideClosed is true, exclude entries where isPaid is true
  const visibleHistoryData = hideClosed ? historyData.filter(e => !e.isPaid) : historyData;
  const totalPages = Math.max(1, Math.ceil(visibleHistoryData.length / PER_PAGE));
  // Clamp page if data shrinks
  React.useEffect(() => {
    const tp = Math.max(1, Math.ceil(visibleHistoryData.length / PER_PAGE));
    if (page >= tp) setPage(Math.max(0, tp - 1));
  }, [visibleHistoryData.length]);
  const startIdx = Math.min(page, totalPages - 1) * PER_PAGE;
  const pagedHistoryData = visibleHistoryData.slice(startIdx, startIdx + PER_PAGE);
  const canPrev = page > 0;
  const canNext = page < (totalPages - 1);

      // Title aligned with OPEN/DEV width
      return (
        <>
          <div style={{fontWeight:400, fontSize:'1.2em', color:'#00ff00', textAlign:'left', letterSpacing:'0.01em', display:'flex', alignItems:'center', justifyContent:'space-between', width:'75%', boxSizing:'border-box', marginLeft:'auto', marginRight:'auto', marginBottom:'0.5em'}}>
            <span>History:</span>
            <span 
              onClick={handleExpand}
              style={{cursor: userHasTokens ? 'pointer' : 'not-allowed', fontSize:'0.9em', color: userHasTokens ? '#00ff00' : '#006600', userSelect:'none'}}
              title={expanded ? 'Collapse' : (userHasTokens ? 'Expand' : 'Connect & join to enable')}
            >{expanded ? '▼ Collapse' : '▶ Expand'}</span>
          </div>
          <div className="HISTORY-card">
            <div style={{paddingLeft:'5%'}}>
              {!expanded && (
                <div
                  style={{color:'#00ff00', fontSize:'1.05em', cursor: userHasTokens ? 'pointer' : 'not-allowed', padding:'18px'}}
                  onClick={() => userHasTokens && setExpanded(true)}
                >
                  🔍 Click to view your entry history.
                  <div style={{fontSize:'0.85em', color:'#888', marginTop:'6px'}}></div>
                </div>
              )}
              {expanded && (
                <div>
                  <div style={{marginBottom:'0.8em',color:'#00ff00',fontSize:'1em',fontWeight:500,display:'flex',justifyContent:'space-between',alignItems:'center'}}>
                    <span>Your entries: {historyData.filter(e => e.isUserToken).length}</span>
                    <span
                      onClick={() => { setHideClosed(v => !v); setPage(0); }}
                      title={hideClosed ? 'Show closed entries' : 'Hide closed entries'}
                      style={{cursor:'pointer',fontSize:'0.85em',color:'#ccc',textDecoration:'underline'}}
                    >{hideClosed ? 'show ❤️' : 'hide ❤️'}</span>
                  </div>
                    {loading ? (
                    <div style={{color:'#00ff00'}}>Loading...</div>
                  ) : historyData.length === 0 ? (
                    <div style={{color:'#00ff00'}}>No entry history found.</div>
                  ) : (
                    <div>
                      <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',padding:'0.5em 0',borderBottom:'1px solid #444',marginBottom:'0.5em'}}>
                        <div style={{display:'grid',gridTemplateColumns:'60px 80px 120px 100px 90px',gap:'0.5em',fontSize:'0.8em',fontWeight:600,color:'#ccc'}}>
                          <div>ID</div>
                          <div>Status</div>
                          <div>Address</div>
                          <div>Paid</div>
                          <div>Auto-pay point</div>
                        </div>
                        <div style={{display:'flex',alignItems:'center',gap:'0.8em'}}>
                          {/* Simple pager: < 1/N > */}
                          <span
                            onClick={() => canPrev && setPage(p => Math.max(0, p - 1))}
                            style={{cursor: canPrev ? 'pointer' : 'not-allowed', opacity: canPrev ? 1 : 0.4, userSelect:'none'}}
                            title={canPrev ? 'Previous page' : ''}
                          >&lt;</span>
                          <span style={{fontSize:'0.85em', color:'#ccc'}}>{Math.min(page + 1, totalPages)}/{totalPages}</span>
                          <span
                            onClick={() => canNext && setPage(p => Math.min(totalPages - 1, p + 1))}
                            style={{cursor: canNext ? 'pointer' : 'not-allowed', opacity: canNext ? 1 : 0.4, userSelect:'none'}}
                            title={canNext ? 'Next page' : ''}
                          >&gt;</span>
                          <EOLTimer carouselIdx={carouselIdx} tokens={tokens} account={account} />
                        </div>
                      </div>
                      <div>
                        {pagedHistoryData.map((entry, idx) => (
                          <div key={entry.tokenId} style={{
                            display:'grid', gridTemplateColumns:'60px 80px 120px 100px 90px', gap:'0.5em', padding:'0.4em 0', borderBottom: idx < pagedHistoryData.length - 1 ? '1px solid #333' : 'none', fontSize:'0.85em', background: entry.isUserToken ? 'rgba(0,255,136,0.05)' : 'transparent', borderRadius: entry.isUserToken ? '0.3em' : '0'
                          }}>
                            <div style={{fontWeight: entry.isUserToken ? 600 : 400, color: entry.isUserToken ? '#00ff88' : '#fff'}}>#{entry.tokenId}</div>
                            <div style={{display:'flex',alignItems:'center',gap:'0.3em'}}>
                              <span>{entry.preEOL ? '❤️' : getColorEmoji(entry.status)}</span>
                              <span style={{fontSize:'0.8em'}}>{entry.preEOL ? 'Closed' : getColorDescription(entry.status)}</span>
                            </div>
                            <div style={{fontSize:'0.8em',fontFamily:'monospace'}}>
                              {entry.owner === 'YOU' ? <span style={{color:'#00ff88',fontWeight:600}}>YOU</span> : (entry.owner === 'Burned' ? <span style={{color:'#ff6b6b',fontStyle:'italic'}}>🔥 Burned</span> : <span style={{color: entry.owner === 'Unknown' ? '#888' : '#fff'}}>{maskAddress(entry.owner)}</span>)}
                            </div>
                            <div style={{fontSize:'0.8em'}}>{entry.isPaid && entry.paidAmount ? entry.paidAmount : (entry.isPaid ? '-' : '-')}</div>
                            <div style={{textAlign:'center',fontWeight:600,color:'#fbbf24'}}>{entry.payPoint}</div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </>
      );
    }

    // --- Matrix Visualizer
    function MatrixVisualizer({ carouselIdx, tokens, account }) {
      const canvasRef = React.useRef(null);
      const [vpData, setVpData] = React.useState([]); 
      const [connectionData, setConnectionData] = React.useState([]);
      const [lastTokenId, setLastTokenId] = React.useState(0);
      const [isLoading, setIsLoading] = React.useState(false);
      const [currentView, setCurrentView] = React.useState('2d');
      const [lastEOL, setLastEOL] = React.useState(null);
      const [userOwnedIds, setUserOwnedIds] = React.useState(new Set());
  const userOwnedIdsRef = React.useRef(new Set());

      const zoomRef = React.useRef(1);
      const offsetXRef = React.useRef(0);
      const offsetYRef = React.useRef(0);
      const isDraggingRef = React.useRef(false);
      const lastMouseXRef = React.useRef(0);
      const lastMouseYRef = React.useRef(0);
      const rotationXRef = React.useRef(0);
      const rotationYRef = React.useRef(0);
      const lastProjectedRef = React.useRef([]);
  // Centering flags so we only auto-center once per view after data/load or view switch
  const centered2DRef = React.useRef(false);
  const centered3DRef = React.useRef(false);

      const matrixSize = tokens[carouselIdx].name.includes('3x3') ? 3 : 4;

      React.useEffect(() => { if (account && tokens[carouselIdx].config) loadMatrixData(); }, [account, carouselIdx]);

      // Ensure canvas internal resolution matches CSS size (and devicePixelRatio) to avoid cursor offset
      React.useEffect(() => {
        function resizeCanvas(){
          const canvas = canvasRef.current; if(!canvas) return;
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          const displayWidth = Math.floor(rect.width * dpr);
            const displayHeight = Math.floor(rect.height * dpr);
          if(canvas.width !== displayWidth || canvas.height !== displayHeight){
            canvas.width = displayWidth; canvas.height = displayHeight;
          }
          // We render in logical CSS pixels, so adjust context scale for DPR once (exclude zoom which is handled separately)
          const ctx = canvas.getContext('2d');
          ctx.setTransform(1,0,0,1,0,0); // reset
          ctx.scale(dpr, dpr);
          render();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        return ()=> window.removeEventListener('resize', resizeCanvas);
      }, [currentView]);

      React.useEffect(() => {
        const canvas = canvasRef.current; if (!canvas) return;
        canvas.width = 560; canvas.height = 400;
        const cleanup = setupMouseEvents(canvas);
        render();
        return cleanup;
  }, [vpData, connectionData, currentView]);

  // Keep ref in sync so event handlers (wheel/pan) see latest ownership without re-binding
  React.useEffect(() => { userOwnedIdsRef.current = userOwnedIds; if(vpData.length>0) render(); }, [userOwnedIds]);

      async function loadMatrixData() {
        if (!account || !tokens[carouselIdx].config) return;
        setIsLoading(true);
        try {
          const cfg = tokens[carouselIdx].config;
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const contract = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);
          const nextTokenId = await contract.nextTokenId();
          const maxTokenId = Number(nextTokenId) - 1;
          setLastTokenId(maxTokenId);
          // Fetch last EOL trigger (completed cycle) properly (only entries AFTER this form current matrix)
          let eolId = 0;
            try {
              if (contract.EOLCycleCount && contract.EOLTriggerAtEntryId) {
                const cycleCountRaw = await contract.EOLCycleCount();
                const cycleCount = Number(cycleCountRaw);
                if (cycleCount > 0) {
                  // Mapping indexed by cycle count (same pattern used in History section)
                  const trig = await contract.EOLTriggerAtEntryId(cycleCount);
                    const tNum = Number(trig);
                    if (!isNaN(tNum) && tNum > 0) eolId = tNum;
                }
              }
            } catch {}
          setLastEOL(eolId);
          if (maxTokenId <= 0 || (eolId > 0 && maxTokenId <= eolId)) { // nothing in current cycle
            setVpData([]); setConnectionData([]); setIsLoading(false); return; }
          const result = generateVPStructure(maxTokenId, matrixSize, eolId);
          let positions = currentView === '2d' ? calculate2DLayout(result.positions, 560, 400) : calculate3DLayout(result.positions);
          setVpData(positions);
          setConnectionData(result.connections);
          // Fetch user-owned IDs in current cycle (open entries) for blue highlighting
          try {
            if (account) {
              const cfg = tokens[carouselIdx].config;
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const contract = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);
              const receiptAddr = await contract.getReceiptContract();
              const rc = new ethers.Contract(receiptAddr, ["function balanceOf(address, uint256) view returns (uint256)"], provider);
              const ids = positions.map(p=>p.id);
              const balanceCalls = await Promise.all(ids.map(async id=>{ try { const b=await rc.balanceOf(account,id); return {id, owned: b && b.toString() !== '0'}; } catch{ return {id, owned:false}; }}));
              setUserOwnedIds(new Set(balanceCalls.filter(x=>x.owned).map(x=>x.id)));
            } else setUserOwnedIds(new Set());
          } catch { setUserOwnedIds(new Set()); }
        } catch {
          setVpData([]); setConnectionData([]);
        }
        setIsLoading(false);
      }

  function generateVPStructure(maxPosition, matrixSize, eolIdInput) {
        const positions = []; const connections = [];
        const eol = eolIdInput && Number(eolIdInput) > 0 ? Number(eolIdInput) : 0;
        const startId = eol > 0 ? eol + 1 : 1;
        if (maxPosition < startId) return { positions: [], connections: [] };
        for (let currentPosition = startId; currentPosition <= maxPosition; currentPosition++) {
          const relative = currentPosition - eol; // relative position in the active cycle
          let parent = null;
            if (relative > 1) {
              const parentRelative = Math.floor((relative + matrixSize - 2) / matrixSize); // same formula but relative
              parent = eol + parentRelative; // convert back to global id
            }
          // level computed from relative index
          let level = 1, levelStart = 1, levelSize = 1;
          while (relative > levelStart + levelSize - 1) { levelStart += levelSize; levelSize *= matrixSize; level++; }
          positions.push({ id: currentPosition, level, x:0,y:0,z:0, parent });
          if (parent !== null) connections.push({ from: parent, to: currentPosition });
        }
        return { positions, connections };
      }

      function calculate2DLayout(positions, canvasWidth, canvasHeight) {
        const levels = {}; const centerX = canvasWidth/2; const centerY = canvasHeight/2;
        positions.forEach(pos => { if (!levels[pos.level]) levels[pos.level] = []; levels[pos.level].push(pos); });
        const totalLevels = Math.max(...Object.keys(levels).map(Number));
        function calculateRadius(level, totalLevels) {
          if (level === 1) return 0; const availableSpace = Math.min(centerX, centerY) - 20; const levelCount = totalLevels - 1; if (levelCount <= 1) return 30; const compressionFactor = 0.8; let totalWeight = 0; for (let i=1;i<=levelCount;i++){ totalWeight += Math.pow(compressionFactor, levelCount - i);} let weightSum=0; for(let i=1;i<level;i++){ weightSum += Math.pow(compressionFactor, levelCount - i);} return Math.max(30, (weightSum/totalWeight)*availableSpace);
        }
        Object.keys(levels).forEach(levelNum => {
          const level = parseInt(levelNum); const levelPositions = levels[level];
          if (level === 1) { levelPositions[0].x = centerX; levelPositions[0].y = centerY; }
          else { const radius = calculateRadius(level, totalLevels); const baseAngleSpacing = (2*Math.PI)/Math.pow(matrixSize, level-1); const parentGroups = {}; levelPositions.forEach(pos => { const parentId = pos.parent; if (!parentGroups[parentId]) parentGroups[parentId] = []; parentGroups[parentId].push(pos); }); Object.keys(parentGroups).forEach(parentId => { const group = parentGroups[parentId]; if (group.length === 0) return; const parent = positions.find(p => p.id === parseInt(parentId)); if (!parent) return; const parentAngle = Math.atan2(parent.y - centerY, parent.x - centerX); const outwardDirection = parentAngle; group.sort((a,b)=>a.id-b.id); group.forEach((pos, siblingIndex) => { let childAngle; if (matrixSize === 3) { if (siblingIndex === 1) { childAngle = outwardDirection; } else { const offset = (siblingIndex === 0) ? -baseAngleSpacing : baseAngleSpacing; childAngle = outwardDirection + offset; } } else { const offset = (siblingIndex - 1.5) * baseAngleSpacing; childAngle = outwardDirection + offset; } pos.x = centerX + radius * Math.cos(childAngle); pos.y = centerY + radius * Math.sin(childAngle); }); }); }
        });
        return positions;
      }

      function calculate3DLayout(positions, radius = 60) {
        const levels = {};
        positions.forEach(pos => { if (!levels[pos.level]) levels[pos.level] = []; levels[pos.level].push(pos); });
        const maxLevel = Math.max(...Object.keys(levels).map(Number));
  const vpStatus = getCompleteVPPositions(positions);
        const completeVPPositions = new Set();
        vpStatus.complete.forEach(topId => {
          completeVPPositions.add(topId);
          const children = positions.filter(p => p.parent === topId);
            children.forEach(child => {
              completeVPPositions.add(child.id);
              const grandchildren = positions.filter(p => p.parent === child.id);
              grandchildren.forEach(gc => completeVPPositions.add(gc.id));
            });
        });
        let focusLevel = maxLevel;
        for (let level = 1; level <= maxLevel; level++) {
          const levelPositions = positions.filter(p => p.level === level);
          const hasActive = levelPositions.some(p => !completeVPPositions.has(p.id));
          if (hasActive) { focusLevel = level; break; }
        }
        const totalLevels = Math.max(...Object.keys(levels).map(Number));
        function calculateShellRadius(level, totalLevels, baseRadius) {
          if (level === 1) return 0;
          const maxShellRadius = baseRadius * 5;
          const levelCount = totalLevels - 1;
          if (levelCount <= 1) return baseRadius;
          const compressionFactor = 0.75;
          let totalWeight=0; for(let i=1;i<=levelCount;i++){ totalWeight += Math.pow(compressionFactor, levelCount - i);} let weightSum=0; for(let i=1;i<level;i++){ weightSum += Math.pow(compressionFactor, levelCount - i);} return Math.max(baseRadius, (weightSum/totalWeight)*maxShellRadius);
        }
        Object.keys(levels).forEach(levelNum => {
          const level = parseInt(levelNum);
          const levelPositions = levels[level];
          if (level === 1) {
            levelPositions[0].x = 0; levelPositions[0].y = 0; levelPositions[0].z = 0;
          } else {
            const shellRadius = calculateShellRadius(level, totalLevels, radius);
            levelPositions.forEach((pos, index) => {
              const parent = positions.find(p => p.id === pos.parent);
              const siblings = positions.filter(p => p.parent === pos.parent);
              const siblingIndex = siblings.findIndex(s => s.id === pos.id);
              if (parent && siblings.length === matrixSize) {
                let directionVector = { x:0, y:0, z:1 };
                if (parent.parent) {
                  const grandmother = positions.find(p => p.id === parent.parent);
                  if (grandmother) {
                    const len = Math.sqrt(Math.pow(parent.x-grandmother.x,2)+Math.pow(parent.y-grandmother.y,2)+Math.pow(parent.z-grandmother.z,2));
                    if (len>0) directionVector = { x:(parent.x-grandmother.x)/len, y:(parent.y-grandmother.y)/len, z:(parent.z-grandmother.z)/len };
                  }
                } else if (level === 2) {
                  const len = Math.sqrt(parent.x*parent.x + parent.y*parent.y + parent.z*parent.z);
                  if (len>0) directionVector = { x:parent.x/len, y:parent.y/len, z:parent.z/len };
                }
                if (matrixSize === 3) {
                  if (level === 2) {
                    const triangleRadius = shellRadius;
                    const angle = (2*Math.PI/3) * siblingIndex;
                    pos.x = triangleRadius*Math.cos(angle);
                    pos.y = triangleRadius*Math.sin(angle);
                    pos.z = 0;
                  } else {
                    let perpVector1 = { x:0, y:1, z:0 }; if (Math.abs(directionVector.y)>0.9) perpVector1 = { x:1, y:0, z:0 };
                    let cross1 = { x: directionVector.y*perpVector1.z - directionVector.z*perpVector1.y, y: directionVector.z*perpVector1.x - directionVector.x*perpVector1.z, z: directionVector.x*perpVector1.y - directionVector.y*perpVector1.x };
                    let len1 = Math.sqrt(cross1.x*cross1.x + cross1.y*cross1.y + cross1.z*cross1.z); if (len1>0){ cross1.x/=len1; cross1.y/=len1; cross1.z/=len1; }
                    let cross2 = { x: directionVector.y*cross1.z - directionVector.z*cross1.y, y: directionVector.z*cross1.x - directionVector.x*cross1.z, z: directionVector.x*cross1.y - directionVector.y*cross1.x };
                    const triangleRadius = shellRadius*0.15; const angle=(2*Math.PI/3)*siblingIndex; const triX=triangleRadius*Math.cos(angle); const triY=triangleRadius*Math.sin(angle); const extensionDistance = shellRadius*0.05; const triCenter = { x: parent.x + directionVector.x*extensionDistance, y: parent.y + directionVector.y*extensionDistance, z: parent.z + directionVector.z*extensionDistance };
                    const childPos = { x: triCenter.x + triX*cross1.x + triY*cross2.x, y: triCenter.y + triX*cross1.y + triY*cross2.y, z: triCenter.z + triX*cross1.z + triY*cross2.z };
                    const dist = Math.sqrt(childPos.x*childPos.x + childPos.y*childPos.y + childPos.z*childPos.z); const scale = shellRadius/dist; pos.x = childPos.x*scale; pos.y = childPos.y*scale; pos.z = childPos.z*scale;
                  }
                } else if (matrixSize === 4) {
                  if (level === 2) {
                    const squareRadius = shellRadius; const angle=(Math.PI/2)*siblingIndex; pos.x = squareRadius*Math.cos(angle); pos.y = squareRadius*Math.sin(angle); pos.z = 0;
                  } else {
                    let perpVector1 = { x:0, y:1, z:0 }; if (Math.abs(directionVector.y)>0.9) perpVector1 = { x:1, y:0, z:0 };
                    let cross1 = { x: directionVector.y*perpVector1.z - directionVector.z*perpVector1.y, y: directionVector.z*perpVector1.x - directionVector.x*perpVector1.z, z: directionVector.x*perpVector1.y - directionVector.y*perpVector1.x };
                    let len1 = Math.sqrt(cross1.x*cross1.x + cross1.y*cross1.y + cross1.z*cross1.z); if (len1>0){ cross1.x/=len1; cross1.y/=len1; cross1.z/=len1; }
                    let cross2 = { x: directionVector.y*cross1.z - directionVector.z*cross1.y, y: directionVector.z*cross1.x - directionVector.x*cross1.z, z: directionVector.x*cross1.y - directionVector.y*cross1.x };
                    const squareRadius = shellRadius*0.15; const angle=(Math.PI/2)*siblingIndex; const sqX=squareRadius*Math.cos(angle); const sqY=squareRadius*Math.sin(angle); const extensionDistance=shellRadius*0.05; const sqCenter={ x: parent.x + directionVector.x*extensionDistance, y: parent.y + directionVector.y*extensionDistance, z: parent.z + directionVector.z*extensionDistance };
                    const childPos={ x: sqCenter.x + sqX*cross1.x + sqY*cross2.x, y: sqCenter.y + sqX*cross1.y + sqY*cross2.y, z: sqCenter.z + sqX*cross1.z + sqY*cross2.z };
                    const dist=Math.sqrt(childPos.x*childPos.x + childPos.y*childPos.y + childPos.z*childPos.z); const scale=shellRadius/dist; pos.x=childPos.x*scale; pos.y=childPos.y*scale; pos.z=childPos.z*scale;
                  }
                }
              } else {
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                const theta = goldenAngle * index;
                const y = 1 - (index / Math.max(1,(levelPositions.length - 1))) * 2;
                const radiusAtY = Math.sqrt(Math.max(0,1 - y*y));
                const x = Math.cos(theta)*radiusAtY; const z = Math.sin(theta)*radiusAtY;
                pos.x = x*shellRadius; pos.y = y*shellRadius; pos.z = z*shellRadius;
              }
            });
          }
        });
        return positions;
      }

      function project3DTo2D(x,y,z,canvasWidth,canvasHeight){
        // canvasWidth/Height should be logical (CSS pixel) dimensions for consistent positioning
        const cos1=Math.cos(rotationYRef.current), sin1=Math.sin(rotationYRef.current), cos2=Math.cos(rotationXRef.current), sin2=Math.sin(rotationXRef.current);
        const x1=x*cos1 - z*sin1; const z1=x*sin1 + z*cos1; const y2=y*cos2 - z1*sin2; const z2=y*sin2 + z1*cos2;
        const distance=800; const perspective=distance/(distance+z2);
        return { x:canvasWidth/2 + x1*perspective, y:canvasHeight/2 + y2*perspective, scale:Math.max(0.1,perspective)};
      }

  function render(){ const canvas=canvasRef.current; if(!canvas) return; const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height); if(vpData.length===0){ ctx.fillStyle='#ffd93d'; ctx.font='16px monospace'; ctx.textAlign='center'; ctx.fillText(isLoading?'Loading matrix data...':'No matrix data yet', canvas.width/2, canvas.height/2); return; } ctx.save(); if(currentView==='2d'){ ctx.translate(offsetXRef.current, offsetYRef.current); ctx.scale(zoomRef.current, zoomRef.current); render2D(ctx); } else { // 3D: scale about canvas center so mother stays fixed
    offsetXRef.current = 0; offsetYRef.current = 0; const cx=canvas.width/2, cy=canvas.height/2; ctx.translate(cx, cy); ctx.scale(zoomRef.current, zoomRef.current); ctx.translate(-cx, -cy); render3D(ctx); } ctx.restore(); }
      
  // Picking removed.

  function render2D(ctx){
    // Auto-center once using bounding box of current layout (logical coordinates before zoom/offset transforms applied above)
    if(!centered2DRef.current && vpData.length){
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity; vpData.forEach(p=>{ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; });
      const boxW=maxX-minX, boxH=maxY-minY; const canvas=canvasRef.current; if(canvas){
        const targetX = canvas.width/2 - (minX + boxW/2);
        const targetY = canvas.height/2 - (minY + boxH/2);
        offsetXRef.current = targetX; offsetYRef.current = targetY; centered2DRef.current = true; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.translate(offsetXRef.current, offsetYRef.current); ctx.scale(zoomRef.current, zoomRef.current);
      }
    }
    ctx.strokeStyle='#444'; ctx.lineWidth=1/zoomRef.current; ctx.beginPath(); connectionData.forEach(conn=>{ const fromPos=vpData.find(p=>p.id===conn.from); const toPos=vpData.find(p=>p.id===conn.to); if(fromPos && toPos){ ctx.moveTo(fromPos.x, fromPos.y); ctx.lineTo(toPos.x, toPos.y);} }); ctx.stroke(); const vpStatus = getCompleteVPPositions(vpData); const ownedSet = userOwnedIdsRef.current; vpData.forEach(pos=>{ let dotSize=2/zoomRef.current; const isPaid=vpStatus.paid.includes(pos.id); const owned=ownedSet.has(pos.id); if(owned && !isPaid){ ctx.fillStyle='#0080ff'; dotSize += 1/zoomRef.current; } else if(isPaid){ ctx.fillStyle='#ff0000'; } else { ctx.fillStyle='#00ff00'; } drawHexagon(ctx,pos.x,pos.y,dotSize); }); }

  function render3D(ctx){ const canvas=canvasRef.current; if(!canvas) return; const dpr=window.devicePixelRatio||1; const logicalW=canvas.width/dpr; const logicalH=canvas.height/dpr;
    // Identify cycle root id (mother): first id after EOL (or 1)
    const motherId = (lastEOL && Number(lastEOL) > 0) ? Number(lastEOL)+1 : 1;
    const mother = vpData.find(p=>p.id===motherId);
    const mx = mother?mother.x:0, my=mother?mother.y:0, mz=mother?mother.z:0;
    // Project with mother translated to origin so she is always centered
    const projected=vpData.map(pos=>{ const pr=project3DTo2D(pos.x-mx,pos.y-my,pos.z-mz,logicalW,logicalH); return {...pos, projectedX:pr.x, projectedY:pr.y, scale:pr.scale}; });
    // 3D already projects around canvas center (project3DTo2D adds canvasWidth/2, canvasHeight/2).
    // Previous auto-centering double-shifted the layout. We only center by keeping offset refs at 0.
    centered3DRef.current = true; // mark so reCenter won't attempt old logic
    lastProjectedRef.current = projected.map(p=>({id:p.id,x:p.projectedX,y:p.projectedY})); projected.sort((a,b)=>b.z - a.z); ctx.strokeStyle='#444'; ctx.lineWidth=1/zoomRef.current; ctx.beginPath(); connectionData.forEach(conn=>{ const fromPos=projected.find(p=>p.id===conn.from); const toPos=projected.find(p=>p.id===conn.to); if(fromPos && toPos){ ctx.moveTo(fromPos.projectedX, fromPos.projectedY); ctx.lineTo(toPos.projectedX, toPos.projectedY);} }); ctx.stroke(); const vpStatus=getCompleteVPPositions(vpData); const ownedSet=userOwnedIdsRef.current; projected.forEach(pos=>{ let dotSize=2/zoomRef.current; const isPaid=vpStatus.paid.includes(pos.id); const owned=ownedSet.has(pos.id); if(owned && !isPaid){ ctx.fillStyle='#0080ff'; dotSize += 1/zoomRef.current; } else if(isPaid){ ctx.fillStyle='#ff0000'; } else { ctx.fillStyle='#00ff00'; } drawHexagon(ctx,pos.projectedX,pos.projectedY,dotSize); }); }

      function drawHexagon(ctx,x,y,size){ ctx.beginPath(); for(let i=0;i<6;i++){ const angle=(Math.PI/3)*i; const px=x+size*Math.cos(angle); const py=y+size*Math.sin(angle); if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.closePath(); ctx.fill(); }
      function drawDiamond(ctx,x,y,size){ ctx.beginPath(); ctx.moveTo(x,y-size); ctx.lineTo(x+size,y); ctx.lineTo(x,y+size); ctx.lineTo(x-size,y); ctx.closePath(); ctx.fill(); }

  // Picking and direct dot selection removed.

      function setupMouseEvents(canvas){
        // Helper to get mouse in canvas logical pixel space (after DPR scaling but before zoom/offset)
        function getMouse(e){
          const rect=canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          const scaleX = (canvas.width / dpr) / rect.width; // should be ~1
          const scaleY = (canvas.height / dpr) / rect.height;
          return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
          };
        }
        const handleMouseDown=(e)=>{ const m=getMouse(e); isDraggingRef.current=true; lastMouseXRef.current=m.x; lastMouseYRef.current=m.y; canvas.style.cursor='grabbing'; };
  const handleMouseMove=(e)=>{ const m=getMouse(e); if(!isDraggingRef.current){ canvas.style.cursor='grab'; return; } const dx=m.x-lastMouseXRef.current; const dy=m.y-lastMouseYRef.current; if(currentView==='2d'){ offsetXRef.current += dx; offsetYRef.current += dy; } else { rotationYRef.current += dx*0.01; rotationXRef.current += dy*0.01; } lastMouseXRef.current=m.x; lastMouseYRef.current=m.y; render(); };
        const handleMouseUp=()=>{ isDraggingRef.current=false; canvas.style.cursor='grab'; };
        const handleMouseLeave=()=>{ if(!isDraggingRef.current) canvas.style.cursor='grab'; };
  const handleClick=()=>{}; // disabled
        const handleWheel=(e)=>{ e.preventDefault(); const mCenter=getMouse(e); const oldZ=zoomRef.current; const factor = e.deltaY>0 ? 0.9 : 1.1; zoomRef.current *= factor; zoomRef.current = Math.max(0.1, Math.min(zoomRef.current, 5)); if(currentView==='2d'){ const change = zoomRef.current/oldZ; offsetXRef.current = mCenter.x - (mCenter.x - offsetXRef.current)*change; offsetYRef.current = mCenter.y - (mCenter.y - offsetYRef.current)*change; } // In 3D keep offsets at zero so mother stays centered
          render(); };
        canvas.addEventListener('mousedown',handleMouseDown);
        canvas.addEventListener('mousemove',handleMouseMove);
        canvas.addEventListener('mouseup',handleMouseUp);
        canvas.addEventListener('mouseleave',handleMouseLeave);
        canvas.addEventListener('click',handleClick);
        canvas.addEventListener('wheel',handleWheel);
        return ()=>{ canvas.removeEventListener('mousedown',handleMouseDown); canvas.removeEventListener('mousemove',handleMouseMove); canvas.removeEventListener('mouseup',handleMouseUp); canvas.removeEventListener('mouseleave',handleMouseLeave); canvas.removeEventListener('click',handleClick); canvas.removeEventListener('wheel',handleWheel); } }

  function getCompleteVPPositions(positions){
        const complete=[]; const paid=[]; const eol = lastEOL && Number(lastEOL) > 0 ? Number(lastEOL) : 0;
        positions.forEach(pos=>{
          const relative = pos.id - eol; // relative position inside current cycle
          let payPoint;
          if (eol > 0) {
            // Reset matrix: root behaves like original ID1, others follow normal VP payment schedule offset by eol
            payPoint = eol + getVPPaymentPoint(relative, matrixSize);
          } else {
            payPoint = getVPPaymentPoint(pos.id, matrixSize);
          }
          if (lastTokenId >= payPoint) { paid.push(pos.id); if(!complete.includes(pos.id)) complete.push(pos.id); }
        });
        return { complete, paid };
      }
  // Genealogy functions removed.

      const switchView = (view) => {
        setCurrentView(view);
        // Reset transforms; both views rely on layouts already centered
  offsetXRef.current = 0; offsetYRef.current = 0; rotationXRef.current = 0; rotationYRef.current = 0; centered2DRef.current = false; centered3DRef.current = false;
        if(vpData.length>0){
          const positions = view==='2d' ? calculate2DLayout(vpData,560,400) : calculate3DLayout(vpData);
          setVpData(positions);
        }
        setTimeout(()=>render(),0);
      };


      return (
        <div style={{ width: '100%' }}>
          <div style={{display:'flex',justifyContent:'center',marginBottom:'10px',gap:'10px'}}>
            <button
              onClick={()=>switchView('2d')}
              style={{
                padding: '8px 10px',
                fontSize: '.72rem',
                background: '#000',
                color: '#00ff00',
                border: '1.5px solid #00ff00',
                borderRadius: '10px',
                fontWeight: 700,
                letterSpacing: '0.03em',
                textTransform: 'uppercase',
                cursor: 'pointer',
                boxShadow: currentView==='2d'
                  ? '0 0 12px rgba(0,255,0,0.5), 0 0 0 2px rgba(0,255,0,0.35), 0 6px 18px rgba(0,255,0,0.18)'
                  : '0 6px 18px rgba(0,255,0,0.18)'
              }}
            >2D</button>
            <button
              onClick={()=>switchView('3d')}
              style={{
                padding: '8px 10px',
                fontSize: '.72rem',
                background: '#000',
                color: '#00ff00',
                border: '1.5px solid #00ff00',
                borderRadius: '10px',
                fontWeight: 700,
                letterSpacing: '0.03em',
                textTransform: 'uppercase',
                cursor: 'pointer',
                boxShadow: currentView==='3d'
                  ? '0 0 12px rgba(0,255,0,0.5), 0 0 0 2px rgba(0,255,0,0.35), 0 6px 18px rgba(0,255,0,0.18)'
                  : '0 6px 18px rgba(0,255,0,0.18)'
              }}
            >3D</button>
          </div>
          <div style={{ width:'100%', height:'400px', position:'relative', background:'radial-gradient(circle at center, #1a1a2e 0%, #0a0a0a 100%)', borderRadius:'0.5em', overflow:'hidden', marginBottom:'15px' }}>
            <canvas ref={canvasRef} style={{ width:'100%', height:'100%', cursor: isDraggingRef.current ? 'grabbing' : 'grab' }} />
            {/* Re-Center button removed */}
            <div style={{ position:'absolute', top:'10px', left:'10px', background:'rgba(0,0,0,0.8)', padding:'8px', borderRadius:'4px', fontSize:'11px', color:'#00ff00', fontFamily:'monospace' }}>
                <div>Matrix: {tokens[carouselIdx].name}</div>
                <div>Cycle Root ID: {lastEOL && Number(lastEOL) > 0 ? Number(lastEOL)+1 : 1}</div>
                <div>Active Entries (cycle): {vpData.length}</div>
                <div>Total Entries (global): {lastTokenId}</div>
                <div>View: {currentView.toUpperCase()}</div>
                <div>Zoom: {zoomRef.current.toFixed(1)}x</div>
              </div>
            <div style={{ position:'absolute', bottom:'10px', right:'10px', background:'rgba(0,0,0,0.8)', padding:'8px 10px', borderRadius:'4px', fontSize:'10px', color:'#ffd93d', fontFamily:'monospace', textAlign:'left', minWidth:'140px' }}>
              <div style={{marginBottom:'4px'}}>🖱️ {currentView==='2d' ? 'Drag to pan' : 'Drag to rotate'}</div>
              <div style={{marginBottom:'6px'}}>🔍 Scroll to zoom</div>
              <div style={{display:'flex',alignItems:'center',gap:'6px',color:'#0080ff',marginBottom:'2px'}}>
                <span style={{width:'10px',height:'10px',background:'#0080ff',display:'inline-block',transform:'rotate(45deg)'}}></span>
                <span>Your Open Entries</span>
              </div>
              <div style={{display:'flex',alignItems:'center',gap:'6px',color:'#00ff00',marginBottom:'2px'}}>
                <span style={{width:'10px',height:'10px',background:'#00ff00',display:'inline-block',borderRadius:'50%'}}></span>
                <span>Others (Active)</span>
              </div>
              <div style={{display:'flex',alignItems:'center',gap:'6px',color:'#ff0000'}}>
                <span style={{width:'10px',height:'10px',background:'#ff0000',display:'inline-block',borderRadius:'50%'}}></span>
                <span>Paid</span>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function ViewMatrixSection({ carouselIdx, tokens, account }) {
      const [initialized, setInitialized] = React.useState(false);
      const [loading, setLoading] = React.useState(false);
      const [userHasTokens, setUserHasTokens] = React.useState(false);
      const [show, setShow] = React.useState(false);

      React.useEffect(() => { checkUserTokens(); }, [carouselIdx, account]);
    async function checkUserTokens(){
        setLoading(true); setUserHasTokens(false);
        try {
          if (!tokens[carouselIdx]?.config || !account) { setLoading(false); return; }
          const cfg = tokens[carouselIdx].config;
      let provider = null;
      if (window.ethereum) {
        try { const wp = new ethers.providers.Web3Provider(window.ethereum); const net = await wp.getNetwork(); const cid = Number(net.chainId); if (cid === 943 || cid === 369) provider = wp; } catch {}
      }
      if (!provider) provider = new ethers.providers.JsonRpcProvider((window.PULSE_RPC && window.PULSE_RPC[943]) || 'https://rpc.v4.testnet.pulsechain.com');
          const vault = new ethers.Contract(cfg.vault, window.AllVaultABI[cfg.abiKey], provider);
          const receiptAddr = await vault.getReceiptContract();
          const rc = new ethers.Contract(receiptAddr, ["function balanceOf(address, uint256) view returns (uint256)"], provider);
          const nextId = Number(await vault.nextTokenId());
          let owned = 0;
          for (let id=1; id<nextId; id++){ try { const bal = await rc.balanceOf(account, id); if (bal && bal.toString() !== '0') owned++; } catch {} }
          const has = owned>0;
          setUserHasTokens(has);
          if (has && !initialized){ setInitialized(true); } // keep collapsed by default
        } catch { setUserHasTokens(false); }
        setLoading(false);
      }

      if (!tokens[carouselIdx].config) return null;

      return (
        <>
          <div style={{
            fontWeight:400,
            fontSize:'1.2em',
            color:'#fff',
            textAlign:'left',
            letterSpacing:'0.01em',
            display:'flex',
            alignItems:'center',
            width:'75%',
            boxSizing:'border-box',
            marginLeft:'auto',
            marginRight:'auto',
            marginBottom:'0.5em',
            justifyContent:'space-between'
          }}>
            <span style={{color:'#00ff00'}}>View the MATRIX:</span>
            <span onClick={()=> userHasTokens && setShow(!show)} style={{ fontSize:'0.9em', color: userHasTokens ? '#00ff00' : '#006600', cursor: userHasTokens ? 'pointer' : 'not-allowed', userSelect:'none' }}>
              {show ? '▼ Collapse' : '▶ Expand'}
            </span>
          </div>
          <div style={{display:'none'}}>
            <span>View the MATRIX:</span>
            <span onClick={()=> userHasTokens && setShow(!show)} style={{ fontSize:'0.9em', color: userHasTokens ? '#ccc' : '#666', cursor: userHasTokens ? 'pointer' : 'not-allowed', userSelect:'none' }}>
              {show ? '▼ Collapse' : '▶ Expand'}
            </span>
          </div>
          <div className="VIEW-card">
            <div style={{paddingLeft:'5%'}}>
              {loading ? (
                <div style={{color:'#00ff00', fontSize:'1.05em'}}>Checking matrix entries...</div>
              ) : userHasTokens ? (
                show ? (
                  <MatrixVisualizer carouselIdx={carouselIdx} tokens={tokens} account={account} />
                ) : (
                  <div style={{color:'#00ff00', fontSize:'1.05em', cursor:'pointer', padding:'18px'}} onClick={()=>setShow(true)}>
                    🔍 Click to view the Interactive 2D/3D MATRIX view of ALL positions.
                    <div style={{fontSize:'0.85em', color:'#888', marginTop:'6px'}}></div>
                  </div>
                )
              ) : (
                <div style={{color:'#888', fontSize:'1.05em'}}>Matrix visualization available after joining</div>
              )}
            </div>
          </div>
        </>
      );
    }

    // --- DEVELOPER Section (Developer Tools) ---
    function DeveloperSection({ carouselIdx, tokens, account, refreshStats }) {
      const [expanded, setExpanded] = React.useState(false);
      const [isAuthenticated, setIsAuthenticated] = React.useState(false);
      const [passwordAttempts, setPasswordAttempts] = React.useState(0);
      const [statusMessage, setStatusMessage] = React.useState('');
      const [passwordInput, setPasswordInput] = React.useState('');
      
      // Password configuration
      const DEV_PASSWORD = "5555";
      const MAX_ATTEMPTS = 3;
      
      // Handle expand/collapse
      const handleToggle = () => {
        if (!expanded) {
          setExpanded(true);
        } else {
          setExpanded(false);
        }
      };

      // Handle password submission
      const handlePasswordSubmit = (e) => {
        e.preventDefault();
        
        if (passwordAttempts >= MAX_ATTEMPTS) {
          setStatusMessage(`🚫 Access denied. Too many failed attempts (${MAX_ATTEMPTS}). Refresh the page to try again.`);
          return;
        }
        
        if (passwordInput === DEV_PASSWORD) {
          setIsAuthenticated(true);
          setStatusMessage('✅ Access granted! Welcome to Developer mode.');
          setPasswordInput('');
          setTimeout(() => setStatusMessage(''), 3000);
        } else {
          const newAttempts = passwordAttempts + 1;
          setPasswordAttempts(newAttempts);
          const remaining = MAX_ATTEMPTS - newAttempts;
          if (remaining > 0) {
            setStatusMessage(`❌ Incorrect password. ${remaining} attempt(s) remaining.`);
          } else {
            setStatusMessage(`🚫 Access denied. Maximum attempts (${MAX_ATTEMPTS}) reached. Refresh the page to try again.`);
          }
          setPasswordInput('');
          setTimeout(() => setStatusMessage(''), 5000);
        }
      };

      if (!tokens[carouselIdx].config) {
        return (
          <>
            {/* Developers Title aligned to DEV-card width */}
            <div style={{fontWeight:400, fontSize:'1.2em', color:'#fff', textAlign:'left', letterSpacing:'0.01em', display:'flex', alignItems:'center', width:'75%', boxSizing:'border-box', marginLeft:'auto', marginRight:'auto', marginBottom:'0.5em'}}>Developers</div>

            <div className="DEV-card">
              <div style={{paddingLeft:'5%'}}>
                <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',marginBottom:'0.5em'}}>
                  <span style={{fontWeight:400, fontSize:'0.9em', color:'#ccc'}}>
                    {isAuthenticated ? 'Developer tools unlocked 🔓' : 'Password required 🔒'}
                    {passwordAttempts > 0 && !isAuthenticated && (
                      <span style={{marginLeft:'0.5em',fontSize:'0.7em',color:'#ff6b6b'}}>({passwordAttempts}/{MAX_ATTEMPTS})</span>
                    )}
                  </span>
                  <span onClick={handleToggle} style={{cursor:'pointer', fontSize:'0.9em', color:'#ccc', userSelect:'none'}}>
                    {expanded ? '▼ Collapse' : '▶ Expand'}
                  </span>
                </div>
                {expanded && (
                  <>
                    {statusMessage && (
                      <div style={{
                        marginBottom:'1em',
                        padding:'0.8em',
                        borderRadius:'0.5em',
                        fontSize:'0.9em',
                        fontWeight:500,
                        background: statusMessage.includes('✅') ? 'rgba(0,255,136,0.1)' : 'rgba(255,107,107,0.1)',
                        color: statusMessage.includes('✅') ? '#00ff88' : '#ff6b6b'
                      }}>
                        {statusMessage}
                      </div>
                    )}
                    
                    {!isAuthenticated ? (
                      <form onSubmit={handlePasswordSubmit} style={{marginBottom:'1em'}}>
                        <div style={{marginBottom:'0.5em',color:'#ccc',fontSize:'0.9em'}}>Enter developer password:</div>
                        <div style={{display:'flex',gap:'0.5em'}}>
                          <input
                            type="password"
                            value={passwordInput}
                            onChange={(e) => setPasswordInput(e.target.value)}
                            disabled={passwordAttempts >= MAX_ATTEMPTS}
                            style={{
                              flex:1,
                              padding:'0.5em',
                              borderRadius:'0.3em',
                              border:'1px solid #444',
                              background:'rgba(255,255,255,0.1)',
                              color:'#fff',
                              fontSize:'0.9em'
                            }}
                            placeholder="Password..."
                          />
                          <button
                            type="submit"
                            disabled={!passwordInput || passwordAttempts >= MAX_ATTEMPTS}
                            style={{
                              padding:'0.5em 1em',
                              borderRadius:'0.3em',
                              border:'none',
                              background: passwordInput && passwordAttempts < MAX_ATTEMPTS ? '#4CAF50' : '#666',
                              color:'#fff',
                              cursor: passwordInput && passwordAttempts < MAX_ATTEMPTS ? 'pointer' : 'not-allowed',
                              fontSize:'0.9em'
                            }}
                          >
                            Unlock
                          </button>
                        </div>
                      </form>
                    ) : (
                      <div style={{color:'#ff6b6b'}}>No contract config loaded.</div>
                    )}
                  </>
                )}
              </div>
            </div>
          </>
        );
      }

      const cfg = tokens[carouselIdx].config;
      const abi = window.AllVaultABI && window.AllVaultABI[cfg.abiKey] ? window.AllVaultABI[cfg.abiKey] : [];
      // Build categorized function lists for Developer view (dedupe entryFee vs ENTRY_FEE)
      const allFns = abi.filter(x => x && x.type === 'function');
      const nameSet = new Set(allFns.map(x => x.name));
      const filteredFns = allFns.filter(x => !(x.name === 'entryFee' && nameSet.has('ENTRY_FEE')));
      const fnTotal = filteredFns.length;
      const actions = filteredFns
        .filter(x => x.stateMutability === 'nonpayable')
        .map(x => x.name)
        .sort();
      const coreNames = new Set([
        'ENTRY_FEE','PAYOUT_AMOUNT','EOLActive','EOLBatchSize','VP_SIZE','FULL_VP_SIZE','TOKEN','RECEIPT',
        'unpaidOpenEntries','nextTokenId','lastTokenId','isEOLActive','isPaid'
      ]);
      const isUpper = (s) => s && s.toUpperCase && s === s.toUpperCase();
      const views = filteredFns.filter(x => x.stateMutability === 'view');
      const coreConsts = views
        .filter(x => coreNames.has(x.name) || isUpper(x.name))
        .map(x => x.name)
        .sort();
      const helpers = views
        .filter(x => /^get/.test(x.name) || x.name === 'MY_STATUS')
        .map(x => x.name)
        .sort();
      const rawStorage = views
        .filter(x => !coreConsts.includes(x.name) && !helpers.includes(x.name))
        .map(x => x.name)
        .sort();
      
      const [vaultData, setVaultData] = React.useState(null);
      const [eolDebug, setEolDebug] = React.useState({});

      React.useEffect(() => {
        async function fetchDebugData() {
          // Only fetch debug data if wallet is connected to prevent circuit breaker errors
          if (!window.ethereum || !account) {
            setVaultData(null);
            setEolDebug({});
            return;
          }
          
          try {
            // Use the current read provider (selected network)
            let provider = null;
            try { provider = getReadProvider(); } catch {}
            if (!provider) {
              const wanted = Number(window.__READ_CHAIN_ID || localStorage.getItem('READ_CHAIN_ID') || 943);
              const url = (window.PULSE_RPC && window.PULSE_RPC[wanted]) || (wanted===369 ? 'https://rpc.pulsechain.com' : 'https://rpc.v4.testnet.pulsechain.com');
              provider = new ethers.providers.JsonRpcProvider(url);
            }
            // Ensure contract exists on the current network before making calls
            const code = await provider.getCode(cfg.vault);
            if (code === '0x') {
              setVaultData(null);
              setEolDebug({ vaultAddress: cfg.vault, abiKey: cfg.abiKey, error: 'Vault not deployed on this network' });
              return;
            }
            const vault = new ethers.Contract(cfg.vault, abi, provider);
            let data = {};
            let eolTime = null, minEntries = null, currentEntries = 0;
            try { data.nextVPId = await vault.nextVPId ? await vault.nextVPId() : undefined; } catch {}
            try { data.nextTokenId = await vault.nextTokenId(); } catch {}
            try { data.EOLActive = await vault.isEOLActive(); } catch {}
            try { data.ENTRY_FEE = await vault.ENTRY_FEE(); } catch {}
            try { data.PAYOUT_AMOUNT = await vault.PAYOUT_AMOUNT(); } catch {}
            // Vault balance via ERC20/PRC20 to avoid any vault-side revert paths
            try {
              const tokenAddr = (await (async () => { try { return await vault.TOKEN(); } catch { return cfg.token; } })());
              const erc20 = new ethers.Contract(tokenAddr, ["function balanceOf(address) view returns (uint256)"], provider);
              data.vaultBalance = await erc20.balanceOf(cfg.vault);
            } catch {}
            
            try { data.lastEntryTimestamp = await vault.lastEntryTimestamp(); } catch {}
            try { data.VP_SIZE = await vault.VP_SIZE(); } catch {}
            
            // Core contract state
            try { data.TOKEN = await vault.TOKEN(); } catch {}
            try { data.entryFee = await vault.ENTRY_FEE(); } catch {}
            try { data.LastPaidVP = await vault.LastPaidVP(); } catch {}
            try { data.EOLTimestamp = await vault.EOLTimestamp(); } catch {}
            try { data.EOLVaultSnapshot = await vault.EOLVaultSnapshot(); } catch {}
            try { data.EOLOpenEntriesSnapshot = await vault.EOLOpenEntriesSnapshot(); } catch {}
            try { data.EOLCycleCount = await vault.EOLCycleCount(); } catch {}
            try { data.EOLProcessedCount = await vault.EOLProcessedCount(); } catch {}
            try { data.EOLProcessingComplete = await vault.EOLProcessingComplete(); } catch {}
            try { data.EOLBatchSize = await vault.EOLBatchSize(); } catch {}
            
            // System configuration
            try { 
              const config = await vault.getSystemConfiguration();
              data.systemConfig = {
                EOL_TRIGGER_REWARD: config.EOL_TRIGGER_REWARD,
                EOL_TRIGGER_DELAY: config.EOL_TRIGGER_DELAY,
                MIN_ENTRIES_FOR_EOL: config.MIN_ENTRIES_FOR_EOL,
                PAYOUT_MULTIPLIER: config.PAYOUT_MULTIPLIER,
                VP_SIZE: config.VP_SIZE,
                FULL_VP_SIZE: config.FULL_VP_SIZE,
                VAULT_RESERVE: config.VAULT_RESERVE,
                RESEARCH_ADDRESS: config.RESEARCH_ADDRESS
              };
            } catch {}
            
            // Additional utility functions
            try { data.canJoinVP = await vault.canJoinVP(); } catch {}
            try { data.canTriggerEOL = await vault.canTriggerEOL(); } catch {}
            try { data.getTotalEntriesMade = await vault.getTotalEntriesMade(); } catch {}
            try { data.getReceiptContract = await vault.getReceiptContract(); } catch {}
            try { data.EOLTriggerBonus = await vault.EOLTriggerBonus(); } catch {}
            try { data.getEOLTriggerTime = await vault.getEOLTriggerTime(); } catch {}
            try { data.getMinEntriesForEOL = await vault.getMinEntriesForEOL(); } catch {}
            try { data.getTimeUntilEOLAvailable = await vault.getTimeUntilEOLAvailable(); } catch {}
            // Total VPs created (new name only)
            try { data.getTotalVPsCreated = await vault.getTotalVPsCreated(); } catch {}
            
            // Matrix-specific information
            let matrixInfo = {
              isMatrix3x3: cfg.abiKey === 'PuMa3x3' || cfg.abiKey === 'PLS3x3',
              isMatrix4x4: cfg.abiKey === 'PuMa4x4' || cfg.abiKey === 'PLS4x4',
              matrixSize: data.VP_SIZE ? Number(data.VP_SIZE) : 'Unknown',
              isPuMaToken: cfg.name && cfg.name.includes('PuMa'),
              isPLSToken: cfg.name && cfg.name.includes('PLS'),
              sameTokenDifferentMatrix: false
            };
            
            // Check if same token is used across matrices
            if (window.coinConfigs) {
              const sameTokenConfigs = window.coinConfigs.filter(c => c.token === cfg.token);
              matrixInfo.sameTokenDifferentMatrix = sameTokenConfigs.length > 1;
              matrixInfo.sharedTokenConfigs = sameTokenConfigs.map(c => c.name);
            }
            
            data.matrixInfo = matrixInfo;
            
            // --- EOL Cycle Data ---
            try { data.getCurrentEOLCycle = await vault.getCurrentEOLCycle(); } catch {}
            try { data.EOLVaultSnapshot = await vault.EOLVaultSnapshot(); } catch {}
            try { data.EOLOpenEntriesSnapshot = await vault.EOLOpenEntriesSnapshot(); } catch {}
            
            try { data.EOLTimestamp = await vault.EOLTimestamp(); } catch {}
            
            // --- EOL Calculation Functions ---
            try { data.getEOLRewardPerEntry = await vault.getEOLRewardPerEntry(); } catch {}
            try { data.getEOLTotalPool = await vault.getEOLTotalPool(); } catch {}
            try { data.getTotalOpenEntries = await vault.getTotalOpenEntries(); } catch {}
            
            // --- Additional live contract data ---
            try { data.EOLTriggerBonus = await vault.EOLTriggerBonus(); } catch {}
            try { data.getEOLAvailable = await vault.getEOLAvailable ? await vault.getEOLAvailable() : undefined; } catch {}
            try { data.getEOLTriggerTime = await vault.getEOLTriggerTime ? await vault.getEOLTriggerTime() : undefined; } catch {}
            
            data.matrixInfo = matrixInfo;
            
            // --- Count Paid VPs (manual calculation
            try {
              let paidVPsCount = 0;
              let fullVPsCount = 0;
              const totalVPs = data.getTotalVPsCreated ? Number(data.getTotalVPsCreated) : 0;
              
              // Check each VP to see if it's been paid (limit for performance)
              const maxCheck = Math.min(totalVPs, 50); // Limit to first 50
              for (let i = 1; i <= maxCheck; i++) {
                try {
                  if (typeof vault.getVPBasicInfo !== 'function') break; // stop if new API absent
                  const vpInfo = await vault.getVPBasicInfo(i);
                  if (vpInfo && vpInfo.length >= 3) {
                    const [currentIndex, full, paid] = vpInfo;
                    if (full === true) fullVPsCount++;
                    if (paid === true) paidVPsCount++;
                  }
                } catch { /* skip individual index errors */ }
              }
              data.paidVPsCount = paidVPsCount;
              data.fullVPsCount = fullVPsCount;
              data.checkedVPsRange = `1-${maxCheck}`;
            } catch {}
            
            // --- Fetch actual entry count for EOL logic ---
            try { currentEntries = data.nextTokenId !== undefined && data.nextTokenId !== null ? Number(data.nextTokenId) - 1 : 0; } catch {}
            // --- Fetch MIN_ENTRIES_FOR_EOL from contract if available ---
            try { 
              if (vault.getMinEntriesForEOL) {
                data.MIN_ENTRIES_FOR_EOL = await vault.getMinEntriesForEOL();
              } else {
                const params = await vault.params();
                if (params && params.MIN_ENTRIES_FOR_EOL) {
                  data.MIN_ENTRIES_FOR_EOL = params.MIN_ENTRIES_FOR_EOL;
                }
              }
            } catch {}
            if (data.MIN_ENTRIES_FOR_EOL !== undefined && data.MIN_ENTRIES_FOR_EOL !== null) {
              minEntries = Number(data.MIN_ENTRIES_FOR_EOL);
            } else if (cfg && cfg.MIN_ENTRIES_FOR_EOL) {
              minEntries = Number(cfg.MIN_ENTRIES_FOR_EOL);
            } else {
              minEntries = 6;
            }
            let t = data.getEOLTriggerTime;
            if (t !== undefined && t !== null) {
              let n = 0;
              if (typeof t === 'object' && t._isBigNumber) n = Number(t.toString());
              else if (typeof t === 'string' || typeof t === 'number') n = Number(t);
              if (!isNaN(n) && n > 1000000000 && n < 9999999999) eolTime = n;
            }
            const now = Math.floor(Date.now()/1000);
            const canEOL = eolTime && now > eolTime;
            const minEntriesMet = currentEntries >= minEntries;
            
            // Check if user has entries in open VPs (required for EOL trigger)
            let hasOpenEntries = false;
            let openEntriesCount = 0;
            let openEntriesError = null;
            
            // Use UNIFIED user entry function instead of duplicate logic
            if (account) {
              try {
                openEntriesCount = 0; // Simplified for now
                hasOpenEntries = openEntriesCount > 0;
              } catch (error) {
                openEntriesError = error.message;
              }
            }
            
            setVaultData(data);
            setEolDebug({
              eolTime, 
              now, 
              minEntries, 
              currentEntries, 
              canEOL, 
              minEntriesMet, 
              hasOpenEntries,
              openEntriesCount: Number(openEntriesCount),
              openEntriesError,
              vaultAddress: cfg.vault, 
              abiKey: cfg.abiKey, 
              EOLActive: data.EOLActive 
            });
          } catch {}
        }
        fetchDebugData();
      }, [cfg.vault, abi, account]);

      // Date formatting helper
      function formatDate(timestamp) {
        if (!timestamp || timestamp === 0) return 'Never';
        return new Date(timestamp * 1000).toLocaleString();
      }

      return (
        <>
          {/* Developers Title aligned to DEV-card width with top-right expand */}
          <div style={{fontWeight:400, fontSize:'1.2em', color:'#00ff00', textAlign:'left', letterSpacing:'0.01em', display:'flex', alignItems:'center', justifyContent:'space-between', width:'75%', boxSizing:'border-box', marginLeft:'auto', marginRight:'auto', marginBottom:'0.5em'}}>
            <span>Developers:</span>
            <span onClick={handleToggle} style={{cursor:'pointer', fontSize:'0.9em', color:'#00ff00', userSelect:'none'}}>{expanded ? '▼ Collapse' : '▶ Expand'}</span>
          </div>

          <div className="DEV-card">
            <div style={{paddingLeft:'5%'}}>
              {!expanded && (
                <div
                  style={{color:'#00ff00', fontSize:'1.05em', cursor:'pointer', padding:'18px'}}
                  onClick={handleToggle}
                >
                  🔒 Password required — click to unlock developer tools.
                  <div style={{fontSize:'0.85em', color:'#888', marginTop:'6px'}}></div>
                </div>
              )}
              
              {expanded && (
                <>
                  {statusMessage && (
                    <div style={{
                      marginBottom:'1em',
                      padding:'0.8em',
                      borderRadius:'0.5em',
                      fontSize:'0.9em',
                      fontWeight:500,
                      background: statusMessage.includes('✅') ? 'rgba(0,255,136,0.1)' : 'rgba(255,107,107,0.1)',
                      color: statusMessage.includes('✅') ? '#00ff88' : '#ff6b6b'
                    }}>
                      {statusMessage}
                    </div>
                  )}
                  
                  {!isAuthenticated ? (
                    <form onSubmit={handlePasswordSubmit} style={{marginBottom:'1em'}}>
                      <div style={{marginBottom:'0.5em',color:'#ccc',fontSize:'0.9em'}}>Enter developer password:</div>
                      <div style={{display:'flex',gap:'0.5em'}}>
                        <input
                          type="password"
                          value={passwordInput}
                          onChange={(e) => setPasswordInput(e.target.value)}
                          disabled={passwordAttempts >= MAX_ATTEMPTS}
                          style={{
                            flex:1,
                            padding:'0.5em',
                            borderRadius:'0.3em',
                            border:'1px solid #444',
                            background:'rgba(255,255,255,0.1)',
                            color:'#fff',
                            fontSize:'0.9em'
                          }}
                          placeholder="Password..."
                        />
                        <button
                          type="submit"
                          disabled={!passwordInput || passwordAttempts >= MAX_ATTEMPTS}
                          style={{
                            padding:'0.5em 1em',
                            borderRadius:'0.3em',
                            border:'none',
                            background: passwordInput && passwordAttempts < MAX_ATTEMPTS ? '#4CAF50' : '#666',
                            color:'#fff',
                            cursor: passwordInput && passwordAttempts < MAX_ATTEMPTS ? 'pointer' : 'not-allowed',
                            fontSize:'0.9em'
                          }}
                        >
                          Unlock
                        </button>
                      </div>
                    </form>
                  ) : (
                    <div>
                      {/* Contract Address Info */}
                      <div style={{marginBottom:'1em',color:'#9f9',fontSize:'0.9em',borderBottom:'1px solid #333',paddingBottom:'0.5em'}}>
                        <div><strong>Contract:</strong> {cfg.name} ({cfg.abiKey})</div>
                        <div><strong>Vault:</strong> {cfg.vault}</div>
                        <div><strong>Token:</strong> {cfg.token}</div>
                        <div><strong>Receipt:</strong> {cfg.receipt}</div>
                        <div><strong>Functions:</strong> {fnTotal} found</div>
                      </div>

                      {/* Live Contract Data */}
                      {vaultData ? (
                        <div style={{marginBottom:'1em'}}>
                          <div style={{marginBottom:'1em',fontSize:'1em',fontWeight:500,color:'#4CAF50',borderBottom:'1px solid #333',paddingBottom:'0.5em'}}>
                            📊 MATRIX SYSTEM INFO
                          </div>

                          {/* Matrix Information */}
                          {vaultData.matrixInfo && (
                            <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(0,100,255,0.1)',border:'1px solid #0064ff',borderRadius:'0.5em'}}>
                              <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#0088ff',fontWeight:'bold'}}>🔷 MATRIX CONFIGURATION:</div>
                              <div>• Matrix Type: <span style={{color:'#ffd93d'}}>{vaultData.matrixInfo.isMatrix3x3 ? '3x3' : vaultData.matrixInfo.isMatrix4x4 ? '4x4' : 'Unknown'}</span></div>
                              <div>• Matrix Size (VP_SIZE): <span style={{color:'#ffd93d'}}>{vaultData.VP_SIZE ? Number(vaultData.VP_SIZE) : 'Loading...'}</span></div>
                              <div>• Token Type: <span style={{color:'#ffd93d'}}>{vaultData.matrixInfo.isPuMaToken ? 'PuMa' : vaultData.matrixInfo.isPLSToken ? 'PLS' : 'Unknown'}</span></div>
                              <div>• Auto-Pay System: <span style={{color:'#4CAF50'}}>✅ 100% AUTOMATIC</span></div>
                              {vaultData.matrixInfo.sameTokenDifferentMatrix && (
                                <div>• Shared Token Usage: <span style={{color:'#ffd93d'}}>Used across {vaultData.matrixInfo.sharedTokenConfigs?.join(', ')}</span></div>
                              )}
                            </div>
                          )}

                          {/* Core Contract State */}
                          <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(255,193,7,0.1)',border:'1px solid #ffc107',borderRadius:'0.5em'}}>
                            <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#ffc107',fontWeight:'bold'}}>💰 CORE CONTRACT STATE:</div>
                            {vaultData.ENTRY_FEE && (
                              <div>• Entry Fee: <span style={{color:'#ffd93d'}}>{formatAmount(vaultData.ENTRY_FEE, cfg.decimals)} {tokens[carouselIdx].name}</span></div>
                            )}
                            {vaultData.PAYOUT_AMOUNT && (
                              <div>• Payout Amount: <span style={{color:'#ffd93d'}}>{formatAmount(vaultData.PAYOUT_AMOUNT, cfg.decimals)} {tokens[carouselIdx].name}</span></div>
                            )}
                            {vaultData.vaultBalance && (
                              <div>• Vault Balance: <span style={{color:'#ffd93d'}}>{formatAmount(vaultData.vaultBalance, cfg.decimals)} {tokens[carouselIdx].name}</span></div>
                            )}
                            
                            {vaultData.nextTokenId && (
                              <div>• Next Token ID: <span style={{color:'#ffd93d'}}>{Number(vaultData.nextTokenId)}</span></div>
                            )}
                            {vaultData.LastPaidVP !== undefined && (
                              <div>• Last Paid VP: <span style={{color:'#ffd93d'}}>{vaultData.LastPaidVP ? Number(vaultData.LastPaidVP) : '0'}</span></div>
                            )}
                          </div>

                          {/* Token & Entry Information */}
                          <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(0,255,136,0.1)',border:'1px solid #00ff88',borderRadius:'0.5em'}}>
                            <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#00ff88',fontWeight:'bold'}}>🎫 TOKEN & ENTRY INFO:</div>
                            {vaultData.TOKEN && (
                              <div>• Token Contract: <span style={{color:'#ffd93d'}}>{vaultData.TOKEN.slice(0,6)}...{vaultData.TOKEN.slice(-4)}</span></div>
                            )}
                            {vaultData.getReceiptContract && (
                              <div>• Receipt Contract: <span style={{color:'#ffd93d'}}>{vaultData.getReceiptContract.slice(0,6)}...{vaultData.getReceiptContract.slice(-4)}</span></div>
                            )}
                            {vaultData.getTotalEntriesMade !== undefined && (
                              <div>• Total Entries Made: <span style={{color:'#ffd93d'}}>{vaultData.getTotalEntriesMade ? Number(vaultData.getTotalEntriesMade) : '0'}</span></div>
                            )}
                            {vaultData.lastEntryTimestamp && (
                              <div>• Last Entry Time: <span style={{color:'#ffd93d'}}>{formatDate(Number(vaultData.lastEntryTimestamp))}</span></div>
                            )}
                            {vaultData.canJoinVP !== undefined && (
                              <div>• Can Join VP: <span style={{color: vaultData.canJoinVP ? '#4CAF50' : '#ff6b6b'}}>{vaultData.canJoinVP ? '✅ Yes' : '❌ No'}</span></div>
                            )}
                          </div>

                          {/* EOL Emergency System */}
                          <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(255,107,107,0.1)',border:'1px solid #ff6b6b',borderRadius:'0.5em'}}>
                            <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#ff6b6b',fontWeight:'bold'}}>🚨 EOL EMERGENCY SYSTEM:</div>
                            {vaultData.EOLActive !== undefined && (
                              <div>• EOL Status: <span style={{color: vaultData.EOLActive ? '#ff6b6b' : '#4CAF50'}}>{vaultData.EOLActive ? '🧡 Active' : '💚 Standby'}</span></div>
                            )}
                            {vaultData.EOLCycleCount !== undefined && (
                              <div>• EOL Cycle Count: <span style={{color:'#ffd93d'}}>{vaultData.EOLCycleCount ? Number(vaultData.EOLCycleCount) : '0'}</span></div>
                            )}
                            {vaultData.EOLProcessedCount !== undefined && (
                              <div>• EOL Processed Count: <span style={{color:'#ffd93d'}}>{vaultData.EOLProcessedCount ? Number(vaultData.EOLProcessedCount) : '0'}</span></div>
                            )}
                            {vaultData.EOLProcessingComplete !== undefined && (
                              <div>• EOL Processing Complete: <span style={{color: vaultData.EOLProcessingComplete ? '#4CAF50' : '#ffc107'}}>{vaultData.EOLProcessingComplete ? '✅ Yes' : '⏳ No'}</span></div>
                            )}
                            {vaultData.EOLVaultSnapshot && (
                              <div>• EOL Vault Snapshot: <span style={{color:'#ffd93d'}}>{formatAmount(vaultData.EOLVaultSnapshot, cfg.decimals)} {tokens[carouselIdx].name}</span></div>
                            )}
                            {vaultData.EOLOpenEntriesSnapshot !== undefined && (
                              <div>• EOL Open Entries: <span style={{color:'#ffd93d'}}>{vaultData.EOLOpenEntriesSnapshot ? Number(vaultData.EOLOpenEntriesSnapshot) : '0'}</span></div>
                            )}
                            {vaultData.EOLBatchSize !== undefined && (
                              <div>• EOL Batch Size: <span style={{color:'#ffd93d'}}>{vaultData.EOLBatchSize ? Number(vaultData.EOLBatchSize) : 'Loading...'}</span></div>
                            )}
                            {vaultData.canTriggerEOL !== undefined && (
                              <div>• Can Trigger EOL: <span style={{color: vaultData.canTriggerEOL ? '#4CAF50' : '#ff6b6b'}}>{vaultData.canTriggerEOL ? '✅ Yes' : '❌ No'}</span></div>
                            )}
                            {vaultData.EOLTriggerBonus && (
                              <div>• EOL Trigger Reward: <span style={{color:'#ffd93d'}}>{formatAmount(vaultData.EOLTriggerBonus, cfg.decimals)} {tokens[carouselIdx].name}</span></div>
                            )}
                          </div>

                          {/* System Configuration */}
                          {vaultData.systemConfig && (
                            <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(156,39,176,0.1)',border:'1px solid #9c27b0',borderRadius:'0.5em'}}>
                              <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#9c27b0',fontWeight:'bold'}}>⚙️ SYSTEM CONFIGURATION:</div>
                              {/* Compute the live factor from on-chain reward and entry fee to avoid param-scaling drift across deployments */}
                              {(() => {
                                try {
                                  const bonus = vaultData.EOLTriggerBonus ? ethers.BigNumber.from(vaultData.EOLTriggerBonus) : null;
                                  const fee = vaultData.ENTRY_FEE ? ethers.BigNumber.from(vaultData.ENTRY_FEE) : null;
                                  const decimals = cfg.decimals || 18;
                                  const factor = (bonus && fee) ? (parseFloat(ethers.utils.formatUnits(bonus, decimals)) / parseFloat(ethers.utils.formatUnits(fee, decimals))) : null;
                                  const factorText = factor != null && isFinite(factor) ? factor.toFixed(4) + 'x' : ((Number(vaultData.systemConfig.EOL_TRIGGER_REWARD) / 10000).toFixed(4) + 'x');
                                  const bonusText = bonus ? formatAmount(bonus, decimals) : 'Loading...';
                                  return (
                                    <div>
                                      • EOL Trigger Reward Factor: <span style={{color:'#ffd93d'}}>{factorText} = {bonusText} {tokens[carouselIdx].name}</span>
                                    </div>
                                  );
                                } catch {
                                  return (
                                    <div>
                                      • EOL Trigger Reward Factor: <span style={{color:'#ffd93d'}}>{(Number(vaultData.systemConfig.EOL_TRIGGER_REWARD) / 10000).toFixed(4)}x</span>
                                    </div>
                                  );
                                }
                              })()}
                              <div>• EOL Trigger Delay: <span style={{color:'#ffd93d'}}>{Number(vaultData.systemConfig.EOL_TRIGGER_DELAY)} seconds</span></div>
                              <div>• Min Entries for EOL: <span style={{color:'#ffd93d'}}>{Number(vaultData.systemConfig.MIN_ENTRIES_FOR_EOL)}</span></div>
                              <div>• Payout Multiplier: <span style={{color:'#ffd93d'}}>{Number(vaultData.systemConfig.PAYOUT_MULTIPLIER)}</span></div>
                              <div>• Full VP Size: <span style={{color:'#ffd93d'}}>{Number(vaultData.systemConfig.FULL_VP_SIZE)}</span></div>
                              {vaultData.systemConfig.RESEARCH_ADDRESS && (
                                <div>• Research Address: <span style={{color:'#ffd93d'}}>{vaultData.systemConfig.RESEARCH_ADDRESS.slice(0,6)}...{vaultData.systemConfig.RESEARCH_ADDRESS.slice(-4)}</span></div>
                              )}
                            </div>
                          )}

                          {/* Contract Functions List */}
                          {/* Grouped functions with matrix-green styling */}
                          <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(0,255,0,0.06)',border:'1px solid rgba(0,255,0,0.20)',borderRadius:'0.5em'}}>
                            <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#00ff00',fontWeight:'bold'}}>🛠️ ACTIONS ({actions.length}):</div>
                            {actions.length ? (
                              <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'0.2em',fontSize:'0.8em',fontFamily:'monospace',color:'#9f9'}}>
                                {actions.map((fn, idx) => <div key={'act_'+idx} style={{padding:'0.1em 0'}}>{fn}()</div>)}
                              </div>
                            ) : (
                              <div style={{fontSize:'0.8em',color:'#6f6'}}>No state-changing functions exposed.</div>
                            )}
                          </div>
                          <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(0,255,0,0.06)',border:'1px solid rgba(0,255,0,0.20)',borderRadius:'0.5em'}}>
                            <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#00ff00',fontWeight:'bold'}}>📦 CORE CONSTANTS ({coreConsts.length}):</div>
                            <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'0.2em',fontSize:'0.8em',fontFamily:'monospace',color:'#9f9'}}>
                              {coreConsts.map((fn, idx) => <div key={'core_'+idx} style={{padding:'0.1em 0'}}>{fn}()</div>)}
                            </div>
                          </div>
                          <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(0,255,0,0.06)',border:'1px solid rgba(0,255,0,0.20)',borderRadius:'0.5em'}}>
                            <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#00ff00',fontWeight:'bold'}}>🧮 COMPUTED HELPERS ({helpers.length}):</div>
                            <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'0.2em',fontSize:'0.8em',fontFamily:'monospace',color:'#9f9'}}>
                              {helpers.map((fn, idx) => <div key={'help_'+idx} style={{padding:'0.1em 0'}}>{fn}()</div>)}
                            </div>
                          </div>
                          <div style={{marginBottom:'0.8em',padding:'0.8em',background:'rgba(0,255,0,0.06)',border:'1px solid rgba(0,255,0,0.20)',borderRadius:'0.5em'}}>
                            <div style={{fontSize:'0.9em',marginBottom:'0.3em',color:'#00ff00',fontWeight:'bold'}}>🧱 RAW STORAGE GETTERS ({rawStorage.length}):</div>
                            <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'0.2em',fontSize:'0.8em',fontFamily:'monospace',color:'#9f9'}}>
                              {rawStorage.map((fn, idx) => <div key={'raw_'+idx} style={{padding:'0.1em 0'}}>{fn}()</div>)}
                            </div>
                          </div>

                          {/* Contract Address Reference */}
                          <div style={{marginBottom:'1em'}}>
                            <div style={{color:'#ff00ff',fontWeight:'bold',marginBottom:'0.5em'}}>📋 CONTRACT REFERENCE</div>
                            <div style={{fontSize:'0.8em',color:'#ccc'}}>
                              <div>Vault: {cfg.vault}</div>
                              <div>Token: {cfg.token}</div>
                              <div>Receipt: {cfg.receipt}</div>
                            </div>
                          </div>
                        </div>
                      ) : (
                        <div style={{color:'#888'}}>Loading contract data...</div>
                      )}
                    </div>
                  )}
                </>
              )}
            </div>
          </div>
        </>
      );
    }

    // --- Countdown component for next claim (1 hour window) ---
    function Countdown({ lastClaim }) {
      const [now, setNow] = React.useState(Date.now());
      React.useEffect(() => {
        const t = setInterval(() => setNow(Date.now()), 1000);
        return () => clearInterval(t);
      }, []);
      const msLeft = Math.max(0, 3600_000 - (now - lastClaim));
      const min = Math.floor(msLeft / 60000);
      const sec = Math.floor((msLeft % 60000) / 1000);
      return (
        <div style={{ fontSize: '0.8em', color: '#00ff00', textShadow: '0 0 6px rgba(0,255,0,0.3)' }}>
          Next claim in {min}:{sec.toString().padStart(2, '0')}
        </div>
      );
    }

    ReactDOM.render(<PuMaDappCarousel />, document.getElementById('react-root'));
    console.log('React app rendered successfully!');
  </script>
</body>
</html>
